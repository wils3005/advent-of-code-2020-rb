# This file is autogenerated. Do not edit it by hand. Regenerate it with:
#   srb rbi hidden-definitions

# typed: autogenerated

class Addrinfo
  def connect_internal(local_addrinfo, timeout=T.unsafe(nil)); end
end

class Array
  include ::JSON::Ext::Generator::GeneratorMethods::Array
  def deconstruct(); end

  def shelljoin(); end

  def to_csv(**options); end

  def to_h(); end
end

class Array
  def self.try_convert(_); end
end

BasicObject::BasicObject = BasicObject

class BasicSocket
  def read_nonblock(len, str=T.unsafe(nil), exception: T.unsafe(nil)); end
end

class BigDecimal
  def clone(); end
  EXCEPTION_NaN = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class BigDecimal
  def self.interpret_loosely(_); end
end

class Binding
  def clone(); end

  def irb(); end
end

class Bundler::Dependency
  def branch(); end

  def expanded_platforms(); end

  def git(); end
end

Bundler::Deprecate = Gem::Deprecate

class Bundler::Env
end

class Bundler::Env
  def self.environment(); end

  def self.report(options=T.unsafe(nil)); end

  def self.write(io); end
end

class Bundler::Fetcher
  def fetch_spec(spec); end

  def fetchers(); end

  def http_proxy(); end

  def initialize(remote); end

  def specs(gem_names, source); end

  def specs_with_retry(gem_names, source); end

  def uri(); end

  def use_api(); end

  def user_agent(); end
  FAIL_ERRORS = ::T.let(nil, ::T.untyped)
  FETCHERS = ::T.let(nil, ::T.untyped)
  HTTP_ERRORS = ::T.let(nil, ::T.untyped)
  NET_ERRORS = ::T.let(nil, ::T.untyped)
end

class Bundler::Fetcher::AuthenticationRequiredError
  def initialize(remote_uri); end
end

class Bundler::Fetcher::BadAuthenticationError
  def initialize(remote_uri); end
end

class Bundler::Fetcher::Base
  def api_fetcher?(); end

  def available?(); end

  def display_uri(); end

  def downloader(); end

  def fetch_uri(); end

  def initialize(downloader, remote, display_uri); end

  def remote(); end

  def remote_uri(); end
end

class Bundler::Fetcher::Base
end

class Bundler::Fetcher::CertificateFailureError
  def initialize(remote_uri); end
end

class Bundler::Fetcher::CompactIndex
  def available?(*args, &blk); end

  def fetch_spec(*args, &blk); end

  def specs(*args, &blk); end

  def specs_for_names(gem_names); end
end

class Bundler::Fetcher::CompactIndex::ClientFetcher
  def call(path, headers); end

  def fetcher(); end

  def fetcher=(_); end

  def ui(); end

  def ui=(_); end
end

class Bundler::Fetcher::CompactIndex::ClientFetcher
  def self.[](*_); end

  def self.members(); end
end

class Bundler::Fetcher::CompactIndex
  def self.compact_index_request(method_name); end
end

class Bundler::Fetcher::Dependency
  def dependency_api_uri(gem_names=T.unsafe(nil)); end

  def dependency_specs(gem_names); end

  def get_formatted_specs_and_deps(gem_list); end

  def specs(gem_names, full_dependency_list=T.unsafe(nil), last_spec_list=T.unsafe(nil)); end

  def unmarshalled_dep_gems(gem_names); end
end

class Bundler::Fetcher::Dependency
end

class Bundler::Fetcher::Downloader
  def connection(); end

  def fetch(uri, headers=T.unsafe(nil), counter=T.unsafe(nil)); end

  def initialize(connection, redirect_limit); end

  def redirect_limit(); end

  def request(uri, headers); end
end

class Bundler::Fetcher::Downloader
end

class Bundler::Fetcher::Index
  def fetch_spec(spec); end

  def specs(_gem_names); end
end

class Bundler::Fetcher::Index
end

class Bundler::Fetcher::SSLError
  def initialize(msg=T.unsafe(nil)); end
end

class Bundler::Fetcher::TooManyRequestsError
end

class Bundler::Fetcher::TooManyRequestsError
end

class Bundler::Fetcher
  def self.api_timeout(); end

  def self.api_timeout=(api_timeout); end

  def self.disable_endpoint(); end

  def self.disable_endpoint=(disable_endpoint); end

  def self.max_retries(); end

  def self.max_retries=(max_retries); end

  def self.redirect_limit(); end

  def self.redirect_limit=(redirect_limit); end
end

module Bundler::FileUtils
  VERSION = ::T.let(nil, ::T.untyped)
end

class Bundler::FileUtils::Entry_
  def link(dest); end
end

module Bundler::FileUtils
  def self.cp_lr(src, dest, noop: T.unsafe(nil), verbose: T.unsafe(nil), dereference_root: T.unsafe(nil), remove_destination: T.unsafe(nil)); end

  def self.link_entry(src, dest, dereference_root=T.unsafe(nil), remove_destination=T.unsafe(nil)); end
end

class Bundler::GemHelper
  def allowed_push_host(); end

  def already_tagged?(); end

  def base(); end

  def build_gem(); end

  def built_gem_path(); end

  def clean?(); end

  def committed?(); end

  def gem_command(); end

  def gem_key(); end

  def gem_push?(); end

  def gem_push_host(); end

  def gemspec(); end

  def git_push(remote=T.unsafe(nil)); end

  def guard_clean(); end

  def initialize(base=T.unsafe(nil), name=T.unsafe(nil)); end

  def install(); end

  def install_gem(built_gem_path=T.unsafe(nil), local=T.unsafe(nil)); end

  def name(); end

  def perform_git_push(options=T.unsafe(nil)); end

  def rubygem_push(path); end

  def sh(cmd, &block); end

  def sh_with_input(cmd); end

  def sh_with_status(cmd, &block); end

  def spec_path(); end

  def tag_version(); end

  def version(); end

  def version_tag(); end
end

class Bundler::GemHelper
  def self.gemspec(&block); end

  def self.install_tasks(opts=T.unsafe(nil)); end

  def self.instance(); end

  def self.instance=(instance); end
end

class Bundler::GemVersionPromoter
  def initialize(locked_specs=T.unsafe(nil), unlock_gems=T.unsafe(nil)); end

  def level(); end

  def level=(value); end

  def locked_specs(); end

  def major?(); end

  def minor?(); end

  def prerelease_specified(); end

  def prerelease_specified=(prerelease_specified); end

  def sort_versions(dep, spec_groups); end

  def strict(); end

  def strict=(strict); end

  def unlock_gems(); end
  DEBUG = ::T.let(nil, ::T.untyped)
end

class Bundler::GemVersionPromoter
end

class Bundler::Graph
  def edge_options(); end

  def groups(); end

  def initialize(env, output_file, show_version=T.unsafe(nil), show_requirements=T.unsafe(nil), output_format=T.unsafe(nil), without=T.unsafe(nil)); end

  def node_options(); end

  def output_file(); end

  def output_format(); end

  def relations(); end

  def viz(); end
  GRAPH_NAME = ::T.let(nil, ::T.untyped)
end

class Bundler::Graph::GraphVizClient
  def g(); end

  def initialize(graph_instance); end

  def run(); end
end

class Bundler::Graph::GraphVizClient
end

class Bundler::Graph
end

class Bundler::Index
  include ::Enumerable
end

class Bundler::Injector
  def initialize(deps, options=T.unsafe(nil)); end

  def inject(gemfile_path, lockfile_path); end

  def remove(gemfile_path, lockfile_path); end
  INJECTED_GEMS = ::T.let(nil, ::T.untyped)
end

class Bundler::Injector
  def self.inject(new_deps, options=T.unsafe(nil)); end

  def self.remove(gems, options=T.unsafe(nil)); end
end

class Bundler::Installer
  def generate_bundler_executable_stubs(spec, options=T.unsafe(nil)); end

  def generate_standalone_bundler_executable_stubs(spec); end

  def initialize(root, definition); end

  def post_install_messages(); end

  def run(options); end
end

class Bundler::Installer
  def self.ambiguous_gems(); end

  def self.ambiguous_gems=(ambiguous_gems); end

  def self.install(root, definition, options=T.unsafe(nil)); end
end

class Bundler::Molinillo::DependencyGraph
  include ::Enumerable
end

class Bundler::Molinillo::DependencyGraph::Log
  extend ::Enumerable
end

class Bundler::Molinillo::DependencyGraph::Vertex
  def _recursive_predecessors(vertices=T.unsafe(nil)); end

  def _recursive_successors(vertices=T.unsafe(nil)); end
end

module Bundler::Plugin::API::Source
  def ==(other); end

  def app_cache_dirname(); end

  def app_cache_path(custom_path=T.unsafe(nil)); end

  def bundler_plugin_api_source?(); end

  def cache(spec, custom_path=T.unsafe(nil)); end

  def cached!(); end

  def can_lock?(spec); end

  def dependency_names(); end

  def dependency_names=(dependency_names); end

  def double_check_for(*_); end

  def eql?(other); end

  def fetch_gemspec_files(); end

  def gem_install_dir(); end

  def hash(); end

  def include?(other); end

  def initialize(opts); end

  def install(spec, opts); end

  def install_path(); end

  def installed?(); end

  def name(); end

  def options(); end

  def options_to_lock(); end

  def post_install(spec, disable_exts=T.unsafe(nil)); end

  def remote!(); end

  def root(); end

  def specs(); end

  def to_lock(); end

  def to_s(); end

  def unlock!(); end

  def unmet_deps(); end

  def uri(); end

  def uri_hash(); end
end

module Bundler::Plugin::API::Source
end

module Bundler::Plugin::Events
  GEM_AFTER_INSTALL = ::T.let(nil, ::T.untyped)
  GEM_AFTER_INSTALL_ALL = ::T.let(nil, ::T.untyped)
  GEM_BEFORE_INSTALL = ::T.let(nil, ::T.untyped)
  GEM_BEFORE_INSTALL_ALL = ::T.let(nil, ::T.untyped)
end

class Bundler::Plugin::Index
  def installed_plugins(); end

  def plugin_commands(plugin); end
end

class Bundler::Plugin::Index::CommandConflict
  def initialize(plugin, commands); end
end

class Bundler::Plugin::Index::CommandConflict
end

class Bundler::Plugin::Index::SourceConflict
  def initialize(plugin, sources); end
end

class Bundler::Plugin::Index::SourceConflict
end

class Bundler::Plugin::Installer
  def install(names, options); end

  def install_definition(definition); end
end

class Bundler::Plugin::Installer::Git
  def generate_bin(spec, disable_extensions=T.unsafe(nil)); end
end

class Bundler::Plugin::Installer::Git
end

class Bundler::Plugin::Installer::Rubygems
end

class Bundler::Plugin::Installer::Rubygems
end

class Bundler::Plugin::Installer
end

class Bundler::Plugin::SourceList
end

class Bundler::Plugin::SourceList
end

module Bundler::Plugin
  def self.list(); end
end

class Bundler::ProcessLock
end

class Bundler::ProcessLock
  def self.lock(bundle_path=T.unsafe(nil)); end
end

class Bundler::Retry
  def attempt(&block); end

  def attempts(&block); end

  def current_run(); end

  def current_run=(current_run); end

  def initialize(name, exceptions=T.unsafe(nil), retries=T.unsafe(nil)); end

  def name(); end

  def name=(name); end

  def total_runs(); end

  def total_runs=(total_runs); end
end

class Bundler::Retry
  def self.attempts(); end

  def self.default_attempts(); end

  def self.default_retries(); end
end

class Bundler::RubyGemsGemInstaller
end

class Bundler::RubyGemsGemInstaller
end

class Bundler::RubygemsIntegration
  def add_to_load_path(paths); end

  def all_specs(); end

  def backport_ext_builder_monitor(); end

  def correct_for_windows_path(path); end

  def default_stubs(); end

  def find_name(name); end

  def gem_remote_fetcher(); end

  def plain_specs(); end

  def plain_specs=(specs); end

  def stub_rubygems(specs); end

  def use_gemdeps(gemfile); end
end

class Bundler::Settings::Mirror
  def ==(other); end

  def fallback_timeout(); end

  def fallback_timeout=(timeout); end

  def initialize(uri=T.unsafe(nil), fallback_timeout=T.unsafe(nil)); end

  def uri(); end

  def uri=(uri); end

  def valid?(); end

  def validate!(probe=T.unsafe(nil)); end
  DEFAULT_FALLBACK_TIMEOUT = ::T.let(nil, ::T.untyped)
end

class Bundler::Settings::Mirror
end

class Bundler::Settings::Mirrors
  def each(&blk); end

  def for(uri); end

  def initialize(prober=T.unsafe(nil)); end

  def parse(key, value); end
end

class Bundler::Settings::Mirrors
end

class Bundler::Settings::Validator
end

class Bundler::Settings::Validator::Rule
  def description(); end

  def fail!(key, value, *reasons); end

  def initialize(keys, description, &validate); end

  def k(key); end

  def set(settings, key, value, *reasons); end

  def validate!(key, value, settings); end
end

class Bundler::Settings::Validator::Rule
end

class Bundler::Settings::Validator
  def self.validate!(key, value, settings); end
end

class Bundler::Source::Git
  def glob(); end
end

class Bundler::SpecSet
  include ::Enumerable
end

class Bundler::Thor
  include ::Bundler::Thor::Base
  include ::Bundler::Thor::Invocation
  include ::Bundler::Thor::Shell
  def help(command=T.unsafe(nil), subcommand=T.unsafe(nil)); end
  HELP_MAPPINGS = ::T.let(nil, ::T.untyped)
  TEMPLATE_EXTNAME = ::T.let(nil, ::T.untyped)
  THOR_RESERVED_WORDS = ::T.let(nil, ::T.untyped)
end

module Bundler::Thor::Actions
  def _cleanup_options_and_set(options, key); end

  def _shared_configuration(); end

  def action(instance); end

  def add_file(destination, *args, &block); end

  def add_link(destination, *args); end

  def append_file(path, *args, &block); end

  def append_to_file(path, *args, &block); end

  def apply(path, config=T.unsafe(nil)); end

  def behavior(); end

  def behavior=(behavior); end

  def chmod(path, mode, config=T.unsafe(nil)); end

  def comment_lines(path, flag, *args); end

  def copy_file(source, *args, &block); end

  def create_file(destination, *args, &block); end

  def create_link(destination, *args); end

  def destination_root(); end

  def destination_root=(root); end

  def directory(source, *args, &block); end

  def empty_directory(destination, config=T.unsafe(nil)); end

  def find_in_source_paths(file); end

  def get(source, *args, &block); end

  def gsub_file(path, flag, *args, &block); end

  def in_root(); end

  def initialize(args=T.unsafe(nil), options=T.unsafe(nil), config=T.unsafe(nil)); end

  def inject_into_class(path, klass, *args, &block); end

  def inject_into_file(destination, *args, &block); end

  def inject_into_module(path, module_name, *args, &block); end

  def insert_into_file(destination, *args, &block); end

  def inside(dir=T.unsafe(nil), config=T.unsafe(nil), &block); end

  def link_file(source, *args); end

  def prepend_file(path, *args, &block); end

  def prepend_to_file(path, *args, &block); end

  def relative_to_original_destination_root(path, remove_dot=T.unsafe(nil)); end

  def remove_dir(path, config=T.unsafe(nil)); end

  def remove_file(path, config=T.unsafe(nil)); end

  def run(command, config=T.unsafe(nil)); end

  def run_ruby_script(command, config=T.unsafe(nil)); end

  def source_paths(); end

  def template(source, *args, &block); end

  def thor(command, *args); end

  def uncomment_lines(path, flag, *args); end
  WARNINGS = ::T.let(nil, ::T.untyped)
end

class Bundler::Thor::Actions::CapturableERB
end

class Bundler::Thor::Actions::CapturableERB
end

module Bundler::Thor::Actions::ClassMethods
  def add_runtime_options!(); end

  def source_paths(); end

  def source_paths_for_search(); end

  def source_root(path=T.unsafe(nil)); end
end

module Bundler::Thor::Actions::ClassMethods
end

class Bundler::Thor::Actions::CreateFile
  def data(); end

  def force_on_collision?(); end

  def force_or_skip_or_conflict(force, skip, &block); end

  def identical?(); end

  def initialize(base, destination, data, config=T.unsafe(nil)); end

  def on_conflict_behavior(&block); end

  def render(); end
end

class Bundler::Thor::Actions::CreateFile
end

class Bundler::Thor::Actions::CreateLink
end

class Bundler::Thor::Actions::CreateLink
end

class Bundler::Thor::Actions::Directory
  def execute!(); end

  def file_level_lookup(previous_lookup); end

  def files(lookup); end

  def initialize(base, source, destination=T.unsafe(nil), config=T.unsafe(nil), &block); end

  def source(); end
end

class Bundler::Thor::Actions::Directory
end

class Bundler::Thor::Actions::EmptyDirectory
  def base(); end

  def config(); end

  def convert_encoded_instructions(filename); end

  def destination(); end

  def destination=(destination); end

  def exists?(); end

  def given_destination(); end

  def initialize(base, destination, config=T.unsafe(nil)); end

  def invoke!(); end

  def invoke_with_conflict_check(&block); end

  def on_conflict_behavior(); end

  def on_file_clash_behavior(); end

  def pretend?(); end

  def relative_destination(); end

  def revoke!(); end

  def say_status(status, color); end
end

class Bundler::Thor::Actions::EmptyDirectory
end

class Bundler::Thor::Actions::InjectIntoFile
  def behavior(); end

  def flag(); end

  def initialize(base, destination, data, config); end

  def replace!(regexp, string, force); end

  def replacement(); end

  def say_status(behavior, warning: T.unsafe(nil), color: T.unsafe(nil)); end
end

class Bundler::Thor::Actions::InjectIntoFile
end

module Bundler::Thor::Actions
  def self.included(base); end
end

class Bundler::Thor::AmbiguousCommandError
end

class Bundler::Thor::AmbiguousCommandError
end

Bundler::Thor::AmbiguousTaskError = Bundler::Thor::AmbiguousCommandError

class Bundler::Thor::Argument
  def banner(); end

  def default(); end

  def default_banner(); end

  def description(); end

  def enum(); end

  def human_name(); end

  def initialize(name, options=T.unsafe(nil)); end

  def name(); end

  def required(); end

  def required?(); end

  def show_default?(); end

  def type(); end

  def usage(); end

  def valid_type?(type); end

  def validate!(); end
  VALID_TYPES = ::T.let(nil, ::T.untyped)
end

class Bundler::Thor::Argument
end

class Bundler::Thor::Arguments
  def initialize(arguments=T.unsafe(nil)); end

  def parse(args); end

  def remaining(); end
  NUMERIC = ::T.let(nil, ::T.untyped)
end

class Bundler::Thor::Arguments
  def self.parse(*args); end

  def self.split(args); end
end

module Bundler::Thor::Base
  def args(); end

  def args=(args); end

  def initialize(args=T.unsafe(nil), local_options=T.unsafe(nil), config=T.unsafe(nil)); end

  def options(); end

  def options=(options); end

  def parent_options(); end

  def parent_options=(parent_options); end
end

module Bundler::Thor::Base::ClassMethods
  def all_commands(); end

  def all_tasks(); end

  def allow_incompatible_default_type!(); end

  def argument(name, options=T.unsafe(nil)); end

  def arguments(); end

  def attr_accessor(*_); end

  def attr_reader(*_); end

  def attr_writer(*_); end

  def baseclass(); end

  def basename(); end

  def build_option(name, options, scope); end

  def build_options(options, scope); end

  def check_default_type(); end

  def check_default_type!(); end

  def check_unknown_options(); end

  def check_unknown_options!(); end

  def check_unknown_options?(config); end

  def class_option(name, options=T.unsafe(nil)); end

  def class_options(options=T.unsafe(nil)); end

  def class_options_help(shell, groups=T.unsafe(nil)); end

  def commands(); end

  def create_command(meth); end

  def create_task(meth); end

  def disable_required_check?(command_name); end

  def dispatch(command, given_args, given_opts, config); end

  def exit_on_failure?(); end

  def find_and_refresh_command(name); end

  def find_and_refresh_task(name); end

  def from_superclass(method, default=T.unsafe(nil)); end

  def group(name=T.unsafe(nil)); end

  def handle_argument_error(command, error, args, arity); end

  def handle_no_command_error(command, has_namespace=T.unsafe(nil)); end

  def handle_no_task_error(command, has_namespace=T.unsafe(nil)); end

  def inherited(klass); end

  def initialize_added(); end

  def is_thor_reserved_word?(word, type); end

  def method_added(meth); end

  def namespace(name=T.unsafe(nil)); end

  def no_commands(&block); end

  def no_commands?(); end

  def no_commands_context(); end

  def no_tasks(&block); end

  def print_options(shell, options, group_name=T.unsafe(nil)); end

  def public_command(*names); end

  def public_task(*names); end

  def remove_argument(*names); end

  def remove_class_option(*names); end

  def remove_command(*names); end

  def remove_task(*names); end

  def start(given_args=T.unsafe(nil), config=T.unsafe(nil)); end

  def stop_on_unknown_option?(command_name); end

  def strict_args_position(); end

  def strict_args_position!(); end

  def strict_args_position?(config); end

  def tasks(); end
end

module Bundler::Thor::Base::ClassMethods
end

module Bundler::Thor::Base
  def self.included(base); end

  def self.register_klass_file(klass); end

  def self.shell(); end

  def self.shell=(shell); end

  def self.subclass_files(); end

  def self.subclasses(); end
end

class Bundler::Thor::Command
  def formatted_usage(klass, namespace=T.unsafe(nil), subcommand=T.unsafe(nil)); end

  def handle_argument_error?(instance, error, caller); end

  def handle_no_method_error?(instance, error, caller); end

  def hidden?(); end

  def initialize(name, description, long_description, usage, options=T.unsafe(nil)); end

  def local_method?(instance, name); end

  def not_debugging?(instance); end

  def private_method?(instance); end

  def public_method?(instance); end

  def required_arguments_for(klass, usage); end

  def required_options(); end

  def run(instance, args=T.unsafe(nil)); end

  def sans_backtrace(backtrace, caller); end
  FILE_REGEXP = ::T.let(nil, ::T.untyped)
end

class Bundler::Thor::Command
end

module Bundler::Thor::CoreExt
end

class Bundler::Thor::CoreExt::HashWithIndifferentAccess
  def [](key); end

  def []=(key, value); end

  def convert_key(key); end

  def delete(key); end

  def fetch(key, *args); end

  def initialize(hash=T.unsafe(nil)); end

  def key?(key); end

  def merge(other); end

  def merge!(other); end

  def method_missing(method, *args); end

  def replace(other_hash); end

  def reverse_merge(other); end

  def reverse_merge!(other_hash); end

  def values_at(*indices); end
end

class Bundler::Thor::CoreExt::HashWithIndifferentAccess
end

module Bundler::Thor::CoreExt
end

Bundler::Thor::Correctable = DidYouMean::Correctable

class Bundler::Thor::DynamicCommand
  def initialize(name, options=T.unsafe(nil)); end
end

class Bundler::Thor::DynamicCommand
end

Bundler::Thor::DynamicTask = Bundler::Thor::DynamicCommand

class Bundler::Thor::Error
end

class Bundler::Thor::Error
end

class Bundler::Thor::Group
  include ::Bundler::Thor::Base
  include ::Bundler::Thor::Invocation
  include ::Bundler::Thor::Shell
  def _invoke_for_class_method(klass, command=T.unsafe(nil), *args, &block); end
end

class Bundler::Thor::Group
  extend ::Bundler::Thor::Base::ClassMethods
  extend ::Bundler::Thor::Invocation::ClassMethods
  def self.banner(); end

  def self.desc(description=T.unsafe(nil)); end

  def self.get_options_from_invocations(group_options, base_options); end

  def self.handle_argument_error(command, error, _args, arity); end

  def self.help(shell); end

  def self.invocation_blocks(); end

  def self.invocations(); end

  def self.invoke(*names, &block); end

  def self.invoke_from_option(*names, &block); end

  def self.printable_commands(*_); end

  def self.printable_tasks(*_); end

  def self.remove_invocation(*names); end

  def self.self_command(); end

  def self.self_task(); end
end

class Bundler::Thor::HiddenCommand
end

class Bundler::Thor::HiddenCommand
end

Bundler::Thor::HiddenTask = Bundler::Thor::HiddenCommand

module Bundler::Thor::Invocation
  def _parse_initialization_options(args, opts, config); end

  def _retrieve_class_and_command(name, sent_command=T.unsafe(nil)); end

  def _retrieve_class_and_task(name, sent_command=T.unsafe(nil)); end

  def _shared_configuration(); end

  def current_command_chain(); end

  def initialize(args=T.unsafe(nil), options=T.unsafe(nil), config=T.unsafe(nil), &block); end

  def invoke(name=T.unsafe(nil), *args); end

  def invoke_all(); end

  def invoke_command(command, *args); end

  def invoke_task(command, *args); end

  def invoke_with_padding(*args); end
end

module Bundler::Thor::Invocation::ClassMethods
  def prepare_for_invocation(key, name); end
end

module Bundler::Thor::Invocation::ClassMethods
end

module Bundler::Thor::Invocation
  def self.included(base); end
end

class Bundler::Thor::InvocationError
end

class Bundler::Thor::InvocationError
end

module Bundler::Thor::LineEditor
end

class Bundler::Thor::LineEditor::Basic
  def initialize(prompt, options); end

  def options(); end

  def prompt(); end

  def readline(); end
end

class Bundler::Thor::LineEditor::Basic
  def self.available?(); end
end

class Bundler::Thor::LineEditor::Readline
end

class Bundler::Thor::LineEditor::Readline::PathCompletion
  def initialize(text); end

  def matches(); end
end

class Bundler::Thor::LineEditor::Readline::PathCompletion
end

class Bundler::Thor::LineEditor::Readline
end

module Bundler::Thor::LineEditor
  def self.best_available(); end

  def self.readline(prompt, options=T.unsafe(nil)); end
end

class Bundler::Thor::MalformattedArgumentError
end

class Bundler::Thor::MalformattedArgumentError
end

class Bundler::Thor::NestedContext
  def enter(); end

  def entered?(); end
end

class Bundler::Thor::NestedContext
end

class Bundler::Thor::NoKwargSpellChecker
  def initialize(dictionary); end
end

class Bundler::Thor::NoKwargSpellChecker
end

class Bundler::Thor::Option
  def aliases(); end

  def array?(); end

  def boolean?(); end

  def dasherize(str); end

  def dasherized?(); end

  def group(); end

  def hash?(); end

  def hide(); end

  def lazy_default(); end

  def numeric?(); end

  def repeatable(); end

  def string?(); end

  def switch_name(); end

  def undasherize(str); end

  def usage(padding=T.unsafe(nil)); end

  def validate_default_type!(); end
  VALID_TYPES = ::T.let(nil, ::T.untyped)
end

class Bundler::Thor::Option
  def self.parse(key, value); end
end

class Bundler::Thor::Options
  def assign_result!(option, result); end

  def check_unknown!(); end

  def current_is_switch?(); end

  def current_is_switch_formatted?(); end

  def initialize(hash_options=T.unsafe(nil), defaults=T.unsafe(nil), stop_on_unknown=T.unsafe(nil), disable_required_check=T.unsafe(nil)); end

  def normalize_switch(arg); end

  def parse_boolean(switch); end

  def parse_peek(switch, option); end

  def parsing_options?(); end

  def switch?(arg); end

  def switch_option(arg); end
  EQ_RE = ::T.let(nil, ::T.untyped)
  LONG_RE = ::T.let(nil, ::T.untyped)
  OPTS_END = ::T.let(nil, ::T.untyped)
  SHORT_NUM = ::T.let(nil, ::T.untyped)
  SHORT_RE = ::T.let(nil, ::T.untyped)
  SHORT_SQ_RE = ::T.let(nil, ::T.untyped)
end

class Bundler::Thor::Options
  def self.to_switches(options); end
end

class Bundler::Thor::RequiredArgumentMissingError
end

class Bundler::Thor::RequiredArgumentMissingError
end

module Bundler::Thor::Sandbox
end

module Bundler::Thor::Sandbox
end

module Bundler::Thor::Shell
  def _shared_configuration(); end

  def ask(*args, &block); end

  def error(*args, &block); end

  def file_collision(*args, &block); end

  def initialize(args=T.unsafe(nil), options=T.unsafe(nil), config=T.unsafe(nil)); end

  def no?(*args, &block); end

  def print_in_columns(*args, &block); end

  def print_table(*args, &block); end

  def print_wrapped(*args, &block); end

  def say(*args, &block); end

  def say_status(*args, &block); end

  def set_color(*args, &block); end

  def shell(); end

  def shell=(shell); end

  def terminal_width(*args, &block); end

  def with_padding(); end

  def yes?(*args, &block); end
  SHELL_DELEGATED_METHODS = ::T.let(nil, ::T.untyped)
end

class Bundler::Thor::Shell::Basic
  def answer_match(possibilities, answer, case_insensitive); end

  def as_unicode(); end

  def ask(statement, *args); end

  def ask_filtered(statement, color, options); end

  def ask_simply(statement, color, options); end

  def base(); end

  def base=(base); end

  def can_display_colors?(); end

  def dynamic_width(); end

  def dynamic_width_stty(); end

  def dynamic_width_tput(); end

  def error(statement); end

  def file_collision(destination); end

  def file_collision_help(); end

  def git_merge_tool(); end

  def indent(count=T.unsafe(nil)); end

  def is?(value); end

  def lookup_color(color); end

  def merge(destination, content); end

  def merge_tool(); end

  def mute(); end

  def mute?(); end

  def no?(statement, color=T.unsafe(nil)); end

  def padding(); end

  def padding=(value); end

  def prepare_message(message, *color); end

  def print_in_columns(array); end

  def print_table(array, options=T.unsafe(nil)); end

  def print_wrapped(message, options=T.unsafe(nil)); end

  def quiet?(); end

  def say(message=T.unsafe(nil), color=T.unsafe(nil), force_new_line=T.unsafe(nil)); end

  def say_status(status, message, log_status=T.unsafe(nil)); end

  def set_color(string, *_); end

  def show_diff(destination, content); end

  def stderr(); end

  def stdout(); end

  def terminal_width(); end

  def truncate(string, width); end

  def unix?(); end

  def yes?(statement, color=T.unsafe(nil)); end
  DEFAULT_TERMINAL_WIDTH = ::T.let(nil, ::T.untyped)
end

class Bundler::Thor::Shell::Basic
end

class Bundler::Thor::Shell::Color
  def are_colors_disabled?(); end

  def diff_lcs_loaded?(); end

  def output_diff_line(diff); end

  def set_color(string, *colors); end
  BLACK = ::T.let(nil, ::T.untyped)
  BLUE = ::T.let(nil, ::T.untyped)
  BOLD = ::T.let(nil, ::T.untyped)
  CLEAR = ::T.let(nil, ::T.untyped)
  CYAN = ::T.let(nil, ::T.untyped)
  GREEN = ::T.let(nil, ::T.untyped)
  MAGENTA = ::T.let(nil, ::T.untyped)
  ON_BLACK = ::T.let(nil, ::T.untyped)
  ON_BLUE = ::T.let(nil, ::T.untyped)
  ON_CYAN = ::T.let(nil, ::T.untyped)
  ON_GREEN = ::T.let(nil, ::T.untyped)
  ON_MAGENTA = ::T.let(nil, ::T.untyped)
  ON_RED = ::T.let(nil, ::T.untyped)
  ON_WHITE = ::T.let(nil, ::T.untyped)
  ON_YELLOW = ::T.let(nil, ::T.untyped)
  RED = ::T.let(nil, ::T.untyped)
  WHITE = ::T.let(nil, ::T.untyped)
  YELLOW = ::T.let(nil, ::T.untyped)
end

class Bundler::Thor::Shell::Color
end

class Bundler::Thor::Shell::HTML
  def ask(statement, color=T.unsafe(nil)); end

  def diff_lcs_loaded?(); end

  def output_diff_line(diff); end

  def set_color(string, *colors); end
  BLACK = ::T.let(nil, ::T.untyped)
  BLUE = ::T.let(nil, ::T.untyped)
  BOLD = ::T.let(nil, ::T.untyped)
  CYAN = ::T.let(nil, ::T.untyped)
  GREEN = ::T.let(nil, ::T.untyped)
  MAGENTA = ::T.let(nil, ::T.untyped)
  ON_BLACK = ::T.let(nil, ::T.untyped)
  ON_BLUE = ::T.let(nil, ::T.untyped)
  ON_CYAN = ::T.let(nil, ::T.untyped)
  ON_GREEN = ::T.let(nil, ::T.untyped)
  ON_MAGENTA = ::T.let(nil, ::T.untyped)
  ON_RED = ::T.let(nil, ::T.untyped)
  ON_WHITE = ::T.let(nil, ::T.untyped)
  ON_YELLOW = ::T.let(nil, ::T.untyped)
  RED = ::T.let(nil, ::T.untyped)
  WHITE = ::T.let(nil, ::T.untyped)
  YELLOW = ::T.let(nil, ::T.untyped)
end

class Bundler::Thor::Shell::HTML
end

module Bundler::Thor::Shell
end

Bundler::Thor::Task = Bundler::Thor::Command

class Bundler::Thor::UndefinedCommandError
  include ::DidYouMean::Correctable
  def all_commands(); end

  def command(); end

  def initialize(command, all_commands, namespace); end
end

class Bundler::Thor::UndefinedCommandError::SpellChecker
  def corrections(); end

  def error(); end

  def initialize(error); end

  def spell_checker(); end
end

class Bundler::Thor::UndefinedCommandError::SpellChecker
end

class Bundler::Thor::UndefinedCommandError
end

Bundler::Thor::UndefinedTaskError = Bundler::Thor::UndefinedCommandError

class Bundler::Thor::UnknownArgumentError
  include ::DidYouMean::Correctable
  def initialize(switches, unknown); end

  def switches(); end

  def unknown(); end
end

class Bundler::Thor::UnknownArgumentError::SpellChecker
  def corrections(); end

  def error(); end

  def initialize(error); end

  def spell_checker(); end
end

class Bundler::Thor::UnknownArgumentError::SpellChecker
end

class Bundler::Thor::UnknownArgumentError
end

module Bundler::Thor::Util
end

module Bundler::Thor::Util
  def self.camel_case(str); end

  def self.escape_globs(path); end

  def self.escape_html(string); end

  def self.find_by_namespace(namespace); end

  def self.find_class_and_command_by_namespace(namespace, fallback=T.unsafe(nil)); end

  def self.find_class_and_task_by_namespace(namespace, fallback=T.unsafe(nil)); end

  def self.globs_for(path); end

  def self.load_thorfile(path, content=T.unsafe(nil), debug=T.unsafe(nil)); end

  def self.namespace_from_thor_class(constant); end

  def self.namespaces_in_content(contents, file=T.unsafe(nil)); end

  def self.ruby_command(); end

  def self.snake_case(str); end

  def self.thor_classes_in(klass); end

  def self.thor_root(); end

  def self.thor_root_glob(); end

  def self.user_home(); end
end

class Bundler::Thor
  extend ::Bundler::Thor::Base::ClassMethods
  extend ::Bundler::Thor::Invocation::ClassMethods
  def self.banner(command, namespace=T.unsafe(nil), subcommand=T.unsafe(nil)); end

  def self.check_unknown_options!(options=T.unsafe(nil)); end

  def self.command_help(shell, command_name); end

  def self.default_command(meth=T.unsafe(nil)); end

  def self.default_task(meth=T.unsafe(nil)); end

  def self.deprecation_warning(message); end

  def self.desc(usage, description, options=T.unsafe(nil)); end

  def self.disable_required_check(); end

  def self.disable_required_check!(*command_names); end

  def self.disable_required_check?(command); end

  def self.dispatch(meth, given_args, given_opts, config); end

  def self.dynamic_command_class(); end

  def self.find_command_possibilities(meth); end

  def self.find_task_possibilities(meth); end

  def self.help(shell, subcommand=T.unsafe(nil)); end

  def self.long_desc(long_description, options=T.unsafe(nil)); end

  def self.map(mappings=T.unsafe(nil), **kw); end

  def self.method_option(name, options=T.unsafe(nil)); end

  def self.method_options(options=T.unsafe(nil)); end

  def self.normalize_command_name(meth); end

  def self.normalize_task_name(meth); end

  def self.option(name, options=T.unsafe(nil)); end

  def self.options(options=T.unsafe(nil)); end

  def self.package_name(name, _=T.unsafe(nil)); end

  def self.printable_commands(all=T.unsafe(nil), subcommand=T.unsafe(nil)); end

  def self.printable_tasks(all=T.unsafe(nil), subcommand=T.unsafe(nil)); end

  def self.register(klass, subcommand_name, usage, description, options=T.unsafe(nil)); end

  def self.retrieve_command_name(args); end

  def self.retrieve_task_name(args); end

  def self.stop_on_unknown_option(); end

  def self.stop_on_unknown_option!(*command_names); end

  def self.stop_on_unknown_option?(command); end

  def self.subcommand(subcommand, subcommand_class); end

  def self.subcommand_classes(); end

  def self.subcommand_help(cmd); end

  def self.subcommands(); end

  def self.subtask(subcommand, subcommand_class); end

  def self.subtask_help(cmd); end

  def self.subtasks(); end

  def self.task_help(shell, command_name); end
end

class Bundler::UI::Shell
  def add_color(string, *color); end

  def ask(msg); end

  def confirm(msg, newline=T.unsafe(nil)); end

  def debug(msg, newline=T.unsafe(nil)); end

  def debug?(); end

  def error(msg, newline=T.unsafe(nil)); end

  def info(msg, newline=T.unsafe(nil)); end

  def initialize(options=T.unsafe(nil)); end

  def level(name=T.unsafe(nil)); end

  def level=(level); end

  def no?(); end

  def quiet?(); end

  def shell=(shell); end

  def silence(&blk); end

  def trace(e, newline=T.unsafe(nil), force=T.unsafe(nil)); end

  def unprinted_warnings(); end

  def warn(msg, newline=T.unsafe(nil)); end

  def yes?(msg); end
  LEVELS = ::T.let(nil, ::T.untyped)
end

class Bundler::UI::Shell
end

module Bundler::URI
  include ::Bundler::URI::RFC2396_REGEXP
  ABS_PATH = ::T.let(nil, ::T.untyped)
  ABS_URI = ::T.let(nil, ::T.untyped)
  ABS_URI_REF = ::T.let(nil, ::T.untyped)
  DEFAULT_PARSER = ::T.let(nil, ::T.untyped)
  ESCAPED = ::T.let(nil, ::T.untyped)
  FRAGMENT = ::T.let(nil, ::T.untyped)
  HOST = ::T.let(nil, ::T.untyped)
  OPAQUE = ::T.let(nil, ::T.untyped)
  PORT = ::T.let(nil, ::T.untyped)
  QUERY = ::T.let(nil, ::T.untyped)
  REGISTRY = ::T.let(nil, ::T.untyped)
  REL_PATH = ::T.let(nil, ::T.untyped)
  REL_URI = ::T.let(nil, ::T.untyped)
  REL_URI_REF = ::T.let(nil, ::T.untyped)
  RFC3986_PARSER = ::T.let(nil, ::T.untyped)
  SCHEME = ::T.let(nil, ::T.untyped)
  TBLDECWWWCOMP_ = ::T.let(nil, ::T.untyped)
  TBLENCWWWCOMP_ = ::T.let(nil, ::T.untyped)
  UNSAFE = ::T.let(nil, ::T.untyped)
  URI_REF = ::T.let(nil, ::T.untyped)
  USERINFO = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
  VERSION_CODE = ::T.let(nil, ::T.untyped)
  WEB_ENCODINGS_ = ::T.let(nil, ::T.untyped)
end

class Bundler::URI::BadURIError
end

class Bundler::URI::BadURIError
end

class Bundler::URI::Error
end

class Bundler::URI::Error
end

module Bundler::URI::Escape
  def decode(*arg); end

  def encode(*arg); end

  def escape(*arg); end

  def unescape(*arg); end
end

module Bundler::URI::Escape
end

class Bundler::URI::FTP
  def set_typecode(v); end

  def typecode(); end

  def typecode=(typecode); end
  COMPONENT = ::T.let(nil, ::T.untyped)
  DEFAULT_PORT = ::T.let(nil, ::T.untyped)
  TYPECODE = ::T.let(nil, ::T.untyped)
  TYPECODE_PREFIX = ::T.let(nil, ::T.untyped)
end

class Bundler::URI::FTP
  def self.new2(user, password, host, port, path, typecode=T.unsafe(nil), arg_check=T.unsafe(nil)); end
end

class Bundler::URI::File
  def check_password(user); end

  def check_user(user); end

  def check_userinfo(user); end

  def set_userinfo(v); end
  COMPONENT = ::T.let(nil, ::T.untyped)
  DEFAULT_PORT = ::T.let(nil, ::T.untyped)
end

class Bundler::URI::File
end

class Bundler::URI::Generic
  include ::Bundler::URI
  include ::Bundler::URI::RFC2396_REGEXP
  def +(oth); end

  def -(oth); end

  def ==(oth); end

  def absolute(); end

  def absolute?(); end

  def coerce(oth); end

  def component(); end

  def component_ary(); end

  def default_port(); end

  def eql?(oth); end

  def find_proxy(env=T.unsafe(nil)); end

  def fragment(); end

  def fragment=(v); end

  def hierarchical?(); end

  def host(); end

  def host=(v); end

  def hostname(); end

  def hostname=(v); end

  def initialize(scheme, userinfo, host, port, registry, path, opaque, query, fragment, parser=T.unsafe(nil), arg_check=T.unsafe(nil)); end

  def merge(oth); end

  def merge!(oth); end

  def normalize(); end

  def normalize!(); end

  def opaque(); end

  def opaque=(v); end

  def parser(); end

  def password(); end

  def password=(password); end

  def path(); end

  def path=(v); end

  def port(); end

  def port=(v); end

  def query(); end

  def query=(v); end

  def registry(); end

  def registry=(v); end

  def relative?(); end

  def route_from(oth); end

  def route_to(oth); end

  def scheme(); end

  def scheme=(v); end

  def select(*components); end

  def set_host(v); end

  def set_opaque(v); end

  def set_password(v); end

  def set_path(v); end

  def set_port(v); end

  def set_registry(v); end

  def set_scheme(v); end

  def set_user(v); end

  def set_userinfo(user, password=T.unsafe(nil)); end

  def user(); end

  def user=(user); end

  def userinfo(); end

  def userinfo=(userinfo); end
  COMPONENT = ::T.let(nil, ::T.untyped)
  DEFAULT_PORT = ::T.let(nil, ::T.untyped)
  USE_REGISTRY = ::T.let(nil, ::T.untyped)
end

class Bundler::URI::Generic
  def self.build(args); end

  def self.build2(args); end

  def self.component(); end

  def self.default_port(); end

  def self.use_proxy?(hostname, addr, port, no_proxy); end

  def self.use_registry(); end
end

class Bundler::URI::HTTP
  def request_uri(); end
  COMPONENT = ::T.let(nil, ::T.untyped)
  DEFAULT_PORT = ::T.let(nil, ::T.untyped)
end

class Bundler::URI::HTTP
end

class Bundler::URI::HTTPS
  DEFAULT_PORT = ::T.let(nil, ::T.untyped)
end

class Bundler::URI::HTTPS
end

class Bundler::URI::InvalidComponentError
end

class Bundler::URI::InvalidComponentError
end

class Bundler::URI::InvalidURIError
end

class Bundler::URI::InvalidURIError
end

class Bundler::URI::LDAP
  def attributes(); end

  def attributes=(val); end

  def dn(); end

  def dn=(val); end

  def extensions(); end

  def extensions=(val); end

  def filter(); end

  def filter=(val); end

  def initialize(*arg); end

  def scope(); end

  def scope=(val); end

  def set_attributes(val); end

  def set_dn(val); end

  def set_extensions(val); end

  def set_filter(val); end

  def set_scope(val); end
  COMPONENT = ::T.let(nil, ::T.untyped)
  DEFAULT_PORT = ::T.let(nil, ::T.untyped)
  SCOPE = ::T.let(nil, ::T.untyped)
  SCOPE_BASE = ::T.let(nil, ::T.untyped)
  SCOPE_ONE = ::T.let(nil, ::T.untyped)
  SCOPE_SUB = ::T.let(nil, ::T.untyped)
end

class Bundler::URI::LDAP
end

class Bundler::URI::LDAPS
  DEFAULT_PORT = ::T.let(nil, ::T.untyped)
end

class Bundler::URI::LDAPS
end

class Bundler::URI::MailTo
  def headers(); end

  def headers=(v); end

  def initialize(*arg); end

  def set_headers(v); end

  def set_to(v); end

  def to(); end

  def to=(v); end

  def to_mailtext(); end

  def to_rfc822text(); end
  COMPONENT = ::T.let(nil, ::T.untyped)
  DEFAULT_PORT = ::T.let(nil, ::T.untyped)
  EMAIL_REGEXP = ::T.let(nil, ::T.untyped)
  HEADER_REGEXP = ::T.let(nil, ::T.untyped)
end

class Bundler::URI::MailTo
end

Bundler::URI::Parser = Bundler::URI::RFC2396_Parser

Bundler::URI::REGEXP = Bundler::URI::RFC2396_REGEXP

class Bundler::URI::RFC2396_Parser
  include ::Bundler::URI::RFC2396_REGEXP
  def escape(str, unsafe=T.unsafe(nil)); end

  def extract(str, schemes=T.unsafe(nil)); end

  def initialize(opts=T.unsafe(nil)); end

  def join(*uris); end

  def make_regexp(schemes=T.unsafe(nil)); end

  def parse(uri); end

  def pattern(); end

  def regexp(); end

  def split(uri); end

  def unescape(str, escaped=T.unsafe(nil)); end
end

class Bundler::URI::RFC2396_Parser
end

module Bundler::URI::RFC2396_REGEXP
end

module Bundler::URI::RFC2396_REGEXP::PATTERN
  ABS_PATH = ::T.let(nil, ::T.untyped)
  ABS_URI = ::T.let(nil, ::T.untyped)
  ALNUM = ::T.let(nil, ::T.untyped)
  ALPHA = ::T.let(nil, ::T.untyped)
  DOMLABEL = ::T.let(nil, ::T.untyped)
  ESCAPED = ::T.let(nil, ::T.untyped)
  FRAGMENT = ::T.let(nil, ::T.untyped)
  HEX = ::T.let(nil, ::T.untyped)
  HIER_PART = ::T.let(nil, ::T.untyped)
  HOST = ::T.let(nil, ::T.untyped)
  HOSTNAME = ::T.let(nil, ::T.untyped)
  HOSTPORT = ::T.let(nil, ::T.untyped)
  IPV4ADDR = ::T.let(nil, ::T.untyped)
  IPV6ADDR = ::T.let(nil, ::T.untyped)
  IPV6REF = ::T.let(nil, ::T.untyped)
  NET_PATH = ::T.let(nil, ::T.untyped)
  OPAQUE_PART = ::T.let(nil, ::T.untyped)
  PATH_SEGMENTS = ::T.let(nil, ::T.untyped)
  PORT = ::T.let(nil, ::T.untyped)
  QUERY = ::T.let(nil, ::T.untyped)
  REG_NAME = ::T.let(nil, ::T.untyped)
  REL_PATH = ::T.let(nil, ::T.untyped)
  REL_SEGMENT = ::T.let(nil, ::T.untyped)
  REL_URI = ::T.let(nil, ::T.untyped)
  RESERVED = ::T.let(nil, ::T.untyped)
  SCHEME = ::T.let(nil, ::T.untyped)
  TOPLABEL = ::T.let(nil, ::T.untyped)
  UNRESERVED = ::T.let(nil, ::T.untyped)
  URIC = ::T.let(nil, ::T.untyped)
  URIC_NO_SLASH = ::T.let(nil, ::T.untyped)
  URI_REF = ::T.let(nil, ::T.untyped)
  USERINFO = ::T.let(nil, ::T.untyped)
  X_ABS_URI = ::T.let(nil, ::T.untyped)
  X_REL_URI = ::T.let(nil, ::T.untyped)
end

module Bundler::URI::RFC2396_REGEXP::PATTERN
end

module Bundler::URI::RFC2396_REGEXP
end

class Bundler::URI::RFC3986_Parser
  def join(*uris); end

  def parse(uri); end

  def regexp(); end

  def split(uri); end
  RFC3986_URI = ::T.let(nil, ::T.untyped)
  RFC3986_relative_ref = ::T.let(nil, ::T.untyped)
end

class Bundler::URI::RFC3986_Parser
end

module Bundler::URI::Util
end

module Bundler::URI::Util
  def self.make_components_hash(klass, array_hash); end
end

module Bundler::URI
  extend ::Bundler::URI::Escape
  def self.decode_www_form(str, enc=T.unsafe(nil), separator: T.unsafe(nil), use__charset_: T.unsafe(nil), isindex: T.unsafe(nil)); end

  def self.decode_www_form_component(str, enc=T.unsafe(nil)); end

  def self.encode_www_form(enum, enc=T.unsafe(nil)); end

  def self.encode_www_form_component(str, enc=T.unsafe(nil)); end

  def self.extract(str, schemes=T.unsafe(nil), &block); end

  def self.get_encoding(label); end

  def self.join(*str); end

  def self.parse(uri); end

  def self.regexp(schemes=T.unsafe(nil)); end

  def self.scheme_list(); end

  def self.split(uri); end
end

module Bundler::VersionRanges
end

class Bundler::VersionRanges::NEq
  def version(); end

  def version=(_); end
end

class Bundler::VersionRanges::NEq
  def self.[](*_); end

  def self.members(); end
end

class Bundler::VersionRanges::ReqR
  def cover?(v); end

  def empty?(); end

  def left(); end

  def left=(_); end

  def right(); end

  def right=(_); end

  def single?(); end
  INFINITY = ::T.let(nil, ::T.untyped)
  UNIVERSAL = ::T.let(nil, ::T.untyped)
  ZERO = ::T.let(nil, ::T.untyped)
end

class Bundler::VersionRanges::ReqR::Endpoint
  def inclusive(); end

  def inclusive=(_); end

  def version(); end

  def version=(_); end
end

class Bundler::VersionRanges::ReqR::Endpoint
  def self.[](*_); end

  def self.members(); end
end

class Bundler::VersionRanges::ReqR
  def self.[](*_); end

  def self.members(); end
end

module Bundler::VersionRanges
  def self.empty?(ranges, neqs); end

  def self.for(requirement); end

  def self.for_many(requirements); end
end

module Bundler
  def self.original_exec(*args); end

  def self.original_system(*args); end

  def self.unbundled_env(); end

  def self.unbundled_exec(*args); end

  def self.unbundled_system(*args); end

  def self.with_unbundled_env(); end
end

module CGI::HtmlExtension
  def a(href=T.unsafe(nil)); end

  def base(href=T.unsafe(nil)); end

  def blockquote(cite=T.unsafe(nil)); end

  def caption(align=T.unsafe(nil)); end

  def checkbox(name=T.unsafe(nil), value=T.unsafe(nil), checked=T.unsafe(nil)); end

  def checkbox_group(name=T.unsafe(nil), *values); end

  def file_field(name=T.unsafe(nil), size=T.unsafe(nil), maxlength=T.unsafe(nil)); end

  def form(method=T.unsafe(nil), action=T.unsafe(nil), enctype=T.unsafe(nil)); end

  def hidden(name=T.unsafe(nil), value=T.unsafe(nil)); end

  def html(attributes=T.unsafe(nil)); end

  def image_button(src=T.unsafe(nil), name=T.unsafe(nil), alt=T.unsafe(nil)); end

  def img(src=T.unsafe(nil), alt=T.unsafe(nil), width=T.unsafe(nil), height=T.unsafe(nil)); end

  def multipart_form(action=T.unsafe(nil), enctype=T.unsafe(nil)); end

  def password_field(name=T.unsafe(nil), value=T.unsafe(nil), size=T.unsafe(nil), maxlength=T.unsafe(nil)); end

  def popup_menu(name=T.unsafe(nil), *values); end

  def radio_button(name=T.unsafe(nil), value=T.unsafe(nil), checked=T.unsafe(nil)); end

  def radio_group(name=T.unsafe(nil), *values); end

  def reset(value=T.unsafe(nil), name=T.unsafe(nil)); end

  def scrolling_list(name=T.unsafe(nil), *values); end

  def submit(value=T.unsafe(nil), name=T.unsafe(nil)); end

  def text_field(name=T.unsafe(nil), value=T.unsafe(nil), size=T.unsafe(nil), maxlength=T.unsafe(nil)); end

  def textarea(name=T.unsafe(nil), cols=T.unsafe(nil), rows=T.unsafe(nil)); end
end

module CGI::HtmlExtension
end

class Class
  def json_creatable?(); end
end

module CodeRay
  CODERAY_PATH = ::T.let(nil, ::T.untyped)
  TokenKinds = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class CodeRay::Encoders::Encoder
  DEFAULT_OPTIONS = ::T.let(nil, ::T.untyped)
end

CodeRay::Encoders::Encoder::PLUGIN_HOST = CodeRay::Encoders

class CodeRay::Encoders::HTML
  DEFAULT_OPTIONS = ::T.let(nil, ::T.untyped)
  FILE_EXTENSION = ::T.let(nil, ::T.untyped)
  HTML_ESCAPE = ::T.let(nil, ::T.untyped)
  HTML_ESCAPE_PATTERN = ::T.let(nil, ::T.untyped)
  TOKEN_KIND_TO_INFO = ::T.let(nil, ::T.untyped)
  TRANSPARENT_TOKEN_KINDS = ::T.let(nil, ::T.untyped)
end

class CodeRay::Encoders::HTML::CSS
  CSS_CLASS_PATTERN = ::T.let(nil, ::T.untyped)
end

module CodeRay::Encoders::HTML::Output
  DIV = ::T.let(nil, ::T.untyped)
  PAGE = ::T.let(nil, ::T.untyped)
  SPAN = ::T.let(nil, ::T.untyped)
  TABLE = ::T.let(nil, ::T.untyped)
end

class CodeRay::Encoders::Terminal
  TOKEN_COLORS = ::T.let(nil, ::T.untyped)
end

module CodeRay::FileType
  TypeFromExt = ::T.let(nil, ::T.untyped)
  TypeFromName = ::T.let(nil, ::T.untyped)
  TypeFromShebang = ::T.let(nil, ::T.untyped)
end

module CodeRay::PluginHost
  PLUGIN_HOSTS = ::T.let(nil, ::T.untyped)
  PLUGIN_HOSTS_BY_ID = ::T.let(nil, ::T.untyped)
end

class CodeRay::Scanners::Java
  CONSTANTS = ::T.let(nil, ::T.untyped)
  DIRECTIVES = ::T.let(nil, ::T.untyped)
  ESCAPE = ::T.let(nil, ::T.untyped)
  IDENT = ::T.let(nil, ::T.untyped)
  IDENT_KIND = ::T.let(nil, ::T.untyped)
  KEYWORDS = ::T.let(nil, ::T.untyped)
  MAGIC_VARIABLES = ::T.let(nil, ::T.untyped)
  RESERVED = ::T.let(nil, ::T.untyped)
  STRING_CONTENT_PATTERN = ::T.let(nil, ::T.untyped)
  TYPES = ::T.let(nil, ::T.untyped)
  UNICODE_ESCAPE = ::T.let(nil, ::T.untyped)
end

module CodeRay::Scanners::Java::BuiltinTypes
  List = ::T.let(nil, ::T.untyped)
end

module CodeRay::Scanners::Ruby::Patterns
  BINARY = ::T.let(nil, ::T.untyped)
  CHARACTER = ::T.let(nil, ::T.untyped)
  CLASS_VARIABLE = ::T.let(nil, ::T.untyped)
  CONTROL_META_ESCAPE = ::T.let(nil, ::T.untyped)
  DATA = ::T.let(nil, ::T.untyped)
  DECIMAL = ::T.let(nil, ::T.untyped)
  ESCAPE = ::T.let(nil, ::T.untyped)
  EXPONENT = ::T.let(nil, ::T.untyped)
  FANCY_STRING_INTERPRETED = ::T.let(nil, ::T.untyped)
  FANCY_STRING_KIND = ::T.let(nil, ::T.untyped)
  FANCY_STRING_START = ::T.let(nil, ::T.untyped)
  FLOAT_OR_INT = ::T.let(nil, ::T.untyped)
  FLOAT_SUFFIX = ::T.let(nil, ::T.untyped)
  GLOBAL_VARIABLE = ::T.let(nil, ::T.untyped)
  HEREDOC_OPEN = ::T.let(nil, ::T.untyped)
  HEXADECIMAL = ::T.let(nil, ::T.untyped)
  IDENT = ::T.let(nil, ::T.untyped)
  IDENT_KIND = ::T.let(nil, ::T.untyped)
  INSTANCE_VARIABLE = ::T.let(nil, ::T.untyped)
  KEYWORDS = ::T.let(nil, ::T.untyped)
  KEYWORDS_EXPECTING_VALUE = ::T.let(nil, ::T.untyped)
  KEYWORD_NEW_STATE = ::T.let(nil, ::T.untyped)
  METHOD_AFTER_DOT = ::T.let(nil, ::T.untyped)
  METHOD_NAME = ::T.let(nil, ::T.untyped)
  METHOD_NAME_EX = ::T.let(nil, ::T.untyped)
  METHOD_NAME_OPERATOR = ::T.let(nil, ::T.untyped)
  METHOD_NAME_OR_SYMBOL = ::T.let(nil, ::T.untyped)
  METHOD_SUFFIX = ::T.let(nil, ::T.untyped)
  NUMERIC = ::T.let(nil, ::T.untyped)
  OBJECT_VARIABLE = ::T.let(nil, ::T.untyped)
  OCTAL = ::T.let(nil, ::T.untyped)
  PREDEFINED_CONSTANTS = ::T.let(nil, ::T.untyped)
  PREFIX_VARIABLE = ::T.let(nil, ::T.untyped)
  QUOTE_TO_TYPE = ::T.let(nil, ::T.untyped)
  REGEXP_MODIFIERS = ::T.let(nil, ::T.untyped)
  RUBYDOC = ::T.let(nil, ::T.untyped)
  RUBYDOC_OR_DATA = ::T.let(nil, ::T.untyped)
  SIMPLE_ESCAPE = ::T.let(nil, ::T.untyped)
  SYMBOL = ::T.let(nil, ::T.untyped)
  VALUE_FOLLOWS = ::T.let(nil, ::T.untyped)
  VARIABLE = ::T.let(nil, ::T.untyped)
end

class CodeRay::Scanners::Ruby::StringState
  CLOSING_PAREN = ::T.let(nil, ::T.untyped)
  STRING_PATTERN = ::T.let(nil, ::T.untyped)
end

class CodeRay::Scanners::Scanner
  DEFAULT_OPTIONS = ::T.let(nil, ::T.untyped)
  KINDS_NOT_LOC = ::T.let(nil, ::T.untyped)
  SCANNER_STATE_INFO = ::T.let(nil, ::T.untyped)
  SCAN_ERROR_MESSAGE = ::T.let(nil, ::T.untyped)
end

CodeRay::Scanners::Scanner::PLUGIN_HOST = CodeRay::Scanners

class CodeRay::Styles::Style
  DEFAULT_OPTIONS = ::T.let(nil, ::T.untyped)
end

CodeRay::Styles::Style::PLUGIN_HOST = CodeRay::Styles

class Date
  def infinite?(); end
end

class Date::Infinity
  def initialize(d=T.unsafe(nil)); end
end

class Delegator
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

class DidYouMean::ClassNameChecker
  def class_name(); end

  def class_names(); end

  def corrections(); end

  def initialize(exception); end

  def scopes(); end
end

class DidYouMean::CorrectElement
  def call(names, element); end
end

class DidYouMean::CorrectElement
end

module DidYouMean::Correctable
  def corrections(); end

  def original_message(); end

  def spell_checker(); end

  def to_s(); end
end

module DidYouMean::Jaro
  def self.distance(str1, str2); end
end

module DidYouMean::JaroWinkler
  def self.distance(str1, str2); end
end

class DidYouMean::KeyErrorChecker
  def corrections(); end

  def initialize(key_error); end
end

class DidYouMean::KeyErrorChecker
end

module DidYouMean::Levenshtein
  def self.distance(str1, str2); end

  def self.min3(a, b, c); end
end

class DidYouMean::MethodNameChecker
  def corrections(); end

  def initialize(exception); end

  def method_name(); end

  def method_names(); end

  def names_to_exclude(); end

  def receiver(); end
  RB_RESERVED_WORDS = ::T.let(nil, ::T.untyped)
end

class DidYouMean::NullChecker
  def corrections(); end

  def initialize(*_); end
end

class DidYouMean::ParseDimensions
  def call(); end

  def initialize(dictionary, separator); end
end

class DidYouMean::ParseDimensions
end

class DidYouMean::PlainFormatter
  def message_for(corrections); end
end

class DidYouMean::PlainFormatter
end

class DidYouMean::TreeSpellChecker
  def augment(); end

  def correct(input); end

  def dictionary(); end

  def dimensions(); end

  def initialize(dictionary:, separator: T.unsafe(nil), augment: T.unsafe(nil)); end

  def separator(); end
end

class DidYouMean::TreeSpellChecker
end

class DidYouMean::VariableNameChecker
  def corrections(); end

  def cvar_names(); end

  def initialize(exception); end

  def ivar_names(); end

  def lvar_names(); end

  def method_names(); end

  def name(); end
  RB_RESERVED_WORDS = ::T.let(nil, ::T.untyped)
end

module DidYouMean
  def self.correct_error(error_class, spell_checker); end

  def self.formatter(); end

  def self.formatter=(formatter); end
end

class Dir
  def children(); end

  def each_child(); end
end

module Dir::Tmpname
  UNUSABLE_CHARS = ::T.let(nil, ::T.untyped)
end

class Dir
  def self.exists?(_); end
end

class ERB
  def def_method(mod, methodname, fname=T.unsafe(nil)); end

  def def_module(methodname=T.unsafe(nil)); end
end

class ERB::Compiler::Scanner
  DEFAULT_ETAGS = ::T.let(nil, ::T.untyped)
  DEFAULT_STAGS = ::T.let(nil, ::T.untyped)
end

class Encoding
  def _dump(*_); end
  CESU_8 = ::T.let(nil, ::T.untyped)
end

class Encoding::Converter
  def initialize(*_); end
end

class Encoding
  def self._load(_); end
end

module Enumerable
  def chain(*_); end

  def sum(*_); end
end

class Enumerator
  def +(_); end

  def each_with_index(); end
end

class Enumerator::ArithmeticSequence
  def begin(); end

  def each(&blk); end

  def end(); end

  def exclude_end?(); end

  def last(*_); end

  def step(); end
end

class Enumerator::ArithmeticSequence
end

class Enumerator::Chain
end

class Enumerator::Chain
end

class Enumerator::Generator
  def each(*_, &blk); end

  def initialize(*_); end
end

class Enumerator::Lazy
  def eager(); end
end

class Enumerator::Producer
  def each(&blk); end
end

class Enumerator::Producer
end

class Enumerator::Yielder
  def to_proc(); end
end

class Enumerator
  def self.produce(*_); end
end

Errno::EAUTH = Errno::NOERROR

Errno::EBADARCH = Errno::NOERROR

Errno::EBADEXEC = Errno::NOERROR

Errno::EBADMACHO = Errno::NOERROR

Errno::EBADRPC = Errno::NOERROR

Errno::ECAPMODE = Errno::NOERROR

Errno::EDEADLOCK = Errno::EDEADLK

Errno::EDEVERR = Errno::NOERROR

Errno::EDOOFUS = Errno::NOERROR

Errno::EFTYPE = Errno::NOERROR

Errno::EIPSEC = Errno::NOERROR

Errno::ELAST = Errno::NOERROR

Errno::ENEEDAUTH = Errno::NOERROR

Errno::ENOATTR = Errno::NOERROR

Errno::ENOPOLICY = Errno::NOERROR

Errno::ENOTCAPABLE = Errno::NOERROR

class Errno::ENOTSUP
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::ENOTSUP
end

Errno::EPROCLIM = Errno::NOERROR

Errno::EPROCUNAVAIL = Errno::NOERROR

Errno::EPROGMISMATCH = Errno::NOERROR

Errno::EPROGUNAVAIL = Errno::NOERROR

Errno::EPWROFF = Errno::NOERROR

Errno::EQFULL = Errno::NOERROR

Errno::ERPCMISMATCH = Errno::NOERROR

Errno::ESHLIBVERS = Errno::NOERROR

module Etc
  VERSION = ::T.let(nil, ::T.untyped)
end

class Etc::Group
  def gid(); end

  def gid=(_); end

  def mem(); end

  def mem=(_); end

  def name(); end

  def name=(_); end

  def passwd(); end

  def passwd=(_); end
end

class Etc::Group
  extend ::Enumerable
  def self.[](*_); end

  def self.each(&blk); end

  def self.members(); end
end

class Etc::Passwd
  def dir=(_); end

  def gecos(); end

  def gecos=(_); end

  def gid=(_); end

  def name=(_); end

  def passwd=(_); end

  def shell=(_); end

  def uid=(_); end
end

class Etc::Passwd
  extend ::Enumerable
  def self.[](*_); end

  def self.each(&blk); end

  def self.members(); end
end

class ExitCalledError
end

class ExitCalledError
end

class FalseClass
  include ::JSON::Ext::Generator::GeneratorMethods::FalseClass
end

class Fiber
  def initialize(*_); end
end

class File
  RELATIVE_PARENTDIR = ::T.let(nil, ::T.untyped)
  RELATIVE_SAMEDIR = ::T.let(nil, ::T.untyped)
end

class File
  def self.absolute_path?(_); end

  def self.cleanpath(path, rel_root=T.unsafe(nil)); end

  def self.exists?(_); end

  def self.open!(file, *args, &block); end

  def self.read_binary(file); end

  def self.relative_path(from, to); end
end

module FileUtils
  include ::FileUtils::StreamUtils_
end

module FileUtils::DryRun
  include ::FileUtils
  include ::FileUtils::StreamUtils_
  include ::FileUtils::LowMethods
end

module FileUtils::DryRun
  extend ::FileUtils::DryRun
  extend ::FileUtils
  extend ::FileUtils::StreamUtils_
  extend ::FileUtils::LowMethods
end

module FileUtils::NoWrite
  include ::FileUtils
  include ::FileUtils::StreamUtils_
  include ::FileUtils::LowMethods
end

module FileUtils::NoWrite
  extend ::FileUtils::NoWrite
  extend ::FileUtils
  extend ::FileUtils::StreamUtils_
  extend ::FileUtils::LowMethods
end

module FileUtils::Verbose
  include ::FileUtils
  include ::FileUtils::StreamUtils_
end

module FileUtils::Verbose
  extend ::FileUtils::Verbose
  extend ::FileUtils
  extend ::FileUtils::StreamUtils_
end

module FileUtils
  extend ::FileUtils::StreamUtils_
end

class Float
  include ::JSON::Ext::Generator::GeneratorMethods::Float
end

module Forwardable
  VERSION = ::T.let(nil, ::T.untyped)
end

module Forwardable
  def self._compile_method(src, file, line); end

  def self._delegator_method(obj, accessor, method, ali); end

  def self._valid_method?(method); end

  def self.debug(); end

  def self.debug=(debug); end
end

class FrozenError
  def receiver(); end
end

module GC
  def garbage_collect(full_mark: T.unsafe(nil), immediate_mark: T.unsafe(nil), immediate_sweep: T.unsafe(nil)); end
end

module GC
  def self.verify_transient_heap_internal_consistency(); end
end

module Gem
  ConfigMap = ::T.let(nil, ::T.untyped)
  RbConfigPriorities = ::T.let(nil, ::T.untyped)
  RubyGemsVersion = ::T.let(nil, ::T.untyped)
  UNTAINT = ::T.let(nil, ::T.untyped)
end

Gem::Cache = Gem::SourceIndex

class Gem::Exception
  extend ::Gem::Deprecate
end

class Gem::Ext::BuildError
end

class Gem::Ext::BuildError
end

class Gem::Ext::ExtConfBuilder
end

Gem::Ext::ExtConfBuilder::FileEntry = FileUtils::Entry_

class Gem::Ext::ExtConfBuilder
  def self.build(extension, dest_path, results, args=T.unsafe(nil), lib_dir=T.unsafe(nil)); end

  def self.get_relative_path(path); end
end

class Gem::Package
  def gem(); end
end

class Gem::Package::DigestIO
  def digests(); end

  def initialize(io, digests); end

  def write(data); end
end

class Gem::Package::DigestIO
  def self.wrap(io, digests); end
end

class Gem::Package::FileSource
  def initialize(path); end

  def path(); end

  def present?(); end

  def start(); end

  def with_read_io(&block); end

  def with_write_io(&block); end
end

class Gem::Package::FileSource
end

class Gem::Package::IOSource
  def initialize(io); end

  def io(); end

  def path(); end

  def present?(); end

  def start(); end

  def with_read_io(); end

  def with_write_io(); end
end

class Gem::Package::IOSource
end

class Gem::Package::Old
  def extract_files(destination_dir); end

  def file_list(io); end

  def read_until_dashes(io); end

  def skip_ruby(io); end
end

class Gem::Package::Old
end

class Gem::Package::Source
end

class Gem::Package::Source
end

class Gem::Package::TarHeader
  def ==(other); end

  def checksum(); end

  def devmajor(); end

  def devminor(); end

  def empty?(); end

  def gid(); end

  def gname(); end

  def initialize(vals); end

  def linkname(); end

  def magic(); end

  def mode(); end

  def mtime(); end

  def name(); end

  def prefix(); end

  def size(); end

  def typeflag(); end

  def uid(); end

  def uname(); end

  def update_checksum(); end

  def version(); end
  EMPTY_HEADER = ::T.let(nil, ::T.untyped)
  FIELDS = ::T.let(nil, ::T.untyped)
  PACK_FORMAT = ::T.let(nil, ::T.untyped)
  UNPACK_FORMAT = ::T.let(nil, ::T.untyped)
end

class Gem::Package::TarHeader
  def self.from(stream); end

  def self.oct_or_256based(str); end

  def self.strict_oct(str); end
end

class Gem::Package::TarReader::Entry
  def bytes_read(); end

  def check_closed(); end

  def close(); end

  def closed?(); end

  def directory?(); end

  def eof?(); end

  def file?(); end

  def full_name(); end

  def getc(); end

  def header(); end

  def initialize(header, io); end

  def length(); end

  def pos(); end

  def read(len=T.unsafe(nil)); end

  def readpartial(maxlen=T.unsafe(nil), outbuf=T.unsafe(nil)); end

  def rewind(); end

  def size(); end

  def symlink?(); end
end

class Gem::Package::TarReader::Entry
end

class Gem::Package::TarReader
  def self.new(io); end
end

class Gem::Package::TarWriter
  def self.new(io); end
end

class Gem::Package
  def self.new(gem, security_policy=T.unsafe(nil)); end

  def self.raw_spec(path, security_policy=T.unsafe(nil)); end
end

class Gem::PathSupport
  def home(); end

  def initialize(env); end

  def path(); end

  def spec_cache_dir(); end
end

class Gem::RemoteFetcher::FetchError
  include ::Gem::UriParsing
  def initialize(message, uri); end

  def uri(); end

  def uri=(uri); end
end

class Gem::RemoteFetcher::FetchError
end

class Gem::RemoteFetcher::UnknownHostError
end

class Gem::RemoteFetcher::UnknownHostError
end

class Gem::Request
  extend ::Gem::UserInteraction
  extend ::Gem::DefaultUserInteraction
  extend ::Gem::Text
end

class Gem::Resolver::CurrentSet
end

class Gem::Resolver::CurrentSet
end

class Gem::Resolver::LocalSpecification
end

class Gem::Resolver::LocalSpecification
end

class Gem::Resolver::Molinillo::DependencyGraph::Log
  def add_edge_no_circular(graph, origin, destination, requirement); end

  def add_vertex(graph, name, payload, root); end

  def delete_edge(graph, origin_name, destination_name, requirement); end

  def detach_vertex_named(graph, name); end

  def each(&blk); end

  def pop!(graph); end

  def reverse_each(); end

  def rewind_to(graph, tag); end

  def set_payload(graph, name, payload); end

  def tag(graph, tag); end
end

class Gem::Resolver::Molinillo::DependencyGraph::Log
  extend ::Enumerable
end

class Gem::RuntimeRequirementNotMetError
  def suggestion(); end

  def suggestion=(suggestion); end
end

class Gem::RuntimeRequirementNotMetError
end

class Gem::Security::Exception
end

class Gem::Security::Exception
end

Gem::Security::KEY_ALGORITHM = OpenSSL::PKey::RSA

class Gem::Security::Policy
  include ::Gem::UserInteraction
  include ::Gem::DefaultUserInteraction
  include ::Gem::Text
  def check_cert(signer, issuer, time); end

  def check_chain(chain, time); end

  def check_data(public_key, digest, signature, data); end

  def check_key(signer, key); end

  def check_root(chain, time); end

  def check_trust(chain, digester, trust_dir); end

  def initialize(name, policy=T.unsafe(nil), opt=T.unsafe(nil)); end

  def name(); end

  def only_signed(); end

  def only_signed=(only_signed); end

  def only_trusted(); end

  def only_trusted=(only_trusted); end

  def subject(certificate); end

  def verify(chain, key=T.unsafe(nil), digests=T.unsafe(nil), signatures=T.unsafe(nil), full_name=T.unsafe(nil)); end

  def verify_chain(); end

  def verify_chain=(verify_chain); end

  def verify_data(); end

  def verify_data=(verify_data); end

  def verify_root(); end

  def verify_root=(verify_root); end

  def verify_signatures(spec, digests, signatures); end

  def verify_signer(); end

  def verify_signer=(verify_signer); end
end

class Gem::Security::Policy
end

class Gem::Security::Signer
  include ::Gem::UserInteraction
  include ::Gem::DefaultUserInteraction
  include ::Gem::Text
  def cert_chain(); end

  def cert_chain=(cert_chain); end

  def digest_algorithm(); end

  def digest_name(); end

  def extract_name(cert); end

  def initialize(key, cert_chain, passphrase=T.unsafe(nil), options=T.unsafe(nil)); end

  def key(); end

  def key=(key); end

  def load_cert_chain(); end

  def options(); end

  def re_sign_key(expiration_length: T.unsafe(nil)); end

  def sign(data); end
end

class Gem::Security::Signer
  def self.re_sign_cert(expired_cert, expired_cert_path, private_key); end
end

class Gem::Security::TrustDir
  def cert_path(certificate); end

  def dir(); end

  def each_certificate(); end

  def initialize(dir, permissions=T.unsafe(nil)); end

  def issuer_of(certificate); end

  def load_certificate(certificate_file); end

  def name_path(name); end

  def trust_cert(certificate); end

  def verify(); end
end

module Gem::Security
  def self.alt_name_or_x509_entry(certificate, x509_entry); end

  def self.create_cert(subject, key, age=T.unsafe(nil), extensions=T.unsafe(nil), serial=T.unsafe(nil)); end

  def self.create_cert_email(email, key, age=T.unsafe(nil), extensions=T.unsafe(nil)); end

  def self.create_cert_self_signed(subject, key, age=T.unsafe(nil), extensions=T.unsafe(nil), serial=T.unsafe(nil)); end

  def self.create_key(length=T.unsafe(nil), algorithm=T.unsafe(nil)); end

  def self.email_to_name(email_address); end

  def self.re_sign(expired_certificate, private_key, age=T.unsafe(nil), extensions=T.unsafe(nil)); end

  def self.reset(); end

  def self.sign(certificate, signing_key, signing_cert, age=T.unsafe(nil), extensions=T.unsafe(nil), serial=T.unsafe(nil)); end

  def self.trust_dir(); end

  def self.trusted_certificates(&block); end

  def self.write(pemmable, path, permissions=T.unsafe(nil), passphrase=T.unsafe(nil), cipher=T.unsafe(nil)); end
end

class Gem::SpecFetcher
  include ::Gem::UserInteraction
  include ::Gem::DefaultUserInteraction
  include ::Gem::Text
  def available_specs(type); end

  def detect(type=T.unsafe(nil)); end

  def initialize(sources=T.unsafe(nil)); end

  def latest_specs(); end

  def prerelease_specs(); end

  def search_for_dependency(dependency, matching_platform=T.unsafe(nil)); end

  def sources(); end

  def spec_for_dependency(dependency, matching_platform=T.unsafe(nil)); end

  def specs(); end

  def suggest_gems_from_name(gem_name, type=T.unsafe(nil)); end

  def tuples_for(source, type, gracefully_ignore=T.unsafe(nil)); end
end

class Gem::SpecFetcher
  def self.fetcher(); end

  def self.fetcher=(fetcher); end
end

class Gem::Specification
  include ::Bundler::MatchPlatform
  include ::Bundler::GemHelpers
  def to_ruby(); end

  def upstream_rubyforge_project=(*args, &block); end
end

class Gem::Specification
  extend ::Gem::Deprecate
  extend ::Enumerable
end

class Gem::SpecificationPolicy
  include ::Gem::UserInteraction
  include ::Gem::DefaultUserInteraction
  include ::Gem::Text
  def initialize(specification); end

  def packaging(); end

  def packaging=(packaging); end

  def validate(strict=T.unsafe(nil)); end

  def validate_dependencies(); end

  def validate_metadata(); end

  def validate_permissions(); end
  HOMEPAGE_URI_PATTERN = ::T.let(nil, ::T.untyped)
  LAZY = ::T.let(nil, ::T.untyped)
  LAZY_PATTERN = ::T.let(nil, ::T.untyped)
  METADATA_LINK_KEYS = ::T.let(nil, ::T.untyped)
  SPECIAL_CHARACTERS = ::T.let(nil, ::T.untyped)
  VALID_NAME_PATTERN = ::T.let(nil, ::T.untyped)
  VALID_URI_PATTERN = ::T.let(nil, ::T.untyped)
end

class Gem::SpecificationPolicy
end

class Gem::StreamUI
  def _deprecated_debug(statement); end
end

class Gem::StubSpecification
  def build_extensions(); end

  def extensions(); end

  def initialize(filename, base_dir, gems_dir, default_gem); end

  def missing_extensions?(); end

  def valid?(); end
end

class Gem::StubSpecification::StubLine
  def extensions(); end

  def full_name(); end

  def initialize(data, extensions); end

  def name(); end

  def platform(); end

  def require_paths(); end

  def version(); end
end

class Gem::StubSpecification
  def self.default_gemspec_stub(filename, base_dir, gems_dir); end

  def self.gemspec_stub(filename, base_dir, gems_dir); end
end

class Gem::UninstallError
  def spec(); end

  def spec=(spec); end
end

class Gem::UninstallError
end

Gem::UnsatisfiableDepedencyError = Gem::UnsatisfiableDependencyError

Gem::Version::Requirement = Gem::Requirement

module Gem
  def self.upstream_default_bindir(); end

  def self.upstream_default_dir(); end

  def self.upstream_default_path(); end

  def self.upstream_default_specifications_dir(); end
end

class Hash
  include ::JSON::Ext::Generator::GeneratorMethods::Hash
  def deconstruct_keys(_); end
end

class Hash
  def self.try_convert(_); end
end

class IO
  def beep(); end

  def check_winsize_changed(); end

  def clear_screen(); end

  def console_mode(); end

  def console_mode=(console_mode); end

  def cooked(); end

  def cooked!(); end

  def cursor(); end

  def cursor=(cursor); end

  def cursor_down(_); end

  def cursor_left(_); end

  def cursor_right(_); end

  def cursor_up(_); end

  def echo=(echo); end

  def echo?(); end

  def erase_line(_); end

  def erase_screen(_); end

  def getch(*_); end

  def getpass(*_); end

  def goto(_, _1); end

  def goto_column(_); end

  def iflush(); end

  def ioflush(); end

  def noecho(); end

  def nonblock(*_); end

  def nonblock=(nonblock); end

  def nonblock?(); end

  def nread(); end

  def oflush(); end

  def pathconf(_); end

  def pressed?(); end

  def raw(*_); end

  def raw!(*_); end

  def ready?(); end

  def scroll_backward(_); end

  def scroll_forward(_); end

  def set_encoding_by_bom(); end

  def wait(*_); end

  def wait_readable(*_); end

  def wait_writable(*_); end

  def winsize(); end

  def winsize=(winsize); end
end

class IO::ConsoleMode
  def echo=(echo); end

  def raw(*_); end

  def raw!(*_); end
end

class IO::ConsoleMode
end

IO::EWOULDBLOCKWaitReadable = IO::EAGAINWaitReadable

IO::EWOULDBLOCKWaitWritable = IO::EAGAINWaitWritable

class IO
  def self.console(*_); end
end

class IPAddr
  def ==(other); end

  def initialize(addr=T.unsafe(nil), family=T.unsafe(nil)); end
end

class Integer
  include ::JSON::Ext::Generator::GeneratorMethods::Integer
  def to_bn(); end
  GMP_VERSION = ::T.let(nil, ::T.untyped)
end

class JSON::Ext::Generator::State
  def self.from_state(_); end
end

class JSON::Ext::Parser
  def initialize(*_); end
end

JSON::Parser = JSON::Ext::Parser

JSON::State = JSON::Ext::Generator::State

JSON::UnparserError = JSON::GeneratorError

module Kernel
  def itself(); end

  def object_id(); end

  def pretty_inspect(); end

  def then(); end

  def yield_self(); end
end

module Kernel
  def self.at_exit(); end
end

class KeyError
  include ::DidYouMean::Correctable
end

class Logger
  def debug!(); end

  def error!(); end

  def fatal!(); end

  def info!(); end

  def warn!(); end
  SEV_LABEL = ::T.let(nil, ::T.untyped)
end

class Logger::Formatter
  Format = ::T.let(nil, ::T.untyped)
end

class Logger::LogDevice
  include ::MonitorMixin
end

module Logger::Period
  SiD = ::T.let(nil, ::T.untyped)
end

module MethodSource
  VERSION = ::T.let(nil, ::T.untyped)
end

module MethodSource::CodeHelpers::IncompleteExpression
  GENERIC_REGEXPS = ::T.let(nil, ::T.untyped)
  RBX_ONLY_REGEXPS = ::T.let(nil, ::T.untyped)
end

class Monitor
  def enter(); end

  def exit(); end

  def mon_check_owner(); end

  def mon_enter(); end

  def mon_exit(); end

  def mon_locked?(); end

  def mon_owned?(); end

  def mon_synchronize(); end

  def mon_try_enter(); end

  def new_cond(); end

  def synchronize(); end

  def try_enter(); end

  def try_mon_enter(); end

  def wait_for_cond(_, _1); end
end

module MonitorMixin
  def initialize(*args); end
end

class MonitorMixin::ConditionVariable
  def initialize(monitor); end
end

module Mustermann
  DEFAULT_TYPE = ::T.let(nil, ::T.untyped)
end

class Mustermann::AST::Boundaries::NodeTranslator
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

class Mustermann::AST::Expander::NodeTranslator
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

class Mustermann::AST::ParamScanner::NodeTranslator
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

class Mustermann::AST::Pattern
  extend ::SingleForwardable
end

class Mustermann::AST::TemplateGenerator::NodeTranslator
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

class Mustermann::AST::Transformer::ArrayTransform
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

class Mustermann::AST::Transformer::ExpressionTransform
  OPERATORS = ::T.let(nil, ::T.untyped)
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

class Mustermann::AST::Transformer::GroupTransformer
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

class Mustermann::AST::Transformer::NodeTranslator
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

class Mustermann::AST::Transformer::RootTransformer
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

class Mustermann::AST::Translator::NodeTranslator
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

class Mustermann::AST::Validation::NodeTranslator
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

class Mustermann::Caster
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

class NameError
  include ::DidYouMean::Correctable
end

class Net::BufferedIO
  def write_timeout(); end

  def write_timeout=(write_timeout); end
end

class Net::HTTP
  def ipaddr(); end

  def ipaddr=(addr); end

  def max_retries(); end

  def max_retries=(retries); end

  def max_version(); end

  def max_version=(max_version); end

  def min_version(); end

  def min_version=(min_version); end

  def write_timeout(); end

  def write_timeout=(sec); end
  ENVIRONMENT_VARIABLE_IS_MULTIUSER_SAFE = ::T.let(nil, ::T.untyped)
end

Net::HTTP::ProxyMod = Net::HTTP::ProxyDelta

class Net::HTTPAlreadyReported
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPAlreadyReported
end

Net::HTTPClientError::EXCEPTION_TYPE = Net::HTTPServerException

Net::HTTPClientErrorCode = Net::HTTPClientError

class Net::HTTPEarlyHints
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPEarlyHints
end

Net::HTTPFatalErrorCode = Net::HTTPClientError

Net::HTTPInformation::EXCEPTION_TYPE = Net::HTTPError

Net::HTTPInformationCode = Net::HTTPInformation

class Net::HTTPLoopDetected
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPLoopDetected
end

class Net::HTTPMisdirectedRequest
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPMisdirectedRequest
end

Net::HTTPMovedTemporarily = Net::HTTPFound

Net::HTTPMultipleChoice = Net::HTTPMultipleChoices

class Net::HTTPNotExtended
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPNotExtended
end

class Net::HTTPPayloadTooLarge
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPPayloadTooLarge
end

class Net::HTTPProcessing
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPProcessing
end

class Net::HTTPRangeNotSatisfiable
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPRangeNotSatisfiable
end

Net::HTTPRedirectionCode = Net::HTTPRedirection

Net::HTTPRequestURITooLarge = Net::HTTPURITooLong

Net::HTTPResponceReceiver = Net::HTTPResponse

Net::HTTPRetriableCode = Net::HTTPRedirection

Net::HTTPServerError::EXCEPTION_TYPE = Net::HTTPFatalError

Net::HTTPServerErrorCode = Net::HTTPServerError

Net::HTTPSession = Net::HTTP

Net::HTTPSuccessCode = Net::HTTPSuccess

class Net::HTTPURITooLong
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPURITooLong
end

Net::HTTPUnknownResponse::EXCEPTION_TYPE = Net::HTTPError

class Net::HTTPVariantAlsoNegotiates
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPVariantAlsoNegotiates
end

Net::NetPrivate::HTTPRequest = Net::HTTPRequest

Net::NetPrivate::Socket = Net::InternetMessageIO

Net::ProtocRetryError = Net::ProtoRetriableError

class Net::ReadTimeout
  def initialize(io=T.unsafe(nil)); end

  def io(); end
end

class Net::WriteTimeout
  def initialize(io=T.unsafe(nil)); end

  def io(); end
end

class NilClass
  include ::JSON::Ext::Generator::GeneratorMethods::NilClass
end

class NoMatchingPatternError
end

class NoMatchingPatternError
end

class Object
  include ::JSON::Ext::Generator::GeneratorMethods::Object
  include ::PP::ObjectMixin
  def to_yaml(options=T.unsafe(nil)); end
  ARGF = ::T.let(nil, ::T.untyped)
  ARGV = ::T.let(nil, ::T.untyped)
  CROSS_COMPILING = ::T.let(nil, ::T.untyped)
  ENV = ::T.let(nil, ::T.untyped)
  RUBY18 = ::T.let(nil, ::T.untyped)
  RUBY19 = ::T.let(nil, ::T.untyped)
  RUBY_COPYRIGHT = ::T.let(nil, ::T.untyped)
  RUBY_DESCRIPTION = ::T.let(nil, ::T.untyped)
  RUBY_ENGINE = ::T.let(nil, ::T.untyped)
  RUBY_ENGINE_VERSION = ::T.let(nil, ::T.untyped)
  RUBY_PATCHLEVEL = ::T.let(nil, ::T.untyped)
  RUBY_PLATFORM = ::T.let(nil, ::T.untyped)
  RUBY_RELEASE_DATE = ::T.let(nil, ::T.untyped)
  RUBY_REVISION = ::T.let(nil, ::T.untyped)
  RUBY_VERSION = ::T.let(nil, ::T.untyped)
  STDERR = ::T.let(nil, ::T.untyped)
  STDIN = ::T.let(nil, ::T.untyped)
  STDOUT = ::T.let(nil, ::T.untyped)
  TOPLEVEL_BINDING = ::T.let(nil, ::T.untyped)
end

class Object
  def self.yaml_tag(url); end
end

class OpenSSL::ASN1::ASN1Data
  def indefinite_length(); end

  def indefinite_length=(indefinite_length); end
end

class OpenSSL::BN
  def +@(); end

  def -@(); end

  def /(_); end

  def negative?(); end
end

module OpenSSL::KDF
end

class OpenSSL::KDF::KDFError
end

class OpenSSL::KDF::KDFError
end

module OpenSSL::KDF
  def self.hkdf(*_); end

  def self.pbkdf2_hmac(*_); end

  def self.scrypt(*_); end
end

class OpenSSL::OCSP::Request
  def signed?(); end
end

OpenSSL::PKCS7::Signer = OpenSSL::PKCS7::SignerInfo

class OpenSSL::PKey::EC
  EXPLICIT_CURVE = ::T.let(nil, ::T.untyped)
end

class OpenSSL::PKey::EC::Point
  def to_octet_string(_); end
end

module OpenSSL::SSL
  OP_ALLOW_NO_DHE_KEX = ::T.let(nil, ::T.untyped)
  OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION = ::T.let(nil, ::T.untyped)
  OP_CRYPTOPRO_TLSEXT_BUG = ::T.let(nil, ::T.untyped)
  OP_LEGACY_SERVER_CONNECT = ::T.let(nil, ::T.untyped)
  OP_NO_ENCRYPT_THEN_MAC = ::T.let(nil, ::T.untyped)
  OP_NO_RENEGOTIATION = ::T.let(nil, ::T.untyped)
  OP_NO_TLSv1_3 = ::T.let(nil, ::T.untyped)
  OP_SAFARI_ECDHE_ECDSA_BUG = ::T.let(nil, ::T.untyped)
  OP_TLSEXT_PADDING = ::T.let(nil, ::T.untyped)
  SSL2_VERSION = ::T.let(nil, ::T.untyped)
  SSL3_VERSION = ::T.let(nil, ::T.untyped)
  TLS1_1_VERSION = ::T.let(nil, ::T.untyped)
  TLS1_2_VERSION = ::T.let(nil, ::T.untyped)
  TLS1_3_VERSION = ::T.let(nil, ::T.untyped)
  TLS1_VERSION = ::T.let(nil, ::T.untyped)
end

class OpenSSL::SSL::SSLContext
  def add_certificate(*_); end

  def alpn_protocols(); end

  def alpn_protocols=(alpn_protocols); end

  def alpn_select_cb(); end

  def alpn_select_cb=(alpn_select_cb); end

  def enable_fallback_scsv(); end

  def max_version=(version); end

  def min_version=(version); end
  DEFAULT_TMP_DH_CALLBACK = ::T.let(nil, ::T.untyped)
end

class OpenSSL::SSL::SSLSocket
  def alpn_protocol(); end

  def tmp_key(); end
end

module OpenSSL::X509
  V_FLAG_NO_CHECK_TIME = ::T.let(nil, ::T.untyped)
  V_FLAG_TRUSTED_FIRST = ::T.let(nil, ::T.untyped)
end

class OpenSSL::X509::Attribute
  def ==(other); end
end

class OpenSSL::X509::CRL
  def ==(other); end
end

class OpenSSL::X509::Extension
  def ==(other); end
end

class OpenSSL::X509::Name
  def to_utf8(); end
end

class OpenSSL::X509::Request
  def ==(other); end
end

class OpenSSL::X509::Revoked
  def ==(other); end

  def to_der(); end
end

module OpenSSL
  def self.fips_mode(); end
end

class OpenStruct
  VERSION = ::T.let(nil, ::T.untyped)
end

class OptionParser
  def additional_message(typ, opt); end
end

class OptionParser::List
  def get_candidates(id); end
end

class OptionParser::ParseError
  def additional(); end

  def additional=(additional); end
end

module Parallel
  Stop = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
  Version = ::T.let(nil, ::T.untyped)
end

class Parallel::UserInterruptHandler
  INTERRUPT_SIGNAL = ::T.let(nil, ::T.untyped)
end

ParseError = Racc::ParseError

module Parser
  MESSAGES = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

Parser::CurrentRuby = Parser::Ruby27

class Parser::Diagnostic
  LEVELS = ::T.let(nil, ::T.untyped)
end

class Parser::Lexer
  ESCAPES = ::T.let(nil, ::T.untyped)
  KEYWORDS = ::T.let(nil, ::T.untyped)
  KEYWORDS_BEGIN = ::T.let(nil, ::T.untyped)
  LEX_STATES = ::T.let(nil, ::T.untyped)
  PUNCTUATION = ::T.let(nil, ::T.untyped)
  PUNCTUATION_BEGIN = ::T.let(nil, ::T.untyped)
  REGEXP_META_CHARACTERS = ::T.let(nil, ::T.untyped)
end

class Parser::Lexer::Dedenter
  TAB_WIDTH = ::T.let(nil, ::T.untyped)
end

class Parser::Lexer::Literal
  DELIMITERS = ::T.let(nil, ::T.untyped)
  TYPES = ::T.let(nil, ::T.untyped)
end

module Parser::Meta
  NODE_TYPES = ::T.let(nil, ::T.untyped)
end

class Parser::Rewriter
  DEPRECATION_WARNING = ::T.let(nil, ::T.untyped)
end

class Parser::Ruby24
  Racc_arg = ::T.let(nil, ::T.untyped)
  Racc_debug_parser = ::T.let(nil, ::T.untyped)
  Racc_token_to_s_table = ::T.let(nil, ::T.untyped)
end

class Parser::Ruby27
  Racc_arg = ::T.let(nil, ::T.untyped)
  Racc_debug_parser = ::T.let(nil, ::T.untyped)
  Racc_token_to_s_table = ::T.let(nil, ::T.untyped)
end

class Parser::Source::Buffer
  ENCODING_RE = ::T.let(nil, ::T.untyped)
end

class Parser::Source::Comment::Associator
  MAGIC_COMMENT_RE = ::T.let(nil, ::T.untyped)
  POSTFIX_TYPES = ::T.let(nil, ::T.untyped)
end

class Parser::Source::Rewriter
  DEPRECATION_WARNING = ::T.let(nil, ::T.untyped)
end

class Parser::Source::TreeRewriter
  ACTIONS = ::T.let(nil, ::T.untyped)
  DEPRECATION_WARNING = ::T.let(nil, ::T.untyped)
  POLICY_TO_LEVEL = ::T.let(nil, ::T.untyped)
end

class Parser::StaticEnvironment
  FORWARD_ARGS = ::T.let(nil, ::T.untyped)
end

class Pathname
  def fnmatch?(*_); end

  def glob(*_); end

  def make_symlink(_); end
end

class Proc
  def <<(_); end

  def >>(_); end

  def clone(); end
end

module Process
  CLOCK_TAI = ::T.let(nil, ::T.untyped)
end

class ProgressBar::Components::Bar
  DEFAULT_PROGRESS_MARK = ::T.let(nil, ::T.untyped)
  DEFAULT_REMAINDER_MARK = ::T.let(nil, ::T.untyped)
  DEFAULT_UPA_STEPS = ::T.let(nil, ::T.untyped)
end

class ProgressBar::Components::Time
  ELAPSED_LABEL = ::T.let(nil, ::T.untyped)
  ESTIMATED_LABEL = ::T.let(nil, ::T.untyped)
  NO_TIME_ELAPSED_TEXT = ::T.let(nil, ::T.untyped)
  OOB_FRIENDLY_TIME_TEXT = ::T.let(nil, ::T.untyped)
  OOB_LIMIT_IN_HOURS = ::T.let(nil, ::T.untyped)
  OOB_TIME_FORMATS = ::T.let(nil, ::T.untyped)
  OOB_UNKNOWN_TIME_TEXT = ::T.let(nil, ::T.untyped)
  TIME_FORMAT = ::T.let(nil, ::T.untyped)
end

class ProgressBar::Components::Title
  DEFAULT_TITLE = ::T.let(nil, ::T.untyped)
end

class ProgressBar::Format::Molecule
  BAR_MOLECULES = ::T.let(nil, ::T.untyped)
  MOLECULES = ::T.let(nil, ::T.untyped)
end

class ProgressBar::Format::String
  ANSI_SGR_PATTERN = ::T.let(nil, ::T.untyped)
  MOLECULE_PATTERN = ::T.let(nil, ::T.untyped)
end

class ProgressBar::Output
  DEFAULT_OUTPUT_STREAM = ::T.let(nil, ::T.untyped)
end

class ProgressBar::Outputs::NonTty
  DEFAULT_FORMAT_STRING = ::T.let(nil, ::T.untyped)
end

class ProgressBar::Outputs::Tty
  DEFAULT_FORMAT_STRING = ::T.let(nil, ::T.untyped)
end

class ProgressBar::Progress
  DEFAULT_BEGINNING_POSITION = ::T.let(nil, ::T.untyped)
  DEFAULT_SMOOTHING = ::T.let(nil, ::T.untyped)
  DEFAULT_TOTAL = ::T.let(nil, ::T.untyped)
end

class ProgressBar::Time
  TIME_MOCKING_LIBRARY_METHODS = ::T.let(nil, ::T.untyped)
end

class Pry
  BINDING_METHOD_IMPL = ::T.let(nil, ::T.untyped)
  Commands = ::T.let(nil, ::T.untyped)
  EMPTY_COMPLETIONS = ::T.let(nil, ::T.untyped)
  HAS_SAFE_LEVEL = ::T.let(nil, ::T.untyped)
  LOCAL_RC_FILE = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class Pry::BasicObject
  ENV = ::T.let(nil, ::T.untyped)
end

Pry::BasicObject::Dir = Dir

Pry::BasicObject::File = File

Pry::BasicObject::Kernel = Kernel

Pry::BasicObject::LoadError = LoadError

Pry::BasicObject::Pry = Pry

class Pry::CInternals::ETagParser::CFile
  ALTERNATIVE_SEPARATOR = ::T.let(nil, ::T.untyped)
  SYMBOL_SEPARATOR = ::T.let(nil, ::T.untyped)
end

class Pry::Code
  extend ::MethodSource::CodeHelpers
end

class Pry::CodeFile
  DEFAULT_EXT = ::T.let(nil, ::T.untyped)
  EXTENSIONS = ::T.let(nil, ::T.untyped)
  FILES = ::T.let(nil, ::T.untyped)
  INITIAL_PWD = ::T.let(nil, ::T.untyped)
end

class Pry::Command
  VOID_VALUE = ::T.let(nil, ::T.untyped)
end

class Pry::Command::Ls
  DEFAULT_OPTIONS = ::T.let(nil, ::T.untyped)
end

class Pry::Command::Ls::Constants
  DEPRECATED_CONSTANTS = ::T.let(nil, ::T.untyped)
end

class Pry::Command::Ls::Globals
  BUILTIN_GLOBALS = ::T.let(nil, ::T.untyped)
  PSEUDO_GLOBALS = ::T.let(nil, ::T.untyped)
end

class Pry::Command::Wtf
  RUBY_FRAME_PATTERN = ::T.let(nil, ::T.untyped)
end

module Pry::Helpers::DocumentationHelpers
  YARD_TAGS = ::T.let(nil, ::T.untyped)
end

module Pry::Helpers::Text
  COLORS = ::T.let(nil, ::T.untyped)
end

class Pry::Indent
  IGNORE_TOKENS = ::T.let(nil, ::T.untyped)
  MIDWAY_TOKENS = ::T.let(nil, ::T.untyped)
  OPEN_TOKENS = ::T.let(nil, ::T.untyped)
  OPTIONAL_DO_TOKENS = ::T.let(nil, ::T.untyped)
  SINGLELINE_TOKENS = ::T.let(nil, ::T.untyped)
  SPACES = ::T.let(nil, ::T.untyped)
  STATEMENT_END_TOKENS = ::T.let(nil, ::T.untyped)
end

class Pry::InputCompleter
  ARRAY_REGEXP = ::T.let(nil, ::T.untyped)
  CONSTANT_OR_METHOD_REGEXP = ::T.let(nil, ::T.untyped)
  CONSTANT_REGEXP = ::T.let(nil, ::T.untyped)
  GLOBALVARIABLE_REGEXP = ::T.let(nil, ::T.untyped)
  HEX_REGEXP = ::T.let(nil, ::T.untyped)
  NUMERIC_REGEXP = ::T.let(nil, ::T.untyped)
  PROC_OR_HASH_REGEXP = ::T.let(nil, ::T.untyped)
  REGEX_REGEXP = ::T.let(nil, ::T.untyped)
  RESERVED_WORDS = ::T.let(nil, ::T.untyped)
  SYMBOL_METHOD_CALL_REGEXP = ::T.let(nil, ::T.untyped)
  SYMBOL_REGEXP = ::T.let(nil, ::T.untyped)
  TOPLEVEL_LOOKUP_REGEXP = ::T.let(nil, ::T.untyped)
  VARIABLE_REGEXP = ::T.let(nil, ::T.untyped)
  WORD_ESCAPE_STR = ::T.let(nil, ::T.untyped)
end

class Pry::Inspector
  MAP = ::T.let(nil, ::T.untyped)
end

module Pry::MethodInfo
  METHOD_INSPECT_PATTERN = ::T.let(nil, ::T.untyped)
end

class Pry::ObjectPath
  SPECIAL_TERMS = ::T.let(nil, ::T.untyped)
end

class Pry::Output
  DEFAULT_SIZE = ::T.let(nil, ::T.untyped)
end

class Pry::PluginManager
  PRY_PLUGIN_PREFIX = ::T.let(nil, ::T.untyped)
end

class Pry::Slop
  DEFAULT_OPTIONS = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class Pry::Slop::Option
  DEFAULT_OPTIONS = ::T.let(nil, ::T.untyped)
end

module PryDoc
  VERSION = ::T.let(nil, ::T.untyped)
end

module Psych
  VERSION = ::T.let(nil, ::T.untyped)
end

module Psych
  def self.add_builtin_type(type_tag, &block); end

  def self.add_domain_type(domain, type_tag, &block); end

  def self.add_tag(tag, klass); end

  def self.domain_types(); end

  def self.domain_types=(domain_types); end

  def self.dump_tags(); end

  def self.dump_tags=(dump_tags); end

  def self.libyaml_version(); end

  def self.load_tags(); end

  def self.load_tags=(load_tags); end

  def self.remove_type(type_tag); end
end

module Puma
  HAS_SSL = ::T.let(nil, ::T.untyped)
  HTTP_STATUS_CODES = ::T.let(nil, ::T.untyped)
  IS_JRUBY = ::T.let(nil, ::T.untyped)
  IS_WINDOWS = ::T.let(nil, ::T.untyped)
  Plugins = ::T.let(nil, ::T.untyped)
  STATUS_WITH_NO_ENTITY_BODY = ::T.let(nil, ::T.untyped)
end

class Puma::Binder
  RACK_VERSION = ::T.let(nil, ::T.untyped)
end

class Puma::Client
  EmptyBody = ::T.let(nil, ::T.untyped)
end

module Puma::ConfigDefault
  DefaultRackup = ::T.let(nil, ::T.untyped)
  DefaultTCPHost = ::T.let(nil, ::T.untyped)
  DefaultTCPPort = ::T.let(nil, ::T.untyped)
  DefaultWorkerShutdownTimeout = ::T.let(nil, ::T.untyped)
  DefaultWorkerTimeout = ::T.let(nil, ::T.untyped)
end

module Puma::Const
  BANNED_HEADER_KEY = ::T.let(nil, ::T.untyped)
  CGI_VER = ::T.let(nil, ::T.untyped)
  CHUNKED = ::T.let(nil, ::T.untyped)
  CHUNK_SIZE = ::T.let(nil, ::T.untyped)
  CLOSE = ::T.let(nil, ::T.untyped)
  CLOSE_CHUNKED = ::T.let(nil, ::T.untyped)
  CODE_NAME = ::T.let(nil, ::T.untyped)
  COLON = ::T.let(nil, ::T.untyped)
  CONNECTION_CLOSE = ::T.let(nil, ::T.untyped)
  CONNECTION_KEEP_ALIVE = ::T.let(nil, ::T.untyped)
  CONTENT_LENGTH = ::T.let(nil, ::T.untyped)
  CONTENT_LENGTH2 = ::T.let(nil, ::T.untyped)
  CONTENT_LENGTH_S = ::T.let(nil, ::T.untyped)
  CONTINUE = ::T.let(nil, ::T.untyped)
  DQUOTE = ::T.let(nil, ::T.untyped)
  EARLY_HINTS = ::T.let(nil, ::T.untyped)
  ERROR_RESPONSE = ::T.let(nil, ::T.untyped)
  FAST_TRACK_KA_TIMEOUT = ::T.let(nil, ::T.untyped)
  FIRST_DATA_TIMEOUT = ::T.let(nil, ::T.untyped)
  GATEWAY_INTERFACE = ::T.let(nil, ::T.untyped)
  HALT_COMMAND = ::T.let(nil, ::T.untyped)
  HEAD = ::T.let(nil, ::T.untyped)
  HIJACK = ::T.let(nil, ::T.untyped)
  HIJACK_IO = ::T.let(nil, ::T.untyped)
  HIJACK_P = ::T.let(nil, ::T.untyped)
  HTTP = ::T.let(nil, ::T.untyped)
  HTTPS = ::T.let(nil, ::T.untyped)
  HTTPS_KEY = ::T.let(nil, ::T.untyped)
  HTTP_10_200 = ::T.let(nil, ::T.untyped)
  HTTP_11 = ::T.let(nil, ::T.untyped)
  HTTP_11_100 = ::T.let(nil, ::T.untyped)
  HTTP_11_200 = ::T.let(nil, ::T.untyped)
  HTTP_CONNECTION = ::T.let(nil, ::T.untyped)
  HTTP_EXPECT = ::T.let(nil, ::T.untyped)
  HTTP_HEADER_DELIMITER = ::T.let(nil, ::T.untyped)
  HTTP_HOST = ::T.let(nil, ::T.untyped)
  HTTP_VERSION = ::T.let(nil, ::T.untyped)
  HTTP_X_FORWARDED_FOR = ::T.let(nil, ::T.untyped)
  HTTP_X_FORWARDED_PROTO = ::T.let(nil, ::T.untyped)
  HTTP_X_FORWARDED_SCHEME = ::T.let(nil, ::T.untyped)
  HTTP_X_FORWARDED_SSL = ::T.let(nil, ::T.untyped)
  ILLEGAL_HEADER_KEY_REGEX = ::T.let(nil, ::T.untyped)
  ILLEGAL_HEADER_VALUE_REGEX = ::T.let(nil, ::T.untyped)
  KEEP_ALIVE = ::T.let(nil, ::T.untyped)
  LINE_END = ::T.let(nil, ::T.untyped)
  LOCALHOST = ::T.let(nil, ::T.untyped)
  LOCALHOST_IP = ::T.let(nil, ::T.untyped)
  MAX_BODY = ::T.let(nil, ::T.untyped)
  MAX_FAST_INLINE = ::T.let(nil, ::T.untyped)
  MAX_HEADER = ::T.let(nil, ::T.untyped)
  NEWLINE = ::T.let(nil, ::T.untyped)
  PATH_INFO = ::T.let(nil, ::T.untyped)
  PERSISTENT_TIMEOUT = ::T.let(nil, ::T.untyped)
  PORT_443 = ::T.let(nil, ::T.untyped)
  PORT_80 = ::T.let(nil, ::T.untyped)
  PUMA_CONFIG = ::T.let(nil, ::T.untyped)
  PUMA_PEERCERT = ::T.let(nil, ::T.untyped)
  PUMA_SERVER_STRING = ::T.let(nil, ::T.untyped)
  PUMA_SOCKET = ::T.let(nil, ::T.untyped)
  PUMA_TMP_BASE = ::T.let(nil, ::T.untyped)
  PUMA_VERSION = ::T.let(nil, ::T.untyped)
  QUERY_STRING = ::T.let(nil, ::T.untyped)
  RACK_AFTER_REPLY = ::T.let(nil, ::T.untyped)
  RACK_INPUT = ::T.let(nil, ::T.untyped)
  RACK_URL_SCHEME = ::T.let(nil, ::T.untyped)
  REMOTE_ADDR = ::T.let(nil, ::T.untyped)
  REQUEST_METHOD = ::T.let(nil, ::T.untyped)
  REQUEST_PATH = ::T.let(nil, ::T.untyped)
  REQUEST_URI = ::T.let(nil, ::T.untyped)
  RESTART_COMMAND = ::T.let(nil, ::T.untyped)
  SERVER_NAME = ::T.let(nil, ::T.untyped)
  SERVER_PORT = ::T.let(nil, ::T.untyped)
  SERVER_PROTOCOL = ::T.let(nil, ::T.untyped)
  SERVER_SOFTWARE = ::T.let(nil, ::T.untyped)
  STOP_COMMAND = ::T.let(nil, ::T.untyped)
  TRANSFER_ENCODING = ::T.let(nil, ::T.untyped)
  TRANSFER_ENCODING2 = ::T.let(nil, ::T.untyped)
  TRANSFER_ENCODING_CHUNKED = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
  WORKER_CHECK_INTERVAL = ::T.let(nil, ::T.untyped)
  WRITE_TIMEOUT = ::T.let(nil, ::T.untyped)
end

class Puma::ErrorLogger
  REQUEST_FORMAT = ::T.let(nil, ::T.untyped)
end

class Puma::Events
  DEFAULT = ::T.let(nil, ::T.untyped)
end

class Puma::HttpParserError
end

class Puma::HttpParserError
end

module Puma::JSON
  BACKSLASH = ::T.let(nil, ::T.untyped)
  CHAR_TO_ESCAPE = ::T.let(nil, ::T.untyped)
  CONTROL_CHAR_TO_ESCAPE = ::T.let(nil, ::T.untyped)
  QUOTE = ::T.let(nil, ::T.untyped)
end

class Puma::Launcher
  KEYS_NOT_TO_PERSIST_IN_STATE = ::T.let(nil, ::T.untyped)
end

class Puma::Plugin
  CALLER_FILE = ::T.let(nil, ::T.untyped)
end

class Puma::Server
  STAT_METHODS = ::T.let(nil, ::T.untyped)
  ThreadLocalKey = ::T.let(nil, ::T.untyped)
  UNPACK_TCP_STATE_FROM_TCP_INFO = ::T.let(nil, ::T.untyped)
end

class Puma::ThreadPool
  SHUTDOWN_GRACE_TIME = ::T.let(nil, ::T.untyped)
end

module Puma::Util
  DEFAULT_SEP = ::T.let(nil, ::T.untyped)
end

module RDoc::Text
  def language(); end

  def language=(language); end
end

class REXML::Parsers::BaseParser
  QNAME = ::T.let(nil, ::T.untyped)
  QNAME_STR = ::T.let(nil, ::T.untyped)
end

class REXML::Parsers::XPathParser
  LOCAL_NAME_WILDCARD = ::T.let(nil, ::T.untyped)
  PREFIX_WILDCARD = ::T.let(nil, ::T.untyped)
end

class REXML::XPathParser
  DEBUG = ::T.let(nil, ::T.untyped)
end

module Racc
  Copyright = ::T.let(nil, ::T.untyped)
  Racc_No_Extentions = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
  Version = ::T.let(nil, ::T.untyped)
end

class Racc::CparseParams
end

class Racc::CparseParams
end

class Racc::Parser
  Racc_Main_Parsing_Routine = ::T.let(nil, ::T.untyped)
  Racc_Runtime_Core_Id_C = ::T.let(nil, ::T.untyped)
  Racc_Runtime_Core_Revision = ::T.let(nil, ::T.untyped)
  Racc_Runtime_Core_Revision_C = ::T.let(nil, ::T.untyped)
  Racc_Runtime_Core_Revision_R = ::T.let(nil, ::T.untyped)
  Racc_Runtime_Core_Version = ::T.let(nil, ::T.untyped)
  Racc_Runtime_Core_Version_C = ::T.let(nil, ::T.untyped)
  Racc_Runtime_Core_Version_R = ::T.let(nil, ::T.untyped)
  Racc_Runtime_Revision = ::T.let(nil, ::T.untyped)
  Racc_Runtime_Type = ::T.let(nil, ::T.untyped)
  Racc_Runtime_Version = ::T.let(nil, ::T.untyped)
  Racc_YY_Parse_Method = ::T.let(nil, ::T.untyped)
end

module Rack
  CACHE_CONTROL = ::T.let(nil, ::T.untyped)
  CONTENT_LENGTH = ::T.let(nil, ::T.untyped)
  CONTENT_TYPE = ::T.let(nil, ::T.untyped)
  DELETE = ::T.let(nil, ::T.untyped)
  ETAG = ::T.let(nil, ::T.untyped)
  EXPIRES = ::T.let(nil, ::T.untyped)
  GET = ::T.let(nil, ::T.untyped)
  HEAD = ::T.let(nil, ::T.untyped)
  HTTPS = ::T.let(nil, ::T.untyped)
  HTTP_COOKIE = ::T.let(nil, ::T.untyped)
  HTTP_HOST = ::T.let(nil, ::T.untyped)
  HTTP_PORT = ::T.let(nil, ::T.untyped)
  HTTP_VERSION = ::T.let(nil, ::T.untyped)
  LINK = ::T.let(nil, ::T.untyped)
  OPTIONS = ::T.let(nil, ::T.untyped)
  PATCH = ::T.let(nil, ::T.untyped)
  PATH_INFO = ::T.let(nil, ::T.untyped)
  POST = ::T.let(nil, ::T.untyped)
  PUT = ::T.let(nil, ::T.untyped)
  QUERY_STRING = ::T.let(nil, ::T.untyped)
  RACK_ERRORS = ::T.let(nil, ::T.untyped)
  RACK_HIJACK = ::T.let(nil, ::T.untyped)
  RACK_HIJACK_IO = ::T.let(nil, ::T.untyped)
  RACK_INPUT = ::T.let(nil, ::T.untyped)
  RACK_IS_HIJACK = ::T.let(nil, ::T.untyped)
  RACK_LOGGER = ::T.let(nil, ::T.untyped)
  RACK_METHODOVERRIDE_ORIGINAL_METHOD = ::T.let(nil, ::T.untyped)
  RACK_MULTIPART_BUFFER_SIZE = ::T.let(nil, ::T.untyped)
  RACK_MULTIPART_TEMPFILE_FACTORY = ::T.let(nil, ::T.untyped)
  RACK_MULTIPROCESS = ::T.let(nil, ::T.untyped)
  RACK_MULTITHREAD = ::T.let(nil, ::T.untyped)
  RACK_RECURSIVE_INCLUDE = ::T.let(nil, ::T.untyped)
  RACK_REQUEST_COOKIE_HASH = ::T.let(nil, ::T.untyped)
  RACK_REQUEST_COOKIE_STRING = ::T.let(nil, ::T.untyped)
  RACK_REQUEST_FORM_HASH = ::T.let(nil, ::T.untyped)
  RACK_REQUEST_FORM_INPUT = ::T.let(nil, ::T.untyped)
  RACK_REQUEST_FORM_VARS = ::T.let(nil, ::T.untyped)
  RACK_REQUEST_QUERY_HASH = ::T.let(nil, ::T.untyped)
  RACK_REQUEST_QUERY_STRING = ::T.let(nil, ::T.untyped)
  RACK_RUNONCE = ::T.let(nil, ::T.untyped)
  RACK_SESSION = ::T.let(nil, ::T.untyped)
  RACK_SESSION_OPTIONS = ::T.let(nil, ::T.untyped)
  RACK_SESSION_UNPACKED_COOKIE_DATA = ::T.let(nil, ::T.untyped)
  RACK_SHOWSTATUS_DETAIL = ::T.let(nil, ::T.untyped)
  RACK_TEMPFILES = ::T.let(nil, ::T.untyped)
  RACK_URL_SCHEME = ::T.let(nil, ::T.untyped)
  RACK_VERSION = ::T.let(nil, ::T.untyped)
  RELEASE = ::T.let(nil, ::T.untyped)
  REQUEST_METHOD = ::T.let(nil, ::T.untyped)
  REQUEST_PATH = ::T.let(nil, ::T.untyped)
  SCRIPT_NAME = ::T.let(nil, ::T.untyped)
  SERVER_NAME = ::T.let(nil, ::T.untyped)
  SERVER_PORT = ::T.let(nil, ::T.untyped)
  SERVER_PROTOCOL = ::T.let(nil, ::T.untyped)
  SET_COOKIE = ::T.let(nil, ::T.untyped)
  TRACE = ::T.let(nil, ::T.untyped)
  TRANSFER_ENCODING = ::T.let(nil, ::T.untyped)
  UNLINK = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class Rack::Auth::AbstractHandler
  def initialize(app, realm=T.unsafe(nil), &authenticator); end

  def realm(); end

  def realm=(realm); end
end

class Rack::Auth::AbstractHandler
end

class Rack::Auth::AbstractRequest
  def initialize(env); end

  def params(); end

  def parts(); end

  def provided?(); end

  def request(); end

  def scheme(); end

  def valid?(); end
  AUTHORIZATION_KEYS = ::T.let(nil, ::T.untyped)
end

class Rack::Auth::AbstractRequest
end

class Rack::Auth::Basic
  def call(env); end
end

class Rack::Auth::Basic::Request
  def basic?(); end

  def credentials(); end

  def username(); end
end

class Rack::Auth::Basic::Request
end

class Rack::Auth::Basic
end

class Rack::Auth::Digest::MD5
  def call(env); end

  def initialize(app, realm=T.unsafe(nil), opaque=T.unsafe(nil), &authenticator); end

  def opaque(); end

  def opaque=(opaque); end

  def passwords_hashed=(passwords_hashed); end

  def passwords_hashed?(); end
  QOP = ::T.let(nil, ::T.untyped)
end

class Rack::Auth::Digest::MD5
end

class Rack::Auth::Digest::Nonce
  def digest(); end

  def fresh?(); end

  def initialize(timestamp=T.unsafe(nil), given_digest=T.unsafe(nil)); end

  def stale?(); end

  def valid?(); end
end

class Rack::Auth::Digest::Nonce
  def self.parse(string); end

  def self.private_key(); end

  def self.private_key=(private_key); end

  def self.time_limit(); end

  def self.time_limit=(time_limit); end
end

class Rack::Auth::Digest::Params
  def [](k); end

  def []=(k, v); end

  def initialize(); end

  def quote(str); end
  UNQUOTED = ::T.let(nil, ::T.untyped)
end

class Rack::Auth::Digest::Params
  def self.dequote(str); end

  def self.parse(str); end

  def self.split_header_value(str); end
end

class Rack::Auth::Digest::Request
  def correct_uri?(); end

  def digest?(); end

  def method(); end

  def method_missing(sym, *args); end

  def nonce(); end

  def respond_to?(sym, *_); end
end

class Rack::Auth::Digest::Request
end

class Rack::BodyProxy
  def close(); end

  def closed?(); end

  def initialize(body, &block); end

  def method_missing(method_name, *args, &block); end
end

class Rack::BodyProxy
end

class Rack::Builder
  UTF_8_BOM = ::T.let(nil, ::T.untyped)
end

class Rack::Cascade
  def <<(app); end

  def add(app); end

  def apps(); end

  def call(env); end

  def include?(app); end

  def initialize(apps, cascade_for=T.unsafe(nil)); end
  NotFound = ::T.let(nil, ::T.untyped)
end

class Rack::Cascade
end

class Rack::Chunked
  include ::Rack::Utils
  def call(env); end

  def chunkable_version?(ver); end

  def initialize(app); end
end

class Rack::Chunked::Body
  def close(); end

  def each(&block); end

  def initialize(body); end
  TAIL = ::T.let(nil, ::T.untyped)
  TERM = ::T.let(nil, ::T.untyped)
end

class Rack::Chunked::Body
end

class Rack::Chunked::TrailerBody
end

class Rack::Chunked::TrailerBody
end

class Rack::Chunked
end

class Rack::CommonLogger
  FORMAT = ::T.let(nil, ::T.untyped)
end

class Rack::ConditionalGet
  def call(env); end

  def initialize(app); end
end

class Rack::ConditionalGet
end

class Rack::Config
  def call(env); end

  def initialize(app, &block); end
end

class Rack::Config
end

class Rack::ContentLength
  include ::Rack::Utils
  def call(env); end

  def initialize(app); end
end

class Rack::ContentLength
end

class Rack::ContentType
  include ::Rack::Utils
  def call(env); end

  def initialize(app, content_type=T.unsafe(nil)); end
end

class Rack::ContentType
end

class Rack::Deflater
  def call(env); end

  def initialize(app, options=T.unsafe(nil)); end
end

class Rack::Deflater::GzipStream
  def close(); end

  def each(&block); end

  def initialize(body, mtime, sync); end

  def write(data); end
end

class Rack::Deflater::GzipStream
end

class Rack::Deflater
end

class Rack::Directory
  def call(env); end

  def check_bad_request(path_info); end

  def check_forbidden(path_info); end

  def entity_not_found(path_info); end

  def filesize_format(int); end

  def get(env); end

  def initialize(root, app=T.unsafe(nil)); end

  def list_directory(path_info, path, script_name); end

  def list_path(env, path, path_info, script_name); end

  def root(); end

  def stat(path); end
  DIR_FILE = ::T.let(nil, ::T.untyped)
  DIR_PAGE_FOOTER = ::T.let(nil, ::T.untyped)
  DIR_PAGE_HEADER = ::T.let(nil, ::T.untyped)
  FILESIZE_FORMAT = ::T.let(nil, ::T.untyped)
end

class Rack::Directory::DirectoryBody
end

class Rack::Directory::DirectoryBody
end

class Rack::Directory
end

class Rack::ETag
  def call(env); end

  def initialize(app, no_cache_control=T.unsafe(nil), cache_control=T.unsafe(nil)); end
  DEFAULT_CACHE_CONTROL = ::T.let(nil, ::T.untyped)
  ETAG_STRING = ::T.let(nil, ::T.untyped)
end

class Rack::ETag
end

class Rack::Events
  def call(env); end

  def initialize(app, handlers); end
end

module Rack::Events::Abstract
  def on_commit(req, res); end

  def on_error(req, res, e); end

  def on_finish(req, res); end

  def on_send(req, res); end

  def on_start(req, res); end
end

module Rack::Events::Abstract
end

class Rack::Events::BufferedResponse
  def body(); end

  def initialize(status, headers, body); end

  def to_a(); end
end

class Rack::Events::BufferedResponse
end

class Rack::Events::EventedBodyProxy
  def each(&blk); end

  def initialize(body, request, response, handlers, &block); end

  def request(); end

  def response(); end
end

class Rack::Events::EventedBodyProxy
end

class Rack::Events
end

Rack::File = Rack::Files

class Rack::Files
  def call(env); end

  def get(env); end

  def initialize(root, headers=T.unsafe(nil), default_mime=T.unsafe(nil)); end

  def root(); end

  def serving(request, path); end
  ALLOWED_VERBS = ::T.let(nil, ::T.untyped)
  ALLOW_HEADER = ::T.let(nil, ::T.untyped)
  MULTIPART_BOUNDARY = ::T.let(nil, ::T.untyped)
end

class Rack::Files::BaseIterator
  def bytesize(); end

  def close(); end

  def each(&blk); end

  def initialize(path, ranges, options); end

  def options(); end

  def path(); end

  def ranges(); end
end

class Rack::Files::BaseIterator
end

class Rack::Files::Iterator
  def to_path(); end
end

class Rack::Files::Iterator
end

class Rack::Files
  def self.method_added(name); end
end

class Rack::ForwardRequest
  def env(); end

  def initialize(url, env=T.unsafe(nil)); end

  def url(); end
end

class Rack::ForwardRequest
end

module Rack::Handler
end

class Rack::Handler::CGI
end

class Rack::Handler::CGI
  def self.run(app, **options); end

  def self.send_body(body); end

  def self.send_headers(status, headers); end

  def self.serve(app); end
end

class Rack::Handler::WEBrick
  def initialize(server, app); end
end

class Rack::Handler::WEBrick
  def self.run(app, **options); end

  def self.shutdown(); end

  def self.valid_options(); end
end

module Rack::Handler
  def self.default(); end

  def self.get(server); end

  def self.pick(server_names); end

  def self.register(server, klass); end

  def self.try_require(prefix, const_name); end
end

class Rack::Head
  def call(env); end

  def initialize(app); end
end

class Rack::Head
end

class Rack::Lint
  include ::Rack::Lint::Assertion
  def _call(env); end

  def call(env=T.unsafe(nil)); end

  def check_content_length(status, headers); end

  def check_content_type(status, headers); end

  def check_env(env); end

  def check_error(error); end

  def check_headers(header); end

  def check_hijack(env); end

  def check_hijack_response(headers, env); end

  def check_input(input); end

  def check_status(status); end

  def close(); end

  def each(&blk); end

  def initialize(app); end

  def verify_content_length(bytes); end
end

module Rack::Lint::Assertion
  def assert(message); end
end

module Rack::Lint::Assertion
end

class Rack::Lint::ErrorWrapper
  include ::Rack::Lint::Assertion
  def close(*args); end

  def flush(); end

  def initialize(error); end

  def puts(str); end

  def write(str); end
end

class Rack::Lint::ErrorWrapper
end

class Rack::Lint::HijackWrapper
  include ::Rack::Lint::Assertion
  def close(*args, &block); end

  def close_read(*args, &block); end

  def close_write(*args, &block); end

  def closed?(*args, &block); end

  def flush(*args, &block); end

  def initialize(io); end

  def read(*args, &block); end

  def read_nonblock(*args, &block); end

  def write(*args, &block); end

  def write_nonblock(*args, &block); end
  REQUIRED_METHODS = ::T.let(nil, ::T.untyped)
end

class Rack::Lint::HijackWrapper
  extend ::Forwardable
end

class Rack::Lint::InputWrapper
  include ::Rack::Lint::Assertion
  def close(*args); end

  def each(*args, &blk); end

  def gets(*args); end

  def initialize(input); end

  def read(*args); end

  def rewind(*args); end
end

class Rack::Lint::InputWrapper
end

class Rack::Lint::LintError
end

class Rack::Lint::LintError
end

class Rack::Lint
end

class Rack::Lock
  def call(env); end

  def initialize(app, mutex=T.unsafe(nil)); end
end

class Rack::Lock
end

class Rack::Logger
  def call(env); end

  def initialize(app, level=T.unsafe(nil)); end
end

class Rack::Logger
end

class Rack::MediaType
  SPLIT_PATTERN = ::T.let(nil, ::T.untyped)
end

class Rack::MediaType
  def self.params(content_type); end

  def self.type(content_type); end
end

class Rack::MethodOverride
  def call(env); end

  def initialize(app); end

  def method_override(env); end
  ALLOWED_METHODS = ::T.let(nil, ::T.untyped)
  HTTP_METHODS = ::T.let(nil, ::T.untyped)
  HTTP_METHOD_OVERRIDE_HEADER = ::T.let(nil, ::T.untyped)
  METHOD_OVERRIDE_PARAM_KEY = ::T.let(nil, ::T.untyped)
end

class Rack::MethodOverride
end

module Rack::Mime
  MIME_TYPES = ::T.let(nil, ::T.untyped)
end

module Rack::Mime
  def self.match?(value, matcher); end

  def self.mime_type(ext, fallback=T.unsafe(nil)); end
end

class Rack::MockRequest
  def delete(uri, opts=T.unsafe(nil)); end

  def get(uri, opts=T.unsafe(nil)); end

  def head(uri, opts=T.unsafe(nil)); end

  def initialize(app); end

  def options(uri, opts=T.unsafe(nil)); end

  def patch(uri, opts=T.unsafe(nil)); end

  def post(uri, opts=T.unsafe(nil)); end

  def put(uri, opts=T.unsafe(nil)); end

  def request(method=T.unsafe(nil), uri=T.unsafe(nil), opts=T.unsafe(nil)); end
  DEFAULT_ENV = ::T.let(nil, ::T.untyped)
end

class Rack::MockRequest::FatalWarner
  def flush(); end

  def puts(warning); end

  def string(); end

  def write(warning); end
end

class Rack::MockRequest::FatalWarner
end

class Rack::MockRequest::FatalWarning
end

class Rack::MockRequest::FatalWarning
end

class Rack::MockRequest
  def self.env_for(uri=T.unsafe(nil), opts=T.unsafe(nil)); end

  def self.parse_uri_rfc2396(uri); end
end

class Rack::MockResponse
  def =~(other); end

  def cookie(name); end

  def cookies(); end

  def errors(); end

  def errors=(errors); end

  def initialize(status, headers, body, errors=T.unsafe(nil)); end

  def match(other); end

  def original_headers(); end
end

class Rack::MockResponse
  def self.[](*_); end
end

module Rack::Multipart
  ATTRIBUTE = ::T.let(nil, ::T.untyped)
  ATTRIBUTE_CHAR = ::T.let(nil, ::T.untyped)
  BROKEN_QUOTED = ::T.let(nil, ::T.untyped)
  BROKEN_UNQUOTED = ::T.let(nil, ::T.untyped)
  CONDISP = ::T.let(nil, ::T.untyped)
  DISPPARM = ::T.let(nil, ::T.untyped)
  EOL = ::T.let(nil, ::T.untyped)
  EXTENDED_INITIAL_NAME = ::T.let(nil, ::T.untyped)
  EXTENDED_INITIAL_PARAMETER = ::T.let(nil, ::T.untyped)
  EXTENDED_INITIAL_VALUE = ::T.let(nil, ::T.untyped)
  EXTENDED_OTHER_NAME = ::T.let(nil, ::T.untyped)
  EXTENDED_OTHER_PARAMETER = ::T.let(nil, ::T.untyped)
  EXTENDED_OTHER_VALUE = ::T.let(nil, ::T.untyped)
  EXTENDED_PARAMETER = ::T.let(nil, ::T.untyped)
  MULTIPART = ::T.let(nil, ::T.untyped)
  MULTIPART_BOUNDARY = ::T.let(nil, ::T.untyped)
  MULTIPART_CONTENT_DISPOSITION = ::T.let(nil, ::T.untyped)
  MULTIPART_CONTENT_ID = ::T.let(nil, ::T.untyped)
  MULTIPART_CONTENT_TYPE = ::T.let(nil, ::T.untyped)
  REGULAR_PARAMETER = ::T.let(nil, ::T.untyped)
  REGULAR_PARAMETER_NAME = ::T.let(nil, ::T.untyped)
  RFC2183 = ::T.let(nil, ::T.untyped)
  SECTION = ::T.let(nil, ::T.untyped)
  TOKEN = ::T.let(nil, ::T.untyped)
  VALUE = ::T.let(nil, ::T.untyped)
end

class Rack::Multipart::Generator
  def dump(); end

  def initialize(params, first=T.unsafe(nil)); end
end

class Rack::Multipart::Generator
end

class Rack::Multipart::MultipartPartLimitError
end

class Rack::Multipart::MultipartPartLimitError
end

class Rack::Multipart::Parser
  def initialize(boundary, tempfile, bufsize, query_parser); end

  def on_read(content); end

  def result(); end

  def state(); end
  BOUNDARY_REGEX = ::T.let(nil, ::T.untyped)
  BUFSIZE = ::T.let(nil, ::T.untyped)
  CHARSET = ::T.let(nil, ::T.untyped)
  EMPTY = ::T.let(nil, ::T.untyped)
  TEMPFILE_FACTORY = ::T.let(nil, ::T.untyped)
  TEXT_PLAIN = ::T.let(nil, ::T.untyped)
end

class Rack::Multipart::Parser::BoundedIO
  def initialize(io, content_length); end

  def read(size, outbuf=T.unsafe(nil)); end

  def rewind(); end
end

class Rack::Multipart::Parser::BoundedIO
end

class Rack::Multipart::Parser::Collector
  include ::Enumerable
  def each(&blk); end

  def initialize(tempfile); end

  def on_mime_body(mime_index, content); end

  def on_mime_finish(mime_index); end

  def on_mime_head(mime_index, head, filename, content_type, name); end
end

class Rack::Multipart::Parser::Collector::BufferPart
  def close(); end

  def file?(); end
end

class Rack::Multipart::Parser::Collector::BufferPart
end

class Rack::Multipart::Parser::Collector::MimePart
  def get_data(); end
end

class Rack::Multipart::Parser::Collector::MimePart
end

class Rack::Multipart::Parser::Collector::TempfilePart
  def close(); end

  def file?(); end
end

class Rack::Multipart::Parser::Collector::TempfilePart
end

class Rack::Multipart::Parser::Collector
end

class Rack::Multipart::Parser::MultipartInfo
  def params(); end

  def params=(_); end

  def tmp_files(); end

  def tmp_files=(_); end
end

class Rack::Multipart::Parser::MultipartInfo
  def self.[](*_); end

  def self.members(); end
end

class Rack::Multipart::Parser
  def self.parse(io, content_length, content_type, tmpfile, bufsize, qp); end

  def self.parse_boundary(content_type); end
end

class Rack::Multipart::UploadedFile
  def content_type(); end

  def content_type=(content_type); end

  def initialize(filepath=T.unsafe(nil), ct=T.unsafe(nil), bin=T.unsafe(nil), path: T.unsafe(nil), content_type: T.unsafe(nil), binary: T.unsafe(nil), filename: T.unsafe(nil), io: T.unsafe(nil)); end

  def local_path(); end

  def method_missing(method_name, *args, &block); end

  def original_filename(); end

  def path(); end

  def respond_to?(*args); end
end

class Rack::Multipart::UploadedFile
end

module Rack::Multipart
  def self.build_multipart(params, first=T.unsafe(nil)); end

  def self.extract_multipart(req, params=T.unsafe(nil)); end

  def self.parse_multipart(env, params=T.unsafe(nil)); end
end

class Rack::NullLogger
  def <<(msg); end

  def add(severity, message=T.unsafe(nil), progname=T.unsafe(nil), &block); end

  def call(env); end

  def close(); end

  def datetime_format(); end

  def datetime_format=(datetime_format); end

  def debug(progname=T.unsafe(nil), &block); end

  def debug?(); end

  def error(progname=T.unsafe(nil), &block); end

  def error?(); end

  def fatal(progname=T.unsafe(nil), &block); end

  def fatal?(); end

  def formatter(); end

  def formatter=(formatter); end

  def info(progname=T.unsafe(nil), &block); end

  def info?(); end

  def initialize(app); end

  def level(); end

  def level=(level); end

  def progname(); end

  def progname=(progname); end

  def sev_threshold(); end

  def sev_threshold=(sev_threshold); end

  def unknown(progname=T.unsafe(nil), &block); end

  def warn(progname=T.unsafe(nil), &block); end

  def warn?(); end
end

class Rack::NullLogger
end

module Rack::Protection
  VERSION = ::T.let(nil, ::T.untyped)
end

class Rack::Protection::AuthenticityToken
  def mask_authenticity_token(session); end
  TOKEN_LENGTH = ::T.let(nil, ::T.untyped)
end

class Rack::Protection::AuthenticityToken
  def self.random_token(); end

  def self.token(session); end
end

class Rack::Protection::Base
  def accepts?(env); end

  def app(); end

  def call(env); end

  def default_options(); end

  def default_reaction(env); end

  def deny(env); end

  def drop_session(env); end

  def encrypt(value); end

  def html?(headers); end

  def initialize(app, options=T.unsafe(nil)); end

  def instrument(env); end

  def options(); end

  def origin(env); end

  def random_string(secure=T.unsafe(nil)); end

  def react(env); end

  def referrer(env); end

  def report(env); end

  def safe?(env); end

  def secure_compare(a, b); end

  def session(env); end

  def session?(env); end

  def warn(env, message); end
  DEFAULT_OPTIONS = ::T.let(nil, ::T.untyped)
end

class Rack::Protection::Base
  def self.default_options(options); end

  def self.default_reaction(reaction); end
end

class Rack::Protection::ContentSecurityPolicy
  def csp_policy(); end
  DIRECTIVES = ::T.let(nil, ::T.untyped)
  NO_ARG_DIRECTIVES = ::T.let(nil, ::T.untyped)
end

class Rack::Protection::ContentSecurityPolicy
end

class Rack::Protection::CookieTossing
  def bad_cookies(); end

  def cookie_paths(path); end

  def empty_cookie(host, path); end

  def redirect(env); end

  def remove_bad_cookies(request, response); end

  def session_key(); end
end

class Rack::Protection::CookieTossing
end

class Rack::Protection::EscapedParams
  def escape(object); end

  def escape_hash(hash); end

  def escape_string(str); end

  def handle(hash); end

  def initialize(*_); end
end

class Rack::Protection::EscapedParams
  extend ::Rack::Utils
end

class Rack::Protection::FormToken
end

class Rack::Protection::FormToken
end

class Rack::Protection::FrameOptions
  def frame_options(); end
end

class Rack::Protection::FrameOptions
end

class Rack::Protection::HttpOrigin
  def base_url(env); end
  DEFAULT_PORTS = ::T.let(nil, ::T.untyped)
end

class Rack::Protection::HttpOrigin
end

class Rack::Protection::IPSpoofing
end

class Rack::Protection::IPSpoofing
end

class Rack::Protection::JsonCsrf
  def close_body(body); end

  def has_vector?(request, headers); end

  def react_and_close(env, body); end
end

class Rack::Protection::JsonCsrf
end

class Rack::Protection::PathTraversal
  def cleanup(path); end
end

class Rack::Protection::PathTraversal
end

class Rack::Protection::ReferrerPolicy
end

class Rack::Protection::ReferrerPolicy
end

class Rack::Protection::RemoteReferrer
end

class Rack::Protection::RemoteReferrer
end

class Rack::Protection::RemoteToken
end

class Rack::Protection::RemoteToken
end

class Rack::Protection::SessionHijacking
end

class Rack::Protection::SessionHijacking
end

class Rack::Protection::StrictTransport
  def strict_transport(); end
end

class Rack::Protection::StrictTransport
end

class Rack::Protection::XSSHeader
end

class Rack::Protection::XSSHeader
end

class Rack::QueryParser
  COMMON_SEP = ::T.let(nil, ::T.untyped)
  DEFAULT_SEP = ::T.let(nil, ::T.untyped)
end

class Rack::Recursive
  def _call(env); end

  def call(env); end

  def include(env, path); end

  def initialize(app); end
end

class Rack::Recursive
end

class Rack::Reloader
  def call(env); end

  def initialize(app, cooldown=T.unsafe(nil), backend=T.unsafe(nil)); end

  def reload!(stderr=T.unsafe(nil)); end

  def safe_load(file, mtime, stderr=T.unsafe(nil)); end
end

module Rack::Reloader::Stat
  def figure_path(file, paths); end

  def rotation(); end

  def safe_stat(file); end
end

module Rack::Reloader::Stat
end

class Rack::Reloader
end

class Rack::Request
  def query(); end

  def version_supplied(); end

  def version_supplied=(version_supplied); end
  ALLOWED_SCHEMES = ::T.let(nil, ::T.untyped)
  SCHEME_WHITELIST = ::T.let(nil, ::T.untyped)
end

module Rack::Request::Helpers
  DEFAULT_PORTS = ::T.let(nil, ::T.untyped)
  FORM_DATA_MEDIA_TYPES = ::T.let(nil, ::T.untyped)
  HTTP_X_FORWARDED_FOR = ::T.let(nil, ::T.untyped)
  HTTP_X_FORWARDED_HOST = ::T.let(nil, ::T.untyped)
  HTTP_X_FORWARDED_PORT = ::T.let(nil, ::T.untyped)
  HTTP_X_FORWARDED_PROTO = ::T.let(nil, ::T.untyped)
  HTTP_X_FORWARDED_SCHEME = ::T.let(nil, ::T.untyped)
  HTTP_X_FORWARDED_SSL = ::T.let(nil, ::T.untyped)
  PARSEABLE_DATA_MEDIA_TYPES = ::T.let(nil, ::T.untyped)
end

class Rack::Response
  CHUNKED = ::T.let(nil, ::T.untyped)
  STATUS_WITH_NO_ENTITY_BODY = ::T.let(nil, ::T.untyped)
end

class Rack::RewindableInput
  def close(); end

  def each(&block); end

  def gets(); end

  def initialize(io); end

  def read(*args); end

  def rewind(); end
end

class Rack::RewindableInput
end

class Rack::Runtime
  def call(env); end

  def initialize(app, name=T.unsafe(nil)); end
  FORMAT_STRING = ::T.let(nil, ::T.untyped)
  HEADER_NAME = ::T.let(nil, ::T.untyped)
end

class Rack::Runtime
end

class Rack::Sendfile
  def call(env); end

  def initialize(app, variation=T.unsafe(nil), mappings=T.unsafe(nil)); end
end

class Rack::Sendfile
end

class Rack::Server
  def app(); end

  def default_options(); end

  def initialize(options=T.unsafe(nil)); end

  def middleware(); end

  def options(); end

  def options=(options); end

  def server(); end

  def start(&block); end
end

class Rack::Server::Options
  def handler_opts(options); end

  def parse!(args); end
end

class Rack::Server::Options
end

class Rack::Server
  def self.default_middleware_by_environment(); end

  def self.logging_middleware(); end

  def self.middleware(); end

  def self.start(options=T.unsafe(nil)); end
end

class Rack::Session::Abstract::Persisted
  DEFAULT_OPTIONS = ::T.let(nil, ::T.untyped)
end

class Rack::Session::Abstract::SessionHash
  Unspecified = ::T.let(nil, ::T.untyped)
end

class Rack::Session::Cookie::SessionId
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

class Rack::Session::Pool
  def delete_session(req, session_id, options); end

  def find_session(req, sid); end

  def generate_sid(); end

  def mutex(); end

  def pool(); end

  def with_lock(req); end

  def write_session(req, session_id, new_session, options); end
  DEFAULT_OPTIONS = ::T.let(nil, ::T.untyped)
end

class Rack::Session::Pool
end

class Rack::Session::SessionId
  ID_VERSION = ::T.let(nil, ::T.untyped)
end

class Rack::ShowExceptions
  CONTEXT = ::T.let(nil, ::T.untyped)
  TEMPLATE = ::T.let(nil, ::T.untyped)
end

class Rack::ShowStatus
  def call(env); end

  def h(obj); end

  def initialize(app); end
  TEMPLATE = ::T.let(nil, ::T.untyped)
end

class Rack::ShowStatus
end

class Rack::Static
  def add_index_root?(path); end

  def applicable_rules(path); end

  def call(env); end

  def can_serve(path); end

  def initialize(app, options=T.unsafe(nil)); end

  def overwrite_file_path(path); end

  def route_file(path); end
end

class Rack::Static
end

class Rack::TempfileReaper
  def call(env); end

  def initialize(app); end
end

class Rack::TempfileReaper
end

class Rack::URLMap
  def call(env); end

  def initialize(map=T.unsafe(nil)); end

  def remap(map); end
end

class Rack::URLMap
end

module Rack::Utils
  COMMON_SEP = ::T.let(nil, ::T.untyped)
  DEFAULT_SEP = ::T.let(nil, ::T.untyped)
  ESCAPE_HTML = ::T.let(nil, ::T.untyped)
  ESCAPE_HTML_PATTERN = ::T.let(nil, ::T.untyped)
  HTTP_STATUS_CODES = ::T.let(nil, ::T.untyped)
  NULL_BYTE = ::T.let(nil, ::T.untyped)
  PATH_SEPS = ::T.let(nil, ::T.untyped)
  STATUS_WITH_NO_ENTITY_BODY = ::T.let(nil, ::T.untyped)
  SYMBOL_TO_STATUS_CODE = ::T.let(nil, ::T.untyped)
end

Rack::Utils::InvalidParameterError = Rack::QueryParser::InvalidParameterError

Rack::Utils::KeySpaceConstrainedParams = Rack::QueryParser::Params

Rack::Utils::ParameterTypeError = Rack::QueryParser::ParameterTypeError

class Random
  def self.bytes(_); end
end

class Range
  def %(_); end

  def entries(); end

  def to_a(); end
end

module RbConfig
  def self.expand(val, config=T.unsafe(nil)); end

  def self.fire_update!(key, val, mkconf=T.unsafe(nil), conf=T.unsafe(nil)); end

  def self.ruby(); end
end

module Readline
  def self.completion_quote_character(); end
end

class Regexp
  TOKEN_KEYS = ::T.let(nil, ::T.untyped)
end

Regexp::Expression::Alternation::OPERAND = Regexp::Expression::Alternative

Regexp::Expression::Anchor::BOL = Regexp::Expression::Anchor::BeginningOfLine

Regexp::Expression::Anchor::BOS = Regexp::Expression::Anchor::BeginningOfString

Regexp::Expression::Anchor::EOL = Regexp::Expression::Anchor::EndOfLine

Regexp::Expression::Anchor::EOS = Regexp::Expression::Anchor::EndOfString

Regexp::Expression::Anchor::EOSobEOL = Regexp::Expression::Anchor::EndOfStringOrBeforeEndOfLine

Regexp::Expression::CharacterSet::Intersection::OPERAND = Regexp::Expression::CharacterSet::IntersectedSequence

Regexp::Expression::MatchLength = Regexp::MatchLength

class Regexp::Expression::Quantifier
  MODES = ::T.let(nil, ::T.untyped)
end

class Regexp::Lexer
  CLOSING_TOKENS = ::T.let(nil, ::T.untyped)
  OPENING_TOKENS = ::T.let(nil, ::T.untyped)
end

class Regexp::Parser
  ENC_FLAGS = ::T.let(nil, ::T.untyped)
  MOD_FLAGS = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class Regexp::Scanner
  PROP_MAPS_DIR = ::T.let(nil, ::T.untyped)
end

module Regexp::Syntax
  VERSION_CONST_REGEXP = ::T.let(nil, ::T.untyped)
  VERSION_FORMAT = ::T.let(nil, ::T.untyped)
  VERSION_REGEXP = ::T.let(nil, ::T.untyped)
end

module Regexp::Syntax::Token
  All = ::T.let(nil, ::T.untyped)
  Map = ::T.let(nil, ::T.untyped)
  Types = ::T.let(nil, ::T.untyped)
end

module Regexp::Syntax::Token::Anchor
  All = ::T.let(nil, ::T.untyped)
  Basic = ::T.let(nil, ::T.untyped)
  Extended = ::T.let(nil, ::T.untyped)
  MatchStart = ::T.let(nil, ::T.untyped)
  String = ::T.let(nil, ::T.untyped)
  Type = ::T.let(nil, ::T.untyped)
end

module Regexp::Syntax::Token::Assertion
  All = ::T.let(nil, ::T.untyped)
  Lookahead = ::T.let(nil, ::T.untyped)
  Lookbehind = ::T.let(nil, ::T.untyped)
  Type = ::T.let(nil, ::T.untyped)
end

module Regexp::Syntax::Token::Backreference
  All = ::T.let(nil, ::T.untyped)
  Name = ::T.let(nil, ::T.untyped)
  Number = ::T.let(nil, ::T.untyped)
  RecursionLevel = ::T.let(nil, ::T.untyped)
  Type = ::T.let(nil, ::T.untyped)
end

module Regexp::Syntax::Token::CharacterSet
  All = ::T.let(nil, ::T.untyped)
  Basic = ::T.let(nil, ::T.untyped)
  Extended = ::T.let(nil, ::T.untyped)
  Type = ::T.let(nil, ::T.untyped)
end

module Regexp::Syntax::Token::CharacterType
  All = ::T.let(nil, ::T.untyped)
  Basic = ::T.let(nil, ::T.untyped)
  Clustered = ::T.let(nil, ::T.untyped)
  Extended = ::T.let(nil, ::T.untyped)
  Hex = ::T.let(nil, ::T.untyped)
  Type = ::T.let(nil, ::T.untyped)
end

module Regexp::Syntax::Token::Conditional
  All = ::T.let(nil, ::T.untyped)
  Condition = ::T.let(nil, ::T.untyped)
  Delimiters = ::T.let(nil, ::T.untyped)
  Separator = ::T.let(nil, ::T.untyped)
  Type = ::T.let(nil, ::T.untyped)
end

module Regexp::Syntax::Token::Escape
  ASCII = ::T.let(nil, ::T.untyped)
  All = ::T.let(nil, ::T.untyped)
  Basic = ::T.let(nil, ::T.untyped)
  Control = ::T.let(nil, ::T.untyped)
  Hex = ::T.let(nil, ::T.untyped)
  Meta = ::T.let(nil, ::T.untyped)
  Octal = ::T.let(nil, ::T.untyped)
  Type = ::T.let(nil, ::T.untyped)
  Unicode = ::T.let(nil, ::T.untyped)
end

module Regexp::Syntax::Token::FreeSpace
  All = ::T.let(nil, ::T.untyped)
  Type = ::T.let(nil, ::T.untyped)
end

module Regexp::Syntax::Token::Group
  All = ::T.let(nil, ::T.untyped)
  Atomic = ::T.let(nil, ::T.untyped)
  Basic = ::T.let(nil, ::T.untyped)
  Comment = ::T.let(nil, ::T.untyped)
  Extended = ::T.let(nil, ::T.untyped)
  Named = ::T.let(nil, ::T.untyped)
  Passive = ::T.let(nil, ::T.untyped)
  Type = ::T.let(nil, ::T.untyped)
  V1_8_6 = ::T.let(nil, ::T.untyped)
  V2_4_1 = ::T.let(nil, ::T.untyped)
end

module Regexp::Syntax::Token::Keep
  All = ::T.let(nil, ::T.untyped)
  Mark = ::T.let(nil, ::T.untyped)
  Type = ::T.let(nil, ::T.untyped)
end

module Regexp::Syntax::Token::Literal
  All = ::T.let(nil, ::T.untyped)
  Type = ::T.let(nil, ::T.untyped)
end

module Regexp::Syntax::Token::Meta
  All = ::T.let(nil, ::T.untyped)
  Basic = ::T.let(nil, ::T.untyped)
  Extended = ::T.let(nil, ::T.untyped)
  Type = ::T.let(nil, ::T.untyped)
end

module Regexp::Syntax::Token::PosixClass
  All = ::T.let(nil, ::T.untyped)
  Extensions = ::T.let(nil, ::T.untyped)
  NonType = ::T.let(nil, ::T.untyped)
  Standard = ::T.let(nil, ::T.untyped)
  Type = ::T.let(nil, ::T.untyped)
end

module Regexp::Syntax::Token::Quantifier
  All = ::T.let(nil, ::T.untyped)
  Greedy = ::T.let(nil, ::T.untyped)
  Interval = ::T.let(nil, ::T.untyped)
  IntervalAll = ::T.let(nil, ::T.untyped)
  IntervalPossessive = ::T.let(nil, ::T.untyped)
  IntervalReluctant = ::T.let(nil, ::T.untyped)
  Possessive = ::T.let(nil, ::T.untyped)
  Reluctant = ::T.let(nil, ::T.untyped)
  Type = ::T.let(nil, ::T.untyped)
end

module Regexp::Syntax::Token::SubexpressionCall
  All = ::T.let(nil, ::T.untyped)
  Name = ::T.let(nil, ::T.untyped)
  Number = ::T.let(nil, ::T.untyped)
end

module Regexp::Syntax::Token::UnicodeProperty
  Age = ::T.let(nil, ::T.untyped)
  Age_V1_9_3 = ::T.let(nil, ::T.untyped)
  Age_V2_0_0 = ::T.let(nil, ::T.untyped)
  Age_V2_2_0 = ::T.let(nil, ::T.untyped)
  Age_V2_3_0 = ::T.let(nil, ::T.untyped)
  Age_V2_4_0 = ::T.let(nil, ::T.untyped)
  Age_V2_5_0 = ::T.let(nil, ::T.untyped)
  Age_V2_6_0 = ::T.let(nil, ::T.untyped)
  Age_V2_6_2 = ::T.let(nil, ::T.untyped)
  Age_V2_6_3 = ::T.let(nil, ::T.untyped)
  All = ::T.let(nil, ::T.untyped)
  CharType_V1_9_0 = ::T.let(nil, ::T.untyped)
  CharType_V2_5_0 = ::T.let(nil, ::T.untyped)
  Derived = ::T.let(nil, ::T.untyped)
  Derived_V1_9_0 = ::T.let(nil, ::T.untyped)
  Derived_V2_0_0 = ::T.let(nil, ::T.untyped)
  Derived_V2_4_0 = ::T.let(nil, ::T.untyped)
  Derived_V2_5_0 = ::T.let(nil, ::T.untyped)
  Emoji = ::T.let(nil, ::T.untyped)
  Emoji_V2_5_0 = ::T.let(nil, ::T.untyped)
  NonType = ::T.let(nil, ::T.untyped)
  POSIX = ::T.let(nil, ::T.untyped)
  Script = ::T.let(nil, ::T.untyped)
  Script_V1_9_0 = ::T.let(nil, ::T.untyped)
  Script_V1_9_3 = ::T.let(nil, ::T.untyped)
  Script_V2_0_0 = ::T.let(nil, ::T.untyped)
  Script_V2_2_0 = ::T.let(nil, ::T.untyped)
  Script_V2_3_0 = ::T.let(nil, ::T.untyped)
  Script_V2_4_0 = ::T.let(nil, ::T.untyped)
  Script_V2_5_0 = ::T.let(nil, ::T.untyped)
  Script_V2_6_0 = ::T.let(nil, ::T.untyped)
  Script_V2_6_2 = ::T.let(nil, ::T.untyped)
  Type = ::T.let(nil, ::T.untyped)
  UnicodeBlock = ::T.let(nil, ::T.untyped)
  UnicodeBlock_V1_9_0 = ::T.let(nil, ::T.untyped)
  UnicodeBlock_V2_0_0 = ::T.let(nil, ::T.untyped)
  UnicodeBlock_V2_2_0 = ::T.let(nil, ::T.untyped)
  UnicodeBlock_V2_3_0 = ::T.let(nil, ::T.untyped)
  UnicodeBlock_V2_4_0 = ::T.let(nil, ::T.untyped)
  UnicodeBlock_V2_5_0 = ::T.let(nil, ::T.untyped)
  UnicodeBlock_V2_6_0 = ::T.let(nil, ::T.untyped)
  UnicodeBlock_V2_6_2 = ::T.let(nil, ::T.untyped)
  V1_9_0 = ::T.let(nil, ::T.untyped)
  V1_9_3 = ::T.let(nil, ::T.untyped)
  V2_0_0 = ::T.let(nil, ::T.untyped)
  V2_2_0 = ::T.let(nil, ::T.untyped)
  V2_3_0 = ::T.let(nil, ::T.untyped)
  V2_4_0 = ::T.let(nil, ::T.untyped)
  V2_5_0 = ::T.let(nil, ::T.untyped)
  V2_6_0 = ::T.let(nil, ::T.untyped)
  V2_6_2 = ::T.let(nil, ::T.untyped)
  V2_6_3 = ::T.let(nil, ::T.untyped)
end

module Regexp::Syntax::Token::UnicodeProperty::Category
  All = ::T.let(nil, ::T.untyped)
  Codepoint = ::T.let(nil, ::T.untyped)
  Letter = ::T.let(nil, ::T.untyped)
  Mark = ::T.let(nil, ::T.untyped)
  Number = ::T.let(nil, ::T.untyped)
  Punctuation = ::T.let(nil, ::T.untyped)
  Separator = ::T.let(nil, ::T.untyped)
  Symbol = ::T.let(nil, ::T.untyped)
end

class Resolv::DNS
  def extract_resources(msg, name, typeclass); end

  def getname(address); end
  RequestID = ::T.let(nil, ::T.untyped)
  RequestIDMutex = ::T.let(nil, ::T.untyped)
end

class Resolv::DNS::Config
  def initialize(config_info=T.unsafe(nil)); end
end

class Resolv::DNS::Label::Str
  def initialize(string); end
end

class Resolv::DNS::Message
  def initialize(id=T.unsafe(nil)); end
end

class Resolv::DNS::Message::MessageDecoder
  def initialize(data); end
end

class Resolv::DNS::Requester::ConnectedUDP
  def initialize(host, port=T.unsafe(nil)); end

  def lazy_initialize(); end
end

class Resolv::DNS::Requester::Sender
  def initialize(msg, data, sock); end
end

class Resolv::DNS::Requester::TCP
  def initialize(host, port=T.unsafe(nil)); end
end

class Resolv::DNS::Requester::UnconnectedUDP
  def initialize(*nameserver_port); end

  def lazy_initialize(); end
end

class Resolv::DNS::Requester::UnconnectedUDP::Sender
  def initialize(msg, data, sock, host, port); end
end

class Resolv::DNS::Resource
  ClassValue = ::T.let(nil, ::T.untyped)
end

class Resolv::DNS::Resource::LOC
  def initialize(version, ssize, hprecision, vprecision, latitude, longitude, altitude); end
end

class Resolv::DNS
  def self.allocate_request_id(host, port); end

  def self.bind_random_port(udpsock, bind_host=T.unsafe(nil)); end

  def self.free_request_id(host, port, id); end

  def self.random(arg); end
end

class Ripper
  def column(); end

  def debug_output(); end

  def debug_output=(debug_output); end

  def encoding(); end

  def end_seen?(); end

  def error?(); end

  def filename(); end

  def initialize(*_); end

  def lineno(); end

  def parse(); end

  def state(); end

  def token(); end

  def yydebug(); end

  def yydebug=(yydebug); end
  EXPR_ARG = ::T.let(nil, ::T.untyped)
  EXPR_ARG_ANY = ::T.let(nil, ::T.untyped)
  EXPR_BEG = ::T.let(nil, ::T.untyped)
  EXPR_BEG_ANY = ::T.let(nil, ::T.untyped)
  EXPR_CLASS = ::T.let(nil, ::T.untyped)
  EXPR_CMDARG = ::T.let(nil, ::T.untyped)
  EXPR_DOT = ::T.let(nil, ::T.untyped)
  EXPR_END = ::T.let(nil, ::T.untyped)
  EXPR_ENDARG = ::T.let(nil, ::T.untyped)
  EXPR_ENDFN = ::T.let(nil, ::T.untyped)
  EXPR_END_ANY = ::T.let(nil, ::T.untyped)
  EXPR_FITEM = ::T.let(nil, ::T.untyped)
  EXPR_FNAME = ::T.let(nil, ::T.untyped)
  EXPR_LABEL = ::T.let(nil, ::T.untyped)
  EXPR_LABELED = ::T.let(nil, ::T.untyped)
  EXPR_MID = ::T.let(nil, ::T.untyped)
  EXPR_NONE = ::T.let(nil, ::T.untyped)
  EXPR_VALUE = ::T.let(nil, ::T.untyped)
  PARSER_EVENT_TABLE = ::T.let(nil, ::T.untyped)
  SCANNER_EVENT_TABLE = ::T.let(nil, ::T.untyped)
  Version = ::T.let(nil, ::T.untyped)
end

class Ripper::Filter
  def initialize(src, filename=T.unsafe(nil), lineno=T.unsafe(nil)); end
end

class Ripper::Lexer
  def errors(); end

  def lex(); end

  def scan(); end

  def tokenize(); end
end

class Ripper::Lexer::Elem
  def event(); end

  def event=(_); end

  def initialize(pos, event, tok, state, message=T.unsafe(nil)); end

  def message(); end

  def message=(_); end

  def pos(); end

  def pos=(_); end

  def state(); end

  def state=(_); end

  def tok(); end

  def tok=(_); end
end

class Ripper::Lexer::Elem
  def self.[](*_); end

  def self.members(); end
end

class Ripper::Lexer::State
  def &(i); end

  def ==(i); end

  def allbits?(i); end

  def anybits?(i); end

  def initialize(i); end

  def nobits?(i); end

  def to_i(); end

  def to_int(); end

  def to_int=(_); end

  def to_s=(_); end

  def |(i); end
end

class Ripper::Lexer::State
  def self.[](*_); end

  def self.members(); end
end

class Ripper::Lexer
end

class Ripper::SexpBuilder
  def on_BEGIN(*args); end

  def on_CHAR(tok); end

  def on_END(*args); end

  def on___end__(tok); end

  def on_alias(*args); end

  def on_alias_error(*args); end

  def on_aref(*args); end

  def on_aref_field(*args); end

  def on_arg_ambiguous(*args); end

  def on_arg_paren(*args); end

  def on_args_add(*args); end

  def on_args_add_block(*args); end

  def on_args_add_star(*args); end

  def on_args_forward(*args); end

  def on_args_new(*args); end

  def on_array(*args); end

  def on_aryptn(*args); end

  def on_assign(*args); end

  def on_assign_error(*args); end

  def on_assoc_new(*args); end

  def on_assoc_splat(*args); end

  def on_assoclist_from_args(*args); end

  def on_backref(tok); end

  def on_backtick(tok); end

  def on_bare_assoc_hash(*args); end

  def on_begin(*args); end

  def on_binary(*args); end

  def on_block_var(*args); end

  def on_blockarg(*args); end

  def on_bodystmt(*args); end

  def on_brace_block(*args); end

  def on_break(*args); end

  def on_call(*args); end

  def on_case(*args); end

  def on_class(*args); end

  def on_class_name_error(*args); end

  def on_comma(tok); end

  def on_command(*args); end

  def on_command_call(*args); end

  def on_comment(tok); end

  def on_const(tok); end

  def on_const_path_field(*args); end

  def on_const_path_ref(*args); end

  def on_const_ref(*args); end

  def on_cvar(tok); end

  def on_def(*args); end

  def on_defined(*args); end

  def on_defs(*args); end

  def on_do_block(*args); end

  def on_dot2(*args); end

  def on_dot3(*args); end

  def on_dyna_symbol(*args); end

  def on_else(*args); end

  def on_elsif(*args); end

  def on_embdoc(tok); end

  def on_embdoc_beg(tok); end

  def on_embdoc_end(tok); end

  def on_embexpr_beg(tok); end

  def on_embexpr_end(tok); end

  def on_embvar(tok); end

  def on_ensure(*args); end

  def on_excessed_comma(*args); end

  def on_fcall(*args); end

  def on_field(*args); end

  def on_float(tok); end

  def on_for(*args); end

  def on_gvar(tok); end

  def on_hash(*args); end

  def on_heredoc_beg(tok); end

  def on_heredoc_end(tok); end

  def on_hshptn(*args); end

  def on_ident(tok); end

  def on_if(*args); end

  def on_if_mod(*args); end

  def on_ifop(*args); end

  def on_ignored_nl(tok); end

  def on_ignored_sp(tok); end

  def on_imaginary(tok); end

  def on_in(*args); end

  def on_int(tok); end

  def on_ivar(tok); end

  def on_kw(tok); end

  def on_kwrest_param(*args); end

  def on_label(tok); end

  def on_label_end(tok); end

  def on_lambda(*args); end

  def on_lbrace(tok); end

  def on_lbracket(tok); end

  def on_lparen(tok); end

  def on_magic_comment(*args); end

  def on_massign(*args); end

  def on_method_add_arg(*args); end

  def on_method_add_block(*args); end

  def on_mlhs_add(*args); end

  def on_mlhs_add_post(*args); end

  def on_mlhs_add_star(*args); end

  def on_mlhs_new(*args); end

  def on_mlhs_paren(*args); end

  def on_module(*args); end

  def on_mrhs_add(*args); end

  def on_mrhs_add_star(*args); end

  def on_mrhs_new(*args); end

  def on_mrhs_new_from_args(*args); end

  def on_next(*args); end

  def on_nl(tok); end

  def on_nokw_param(*args); end

  def on_op(tok); end

  def on_opassign(*args); end

  def on_operator_ambiguous(*args); end

  def on_param_error(*args); end

  def on_params(*args); end

  def on_paren(*args); end

  def on_parse_error(*args); end

  def on_period(tok); end

  def on_program(*args); end

  def on_qsymbols_add(*args); end

  def on_qsymbols_beg(tok); end

  def on_qsymbols_new(*args); end

  def on_qwords_add(*args); end

  def on_qwords_beg(tok); end

  def on_qwords_new(*args); end

  def on_rational(tok); end

  def on_rbrace(tok); end

  def on_rbracket(tok); end

  def on_redo(*args); end

  def on_regexp_add(*args); end

  def on_regexp_beg(tok); end

  def on_regexp_end(tok); end

  def on_regexp_literal(*args); end

  def on_regexp_new(*args); end

  def on_rescue(*args); end

  def on_rescue_mod(*args); end

  def on_rest_param(*args); end

  def on_retry(*args); end

  def on_return(*args); end

  def on_return0(*args); end

  def on_rparen(tok); end

  def on_sclass(*args); end

  def on_semicolon(tok); end

  def on_sp(tok); end

  def on_stmts_add(*args); end

  def on_stmts_new(*args); end

  def on_string_add(*args); end

  def on_string_concat(*args); end

  def on_string_content(*args); end

  def on_string_dvar(*args); end

  def on_string_embexpr(*args); end

  def on_string_literal(*args); end

  def on_super(*args); end

  def on_symbeg(tok); end

  def on_symbol(*args); end

  def on_symbol_literal(*args); end

  def on_symbols_add(*args); end

  def on_symbols_beg(tok); end

  def on_symbols_new(*args); end

  def on_tlambda(tok); end

  def on_tlambeg(tok); end

  def on_top_const_field(*args); end

  def on_top_const_ref(*args); end

  def on_tstring_beg(tok); end

  def on_tstring_content(tok); end

  def on_tstring_end(tok); end

  def on_unary(*args); end

  def on_undef(*args); end

  def on_unless(*args); end

  def on_unless_mod(*args); end

  def on_until(*args); end

  def on_until_mod(*args); end

  def on_var_alias(*args); end

  def on_var_field(*args); end

  def on_var_ref(*args); end

  def on_vcall(*args); end

  def on_void_stmt(*args); end

  def on_when(*args); end

  def on_while(*args); end

  def on_while_mod(*args); end

  def on_word_add(*args); end

  def on_word_new(*args); end

  def on_words_add(*args); end

  def on_words_beg(tok); end

  def on_words_new(*args); end

  def on_words_sep(tok); end

  def on_xstring_add(*args); end

  def on_xstring_literal(*args); end

  def on_xstring_new(*args); end

  def on_yield(*args); end

  def on_yield0(*args); end

  def on_zsuper(*args); end
end

class Ripper::SexpBuilder
end

class Ripper::SexpBuilderPP
end

class Ripper::SexpBuilderPP
end

class Ripper::TokenPattern
  def initialize(pattern); end

  def match(str); end

  def match_list(tokens); end
  MAP = ::T.let(nil, ::T.untyped)
end

class Ripper::TokenPattern::CompileError
end

class Ripper::TokenPattern::CompileError
end

class Ripper::TokenPattern::Error
end

class Ripper::TokenPattern::Error
end

class Ripper::TokenPattern::MatchData
  def initialize(tokens, match); end

  def string(n=T.unsafe(nil)); end
end

class Ripper::TokenPattern::MatchData
end

class Ripper::TokenPattern::MatchError
end

class Ripper::TokenPattern::MatchError
end

class Ripper::TokenPattern
  def self.compile(*_); end
end

class Ripper
  def self.dedent_string(_, _1); end

  def self.lex_state_name(_); end

  def self.token_match(src, pattern); end
end

class RuboCop::AST::Builder
  NODE_MAP = ::T.let(nil, ::T.untyped)
end

class RuboCop::AST::Node
  ARGUMENT_TYPES = ::T.let(nil, ::T.untyped)
  ASSIGNMENTS = ::T.let(nil, ::T.untyped)
  BASIC_CONDITIONALS = ::T.let(nil, ::T.untyped)
  BASIC_LITERALS = ::T.let(nil, ::T.untyped)
  COMPARISON_OPERATORS = ::T.let(nil, ::T.untyped)
  COMPOSITE_LITERALS = ::T.let(nil, ::T.untyped)
  CONDITIONALS = ::T.let(nil, ::T.untyped)
  EQUALS_ASSIGNMENTS = ::T.let(nil, ::T.untyped)
  FALSEY_LITERALS = ::T.let(nil, ::T.untyped)
  IMMUTABLE_LITERALS = ::T.let(nil, ::T.untyped)
  KEYWORDS = ::T.let(nil, ::T.untyped)
  LITERALS = ::T.let(nil, ::T.untyped)
  LOOP_TYPES = ::T.let(nil, ::T.untyped)
  MUTABLE_LITERALS = ::T.let(nil, ::T.untyped)
  OPERATOR_KEYWORDS = ::T.let(nil, ::T.untyped)
  POST_CONDITION_LOOP_TYPES = ::T.let(nil, ::T.untyped)
  REFERENCES = ::T.let(nil, ::T.untyped)
  SHORTHAND_ASSIGNMENTS = ::T.let(nil, ::T.untyped)
  SPECIAL_KEYWORDS = ::T.let(nil, ::T.untyped)
  TRUTHY_LITERALS = ::T.let(nil, ::T.untyped)
  VARIABLES = ::T.let(nil, ::T.untyped)
end

class RuboCop::AST::NodePattern
  VAR = ::T.let(nil, ::T.untyped)
end

class RuboCop::AST::NodePattern::Compiler::Debug
  def comments(*args, &block); end

  def node_ids(); end

  def tokens(*args, &block); end
end

class RuboCop::AST::NodePattern::Compiler::Debug::Colorizer
  def compiler(); end

  def initialize(pattern, compiler: T.unsafe(nil)); end

  def node_pattern(); end

  def pattern(); end

  def test(ruby, trace: T.unsafe(nil)); end
  COLOR_SCHEME = ::T.let(nil, ::T.untyped)
end

class RuboCop::AST::NodePattern::Compiler::Debug::Colorizer::Result
  def color_map(color_scheme=T.unsafe(nil)); end

  def colorize(color_scheme=T.unsafe(nil)); end

  def colorizer(); end

  def colorizer=(_); end

  def match_map(); end

  def matched?(node); end

  def returned(); end

  def returned=(_); end

  def ruby_ast(); end

  def ruby_ast=(_); end

  def trace(); end

  def trace=(_); end
end

class RuboCop::AST::NodePattern::Compiler::Debug::Colorizer::Result
  def self.[](*_); end

  def self.members(); end
end

class RuboCop::AST::NodePattern::Compiler::Debug::Colorizer
end

module RuboCop::AST::NodePattern::Compiler::Debug::InstrumentationSubcompiler
  def do_compile(); end
end

module RuboCop::AST::NodePattern::Compiler::Debug::InstrumentationSubcompiler
end

class RuboCop::AST::NodePattern::Compiler::Debug::NodePatternSubcompiler
  include ::RuboCop::AST::NodePattern::Compiler::Debug::InstrumentationSubcompiler
end

class RuboCop::AST::NodePattern::Compiler::Debug::NodePatternSubcompiler
end

class RuboCop::AST::NodePattern::Compiler::Debug::SequenceSubcompiler
  include ::RuboCop::AST::NodePattern::Compiler::Debug::InstrumentationSubcompiler
end

class RuboCop::AST::NodePattern::Compiler::Debug::SequenceSubcompiler
end

class RuboCop::AST::NodePattern::Compiler::Debug::Trace
  def enter(node_id); end

  def matched?(node_id); end

  def success(node_id); end
end

class RuboCop::AST::NodePattern::Compiler::Debug::Trace
end

class RuboCop::AST::NodePattern::Compiler::Debug
end

class RuboCop::AST::NodePattern::Compiler::SequenceSubcompiler
  DELTA = ::T.let(nil, ::T.untyped)
end

class RuboCop::AST::NodePattern::LexerRex
  CALL = ::T.let(nil, ::T.untyped)
  CONST_NAME = ::T.let(nil, ::T.untyped)
  IDENTIFIER = ::T.let(nil, ::T.untyped)
  NODE_TYPE = ::T.let(nil, ::T.untyped)
  REGEXP = ::T.let(nil, ::T.untyped)
  REGEXP_BODY = ::T.let(nil, ::T.untyped)
  SYMBOL_NAME = ::T.let(nil, ::T.untyped)
end

class RuboCop::AST::NodePattern::Node
  MAP = ::T.let(nil, ::T.untyped)
end

class RuboCop::AST::NodePattern::Node::Repetition
  ARITIES = ::T.let(nil, ::T.untyped)
end

class RuboCop::AST::NodePattern::Parser
  Racc_arg = ::T.let(nil, ::T.untyped)
  Racc_debug_parser = ::T.let(nil, ::T.untyped)
  Racc_token_to_s_table = ::T.let(nil, ::T.untyped)
end

class RuboCop::AST::NodePattern::Parser::WithMeta
  def comments(); end

  def tokens(); end
end

class RuboCop::AST::NodePattern::Parser::WithMeta::Builder
  def emit_atom(type, token); end

  def emit_call(type, selector_t, args=T.unsafe(nil)); end

  def emit_list(type, begin_t, children, end_t); end

  def emit_unary_op(type, operator_t=T.unsafe(nil), *children); end
end

class RuboCop::AST::NodePattern::Parser::WithMeta::Builder
end

class RuboCop::AST::NodePattern::Parser::WithMeta::Lexer
  def initialize(str_or_buffer); end

  def pos(); end
end

class RuboCop::AST::NodePattern::Parser::WithMeta::Lexer
end

class RuboCop::AST::NodePattern::Parser::WithMeta
end

module RuboCop::AST::NodePattern::Sets
  MAX = ::T.let(nil, ::T.untyped)
  REGISTRY = ::T.let(nil, ::T.untyped)
  SET_0_1 = ::T.let(nil, ::T.untyped)
  SET_10_10 = ::T.let(nil, ::T.untyped)
  SET_1_1 = ::T.let(nil, ::T.untyped)
  SET_ADD_DEPENDENCY_ADD_RUNTIME_DEPENDENCY_ADD_DEVELOPMENT_DEPENDENCY = ::T.let(nil, ::T.untyped)
  SET_ATTR_READER_ATTR_WRITER_ATTR_ACCESSOR_ATTR = ::T.let(nil, ::T.untyped)
  SET_CAPTURE2_CAPTURE2E_CAPTURE3_ETC = ::T.let(nil, ::T.untyped)
  SET_CIPHER_DIGEST = ::T.let(nil, ::T.untyped)
  SET_CLASS_EVAL_INSTANCE_EVAL = ::T.let(nil, ::T.untyped)
  SET_CLASS_EVAL_MODULE_EVAL = ::T.let(nil, ::T.untyped)
  SET_CLASS_MODULE = ::T.let(nil, ::T.untyped)
  SET_CLASS_MODULE_STRUCT = ::T.let(nil, ::T.untyped)
  SET_COUNT_LENGTH_SIZE = ::T.let(nil, ::T.untyped)
  SET_DEFINE_METHOD_DEFINE_SINGLETON_METHOD = ::T.let(nil, ::T.untyped)
  SET_EACH_WITH_INDEX_WITH_INDEX = ::T.let(nil, ::T.untyped)
  SET_EACH_WITH_OBJECT_WITH_OBJECT = ::T.let(nil, ::T.untyped)
  SET_ENUMERATOR_RATIONAL_COMPLEX_THREAD = ::T.let(nil, ::T.untyped)
  SET_ESCAPE_ENCODE_UNESCAPE_DECODE = ::T.let(nil, ::T.untyped)
  SET_FIRST_LAST__ETC = ::T.let(nil, ::T.untyped)
  SET_FIXNUM_BIGNUM = ::T.let(nil, ::T.untyped)
  SET_FORMAT_SPRINTF_PRINTF = ::T.let(nil, ::T.untyped)
  SET_GEMCUTTER_RUBYGEMS_RUBYFORGE = ::T.let(nil, ::T.untyped)
  SET_GSUB_GSUB = ::T.let(nil, ::T.untyped)
  SET_INCLUDE_EXTEND_PREPEND = ::T.let(nil, ::T.untyped)
  SET_INSTANCE_EVAL_CLASS_EVAL_MODULE_EVAL = ::T.let(nil, ::T.untyped)
  SET_INSTANCE_EXEC_CLASS_EXEC_MODULE_EXEC = ::T.let(nil, ::T.untyped)
  SET_KEYS_VALUES = ::T.let(nil, ::T.untyped)
  SET_KEY_HAS_KEY_FETCH_ETC = ::T.let(nil, ::T.untyped)
  SET_LAST_FIRST = ::T.let(nil, ::T.untyped)
  SET_LENGTH_SIZE = ::T.let(nil, ::T.untyped)
  SET_LOAD_RESTORE = ::T.let(nil, ::T.untyped)
  SET_MAP_COLLECT = ::T.let(nil, ::T.untyped)
  SET_NEW_OPEN = ::T.let(nil, ::T.untyped)
  SET_NIL_ = ::T.let(nil, ::T.untyped)
  SET_PIPELINE_PIPELINE_R_PIPELINE_RW_ETC = ::T.let(nil, ::T.untyped)
  SET_PRIVATE_PROTECTED = ::T.let(nil, ::T.untyped)
  SET_PRIVATE_PROTECTED_PUBLIC = ::T.let(nil, ::T.untyped)
  SET_PUBLIC_CONSTANT_PRIVATE_CONSTANT = ::T.let(nil, ::T.untyped)
  SET_PUBLIC_PROTECTED_PRIVATE_MODULE_FUNCTION = ::T.let(nil, ::T.untyped)
  SET_RAISE_FAIL = ::T.let(nil, ::T.untyped)
  SET_RAISE_FAIL_THROW_ETC = ::T.let(nil, ::T.untyped)
  SET_REDUCE_INJECT = ::T.let(nil, ::T.untyped)
  SET_REJECT_REJECT = ::T.let(nil, ::T.untyped)
  SET_REQUIRE_REQUIRE_RELATIVE = ::T.let(nil, ::T.untyped)
  SET_SELECT_SELECT = ::T.let(nil, ::T.untyped)
  SET_SEND_PUBLIC_SEND___SEND__ = ::T.let(nil, ::T.untyped)
  SET_SORT_BY_SORT = ::T.let(nil, ::T.untyped)
  SET_SPAWN_SYSTEM = ::T.let(nil, ::T.untyped)
  SET_SPRINTF_FORMAT = ::T.let(nil, ::T.untyped)
  SET_STRUCT_CLASS = ::T.let(nil, ::T.untyped)
  SET_SUCC_PRED_NEXT = ::T.let(nil, ::T.untyped)
  SET_TEMPFILE_STRINGIO = ::T.let(nil, ::T.untyped)
  SET_TO_ENUM_ENUM_FOR = ::T.let(nil, ::T.untyped)
  SET_TO_I_TO_F_TO_C = ::T.let(nil, ::T.untyped)
  SET_TRUE_FALSE = ::T.let(nil, ::T.untyped)
  SET_ZERO_POSITIVE_NEGATIVE = ::T.let(nil, ::T.untyped)
  SET__ = ::T.let(nil, ::T.untyped)
  SET__AT_SLICE = ::T.let(nil, ::T.untyped)
  SET__EQUAL_EQL = ::T.let(nil, ::T.untyped)
  SET__GLOB = ::T.let(nil, ::T.untyped)
  SET___ = ::T.let(nil, ::T.untyped)
  SET___2 = ::T.let(nil, ::T.untyped)
  SET___3 = ::T.let(nil, ::T.untyped)
  SET___4 = ::T.let(nil, ::T.untyped)
  SET___5 = ::T.let(nil, ::T.untyped)
  SET___6 = ::T.let(nil, ::T.untyped)
  SET___7 = ::T.let(nil, ::T.untyped)
  SET___METHOD_____CALLEE__ = ::T.let(nil, ::T.untyped)
  SET____ = ::T.let(nil, ::T.untyped)
  SET____ETC = ::T.let(nil, ::T.untyped)
  SET____ETC_2 = ::T.let(nil, ::T.untyped)
  SET____ETC_3 = ::T.let(nil, ::T.untyped)
end

class RuboCop::AST::ProcessedSource
  STRING_SOURCE_NAME = ::T.let(nil, ::T.untyped)
end

module RuboCop::AST::RuboCopCompatibility
  INCOMPATIBLE_COPS = ::T.let(nil, ::T.untyped)
end

module RuboCop::AST::Traversal
  TYPE_TO_METHOD = ::T.let(nil, ::T.untyped)
end

module RuboCop::AST::Version
  STRING = ::T.let(nil, ::T.untyped)
end

class RuboCop::CLI
  STATUS_ERROR = ::T.let(nil, ::T.untyped)
  STATUS_INTERRUPTED = ::T.let(nil, ::T.untyped)
  STATUS_OFFENSES = ::T.let(nil, ::T.untyped)
  STATUS_SUCCESS = ::T.let(nil, ::T.untyped)
end

class RuboCop::CLI::Command::AutoGenerateConfig
  AUTO_GENERATED_FILE = ::T.let(nil, ::T.untyped)
  PHASE_1 = ::T.let(nil, ::T.untyped)
  PHASE_1_DISABLED = ::T.let(nil, ::T.untyped)
  PHASE_1_OVERRIDDEN = ::T.let(nil, ::T.untyped)
  PHASE_2 = ::T.let(nil, ::T.untyped)
end

class RuboCop::CLI::Command::ExecuteRunner
  INTEGRATION_FORMATTERS = ::T.let(nil, ::T.untyped)
end

class RuboCop::CLI::Command::InitDotfile
  DOTFILE = ::T.let(nil, ::T.untyped)
end

class RuboCop::CLI::Command::SuggestExtensions
  INCLUDED_FORMATTERS = ::T.let(nil, ::T.untyped)
end

class RuboCop::CommentConfig
  COMMENT_DIRECTIVE_REGEXP = ::T.let(nil, ::T.untyped)
  COPS_PATTERN = ::T.let(nil, ::T.untyped)
  COP_NAMES_PATTERN = ::T.let(nil, ::T.untyped)
  COP_NAME_PATTERN = ::T.let(nil, ::T.untyped)
  REDUNDANT_DISABLE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Config
  DEFAULT_RAILS_VERSION = ::T.let(nil, ::T.untyped)
end

class RuboCop::ConfigLoader
  DEFAULT_FILE = ::T.let(nil, ::T.untyped)
  DOTFILE = ::T.let(nil, ::T.untyped)
  RUBOCOP_HOME = ::T.let(nil, ::T.untyped)
  XDG_CONFIG = ::T.let(nil, ::T.untyped)
end

class RuboCop::ConfigLoader
  extend ::RuboCop::FileFinder
end

class RuboCop::ConfigObsoletion
  MOVED_COPS = ::T.let(nil, ::T.untyped)
  OBSOLETE_COPS = ::T.let(nil, ::T.untyped)
  OBSOLETE_ENFORCED_STYLES = ::T.let(nil, ::T.untyped)
  OBSOLETE_PARAMETERS = ::T.let(nil, ::T.untyped)
  REMOVED_COPS = ::T.let(nil, ::T.untyped)
  REMOVED_COPS_WITH_REASON = ::T.let(nil, ::T.untyped)
  RENAMED_COPS = ::T.let(nil, ::T.untyped)
  SPLIT_COPS = ::T.let(nil, ::T.untyped)
end

class RuboCop::ConfigRegeneration
  AUTO_GENERATED_FILE = ::T.let(nil, ::T.untyped)
  COMMAND_REGEX = ::T.let(nil, ::T.untyped)
  DEFAULT_OPTIONS = ::T.let(nil, ::T.untyped)
end

class RuboCop::ConfigValidator
  COMMON_PARAMS = ::T.let(nil, ::T.untyped)
  INTERNAL_PARAMS = ::T.let(nil, ::T.untyped)
  NEW_COPS_VALUES = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::Alignment
  SPACE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::AmbiguousCopName
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Base
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Bundler::DuplicatedGem
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Bundler::GemComment
  CHECKED_OPTIONS_CONFIG = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
  VERSION_SPECIFIERS_OPTION = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Bundler::InsecureProtocolSource
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Bundler::OrderedGems
  MSG = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::CodeLength
  MSG = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::ConfigurableNaming
  FORMATS = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::ConfigurableNumbering
  FORMATS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Corrector
  NOOP_CONSUMER = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::DefNode
  NON_PUBLIC_MODIFIERS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::EachToForCorrector
  CORRECTION_WITHOUT_ARGUMENTS = ::T.let(nil, ::T.untyped)
  CORRECTION_WITH_ARGUMENTS = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::EndKeywordAlignment
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::ForToEachCorrector
  CORRECTION = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::FrozenStringLiteral
  FROZEN_STRING_LITERAL = ::T.let(nil, ::T.untyped)
  FROZEN_STRING_LITERAL_ENABLED = ::T.let(nil, ::T.untyped)
  FROZEN_STRING_LITERAL_TYPES = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Gemspec::DuplicatedAssignment
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Gemspec::OrderedDependencies
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Gemspec::RequiredRubyVersion
  MISSING_MSG = ::T.let(nil, ::T.untyped)
  NOT_EQUAL_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Gemspec::RubyVersionGlobalsUsage
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Generator
  CONFIGURATION_ADDED_MESSAGE = ::T.let(nil, ::T.untyped)
  SOURCE_TEMPLATE = ::T.let(nil, ::T.untyped)
  SPEC_TEMPLATE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Generator::ConfigurationInjector
  TEMPLATE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Generator::RequireFileInjector
  REQUIRE_PATH = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::HashTransformMethod
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::Heredoc
  OPENING_DELIMITER = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::AccessModifierIndentation
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::ArgumentAlignment
  ALIGN_PARAMS_MSG = ::T.let(nil, ::T.untyped)
  FIXED_INDENT_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::ArrayAlignment
  ALIGN_ELEMENTS_MSG = ::T.let(nil, ::T.untyped)
  FIXED_INDENT_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::AssignmentIndentation
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::BeginEndAlignment
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::BlockAlignment
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::BlockEndNewline
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::CaseIndentation
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::ClassStructure
  HUMANIZED_NODE_TYPE = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::ClosingHeredocIndentation
  MSG = ::T.let(nil, ::T.untyped)
  MSG_ARG = ::T.let(nil, ::T.untyped)
  SIMPLE_HEREDOC = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::ClosingParenthesisIndentation
  MSG_ALIGN = ::T.let(nil, ::T.untyped)
  MSG_INDENT = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::CommentIndentation
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::ConditionPosition
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::DefEndAlignment
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::ElseAlignment
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::EmptyComment
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::EmptyLineAfterGuardClause
  END_OF_HEREDOC_LINE = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::EmptyLineAfterMagicComment
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::EmptyLineAfterMultilineCondition
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::EmptyLineBetweenDefs
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::EmptyLines
  LINE_OFFSET = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::EmptyLinesAroundAccessModifier
  MSG_AFTER = ::T.let(nil, ::T.untyped)
  MSG_AFTER_FOR_ONLY_BEFORE = ::T.let(nil, ::T.untyped)
  MSG_BEFORE_AND_AFTER = ::T.let(nil, ::T.untyped)
  MSG_BEFORE_FOR_ONLY_BEFORE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::EmptyLinesAroundArguments
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::EmptyLinesAroundAttributeAccessor
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::EmptyLinesAroundBeginBody
  KIND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::EmptyLinesAroundBlockBody
  KIND = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::Layout::EmptyLinesAroundBody
  MSG_DEFERRED = ::T.let(nil, ::T.untyped)
  MSG_EXTRA = ::T.let(nil, ::T.untyped)
  MSG_MISSING = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::EmptyLinesAroundClassBody
  KIND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::EmptyLinesAroundExceptionHandlingKeywords
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::EmptyLinesAroundMethodBody
  KIND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::EmptyLinesAroundModuleBody
  KIND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::EndOfLine
  MSG_DETECTED = ::T.let(nil, ::T.untyped)
  MSG_MISSING = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::ExtraSpacing
  MSG_UNALIGNED_ASGN = ::T.let(nil, ::T.untyped)
  MSG_UNNECESSARY = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::FirstArgumentIndentation
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::FirstArrayElementIndentation
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::FirstArrayElementLineBreak
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::FirstHashElementIndentation
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::FirstHashElementLineBreak
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::FirstMethodArgumentLineBreak
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::FirstMethodParameterLineBreak
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::FirstParameterIndentation
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::HashAlignment
  MESSAGES = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::HeredocArgumentClosingParenthesis
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::HeredocIndentation
  TYPE_MSG = ::T.let(nil, ::T.untyped)
  WIDTH_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::IndentationConsistency
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::IndentationStyle
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::IndentationWidth
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::InitialIndentation
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::LeadingCommentSpace
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::LeadingEmptyLines
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::LineLength
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::MultilineArrayBraceLayout
  ALWAYS_NEW_LINE_MESSAGE = ::T.let(nil, ::T.untyped)
  ALWAYS_SAME_LINE_MESSAGE = ::T.let(nil, ::T.untyped)
  NEW_LINE_MESSAGE = ::T.let(nil, ::T.untyped)
  SAME_LINE_MESSAGE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::MultilineArrayLineBreaks
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::MultilineAssignmentLayout
  NEW_LINE_OFFENSE = ::T.let(nil, ::T.untyped)
  SAME_LINE_OFFENSE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::MultilineBlockLayout
  ARG_MSG = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  PIPE_SIZE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::MultilineHashBraceLayout
  ALWAYS_NEW_LINE_MESSAGE = ::T.let(nil, ::T.untyped)
  ALWAYS_SAME_LINE_MESSAGE = ::T.let(nil, ::T.untyped)
  NEW_LINE_MESSAGE = ::T.let(nil, ::T.untyped)
  SAME_LINE_MESSAGE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::MultilineHashKeyLineBreaks
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::MultilineMethodArgumentLineBreaks
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::MultilineMethodCallBraceLayout
  ALWAYS_NEW_LINE_MESSAGE = ::T.let(nil, ::T.untyped)
  ALWAYS_SAME_LINE_MESSAGE = ::T.let(nil, ::T.untyped)
  NEW_LINE_MESSAGE = ::T.let(nil, ::T.untyped)
  SAME_LINE_MESSAGE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::MultilineMethodDefinitionBraceLayout
  ALWAYS_NEW_LINE_MESSAGE = ::T.let(nil, ::T.untyped)
  ALWAYS_SAME_LINE_MESSAGE = ::T.let(nil, ::T.untyped)
  NEW_LINE_MESSAGE = ::T.let(nil, ::T.untyped)
  SAME_LINE_MESSAGE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::ParameterAlignment
  ALIGN_PARAMS_MSG = ::T.let(nil, ::T.untyped)
  FIXED_INDENT_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::RescueEnsureAlignment
  ALTERNATIVE_ACCESS_MODIFIERS = ::T.let(nil, ::T.untyped)
  ANCESTOR_TYPES = ::T.let(nil, ::T.untyped)
  ANCESTOR_TYPES_WITH_ACCESS_MODIFIERS = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  RUBY_2_5_ANCESTOR_TYPES = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::SpaceAfterColon
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::SpaceAfterMethodName
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::SpaceAfterNot
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::SpaceAroundEqualsInParameterDefault
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::SpaceAroundKeyword
  ACCEPT_LEFT_PAREN = ::T.let(nil, ::T.untyped)
  ACCEPT_LEFT_SQUARE_BRACKET = ::T.let(nil, ::T.untyped)
  ACCEPT_NAMESPACE_OPERATOR = ::T.let(nil, ::T.untyped)
  DO = ::T.let(nil, ::T.untyped)
  MSG_AFTER = ::T.let(nil, ::T.untyped)
  MSG_BEFORE = ::T.let(nil, ::T.untyped)
  NAMESPACE_OPERATOR = ::T.let(nil, ::T.untyped)
  SAFE_NAVIGATION = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::SpaceAroundMethodCallOperator
  MSG = ::T.let(nil, ::T.untyped)
  SPACES_REGEXP = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::SpaceAroundOperators
  EXCESSIVE_SPACE = ::T.let(nil, ::T.untyped)
  IRREGULAR_METHODS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::SpaceBeforeBlockBraces
  DETECTED_MSG = ::T.let(nil, ::T.untyped)
  MISSING_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::SpaceBeforeComment
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::SpaceBeforeFirstArg
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::SpaceInLambdaLiteral
  MSG_REQUIRE_NO_SPACE = ::T.let(nil, ::T.untyped)
  MSG_REQUIRE_SPACE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::SpaceInsideArrayLiteralBrackets
  EMPTY_MSG = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::SpaceInsideArrayPercentLiteral
  MSG = ::T.let(nil, ::T.untyped)
  MULTIPLE_SPACES_BETWEEN_ITEMS_REGEX = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::SpaceInsideHashLiteralBraces
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::SpaceInsideParens
  MSG = ::T.let(nil, ::T.untyped)
  MSG_SPACE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::SpaceInsidePercentLiteralDelimiters
  BEGIN_REGEX = ::T.let(nil, ::T.untyped)
  END_REGEX = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::SpaceInsideRangeLiteral
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::SpaceInsideReferenceBrackets
  EMPTY_MSG = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::SpaceInsideStringInterpolation
  NO_SPACE_MSG = ::T.let(nil, ::T.untyped)
  SPACE_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::TrailingWhitespace
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::AmbiguousBlockAssociation
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::AmbiguousOperator
  AMBIGUITIES = ::T.let(nil, ::T.untyped)
  MSG_FORMAT = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::AmbiguousRegexpLiteral
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::AssignmentInCondition
  ASGN_TYPES = ::T.let(nil, ::T.untyped)
  MSG_WITHOUT_SAFE_ASSIGNMENT_ALLOWED = ::T.let(nil, ::T.untyped)
  MSG_WITH_SAFE_ASSIGNMENT_ALLOWED = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::BigDecimalNew
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::BinaryOperatorWithIdenticalOperands
  MATH_OPERATORS = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::BooleanSymbol
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::CircularArgumentReference
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::ConstantDefinitionInBlock
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::ConstantResolution
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::Debugger
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::DeprecatedClassMethods
  DEPRECATED_METHODS_OBJECT = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::DeprecatedOpenSSLConstant
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::DisjunctiveAssignmentInConstructor
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::DuplicateBranch
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::DuplicateCaseCondition
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::DuplicateElsifCondition
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::DuplicateHashKey
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::DuplicateMethods
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::DuplicateRegexpCharacterClassElement
  MSG_REPEATED_ELEMENT = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::DuplicateRequire
  MSG = ::T.let(nil, ::T.untyped)
  REQUIRE_METHODS = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::DuplicateRescueException
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::EachWithObjectArgument
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::ElseLayout
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::EmptyBlock
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::EmptyClass
  CLASS_MSG = ::T.let(nil, ::T.untyped)
  METACLASS_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::EmptyConditionalBody
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::EmptyEnsure
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::EmptyExpression
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::EmptyFile
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::EmptyInterpolation
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::EmptyWhen
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::EnsureReturn
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::ErbNewArguments
  MESSAGES = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::FlipFlop
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::FloatComparison
  EQUALITY_METHODS = ::T.let(nil, ::T.untyped)
  FLOAT_INSTANCE_METHODS = ::T.let(nil, ::T.untyped)
  FLOAT_RETURNING_METHODS = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::FloatOutOfRange
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::FormatParameterMismatch
  KERNEL = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  MSG_INVALID = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
  SHOVEL = ::T.let(nil, ::T.untyped)
  STRING_TYPES = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::HashCompareByIdentity
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::HeredocMethodCallPosition
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::IdentityComparison
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::ImplicitStringConcatenation
  FOR_ARRAY = ::T.let(nil, ::T.untyped)
  FOR_METHOD = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::IneffectiveAccessModifier
  ALTERNATIVE_PRIVATE = ::T.let(nil, ::T.untyped)
  ALTERNATIVE_PROTECTED = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::InheritException
  ILLEGAL_CLASSES = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  PREFERRED_BASE_CLASS = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::InterpolationCheck
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::LiteralAsCondition
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::LiteralInInterpolation
  COMPOSITE = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::Loop
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::MissingCopEnableDirective
  MSG = ::T.let(nil, ::T.untyped)
  MSG_BOUND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::MissingSuper
  CALLBACKS = ::T.let(nil, ::T.untyped)
  CALLBACK_MSG = ::T.let(nil, ::T.untyped)
  CLASS_LIFECYCLE_CALLBACKS = ::T.let(nil, ::T.untyped)
  CONSTRUCTOR_MSG = ::T.let(nil, ::T.untyped)
  METHOD_LIFECYCLE_CALLBACKS = ::T.let(nil, ::T.untyped)
  STATELESS_CLASSES = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::MixedRegexpCaptureTypes
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::MultipleComparison
  COMPARISON_METHODS = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::NestedMethodDefinition
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::NestedPercentLiteral
  MSG = ::T.let(nil, ::T.untyped)
  PERCENT_LITERAL_TYPES = ::T.let(nil, ::T.untyped)
  REGEXES = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::NextWithoutAccumulator
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::NoReturnInBeginEndBlocks
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::NonDeterministicRequireOrder
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::NonLocalExitFromIterator
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::NumberConversion
  CONVERSION_METHOD_CLASS_MAPPING = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::OrderedMagicComments
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::OutOfRangeRegexpRef
  MSG = ::T.let(nil, ::T.untyped)
  REGEXP_ARGUMENT_METHODS = ::T.let(nil, ::T.untyped)
  REGEXP_CAPTURE_METHODS = ::T.let(nil, ::T.untyped)
  REGEXP_RECEIVER_METHODS = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::ParenthesesAsGroupedExpression
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::PercentStringArray
  LEADING_QUOTE = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  QUOTES_AND_COMMAS = ::T.let(nil, ::T.untyped)
  TRAILING_QUOTE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::PercentSymbolArray
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::RaiseException
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::RandOne
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::RedundantCopDisableDirective
  COP_NAME = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::RedundantCopEnableDirective
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::RedundantRequireStatement
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::RedundantSafeNavigation
  MSG = ::T.let(nil, ::T.untyped)
  NIL_SPECIFIC_METHODS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::RedundantSplatExpansion
  ARRAY_PARAM_MSG = ::T.let(nil, ::T.untyped)
  ASSIGNMENT_TYPES = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  PERCENT_CAPITAL_I = ::T.let(nil, ::T.untyped)
  PERCENT_CAPITAL_W = ::T.let(nil, ::T.untyped)
  PERCENT_I = ::T.let(nil, ::T.untyped)
  PERCENT_W = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::RedundantStringCoercion
  MSG_DEFAULT = ::T.let(nil, ::T.untyped)
  MSG_SELF = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::RedundantWithIndex
  MSG_EACH_WITH_INDEX = ::T.let(nil, ::T.untyped)
  MSG_WITH_INDEX = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::RedundantWithObject
  MSG_EACH_WITH_OBJECT = ::T.let(nil, ::T.untyped)
  MSG_WITH_OBJECT = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::RegexpAsCondition
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::RequireParentheses
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::RescueException
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::RescueType
  INVALID_TYPES = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::ReturnInVoidContext
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::SafeNavigationChain
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::SafeNavigationConsistency
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::SafeNavigationWithEmpty
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::ScriptPermission
  MSG = ::T.let(nil, ::T.untyped)
  SHEBANG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::SelfAssignment
  ASSIGNMENT_TYPE_TO_RHS_TYPE = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::SendWithMixinArgument
  MIXIN_METHODS = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
  SEND_METHODS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::ShadowedArgument
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::ShadowedException
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::ShadowingOuterLocalVariable
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::StructNewOverride
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
  STRUCT_MEMBER_NAME_TYPES = ::T.let(nil, ::T.untyped)
  STRUCT_METHOD_NAMES = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::SuppressedException
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::ToEnumArguments
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::ToJSON
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::TopLevelReturnWithArgument
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::TrailingCommaInAttributeDeclaration
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::UnderscorePrefixedVariableName
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::UnexpectedBlockArity
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::UnifiedInteger
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::UnmodifiedReduceAccumulator
  MSG = ::T.let(nil, ::T.untyped)
  MSG_INDEX = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::UnreachableCode
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::UnreachableLoop
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::UriEscapeUnescape
  ALTERNATE_METHODS_OF_URI_ESCAPE = ::T.let(nil, ::T.untyped)
  ALTERNATE_METHODS_OF_URI_UNESCAPE = ::T.let(nil, ::T.untyped)
  METHOD_NAMES = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::UriRegexp
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
  URI_CONSTANTS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::UselessAccessModifier
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::UselessAssignment
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::UselessElseWithoutRescue
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::UselessMethodDefinition
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::UselessSetterCall
  ASSIGNMENT_TYPES = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::UselessTimes
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::Void
  BINARY_OPERATORS = ::T.let(nil, ::T.untyped)
  DEFINED_MSG = ::T.let(nil, ::T.untyped)
  LIT_MSG = ::T.let(nil, ::T.untyped)
  NONMUTATING_METHODS = ::T.let(nil, ::T.untyped)
  NONMUTATING_MSG = ::T.let(nil, ::T.untyped)
  OPERATORS = ::T.let(nil, ::T.untyped)
  OP_MSG = ::T.let(nil, ::T.untyped)
  SELF_MSG = ::T.let(nil, ::T.untyped)
  UNARY_OPERATORS = ::T.let(nil, ::T.untyped)
  VAR_MSG = ::T.let(nil, ::T.untyped)
  VOID_CONTEXT_TYPES = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Metrics::AbcSize
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Metrics::BlockLength
  LABEL = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Metrics::BlockNesting
  NESTING_BLOCKS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Metrics::CyclomaticComplexity
  COUNTED_NODES = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Metrics::MethodLength
  LABEL = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Metrics::ParameterLists
  MSG = ::T.let(nil, ::T.untyped)
  OPTIONAL_PARAMETERS_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Metrics::PerceivedComplexity
  COUNTED_NODES = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Metrics::Utils::AbcSizeCalculator
  include ::RuboCop::Cop::Metrics::Utils::RepeatedAttributeDiscount
  include ::RuboCop::AST::Sexp
end

module RuboCop::Cop::Metrics::Utils::IteratingBlock
  KNOWN_ITERATING_METHODS = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::Metrics::Utils::RepeatedAttributeDiscount
  VAR_SETTER_TO_GETTER = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Migration::DepartmentName
  DISABLE_COMMENT_FORMAT = ::T.let(nil, ::T.untyped)
  DISABLING_COPS_CONTENT_TOKEN = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::MultilineExpressionIndentation
  ASSIGNMENT_MESSAGE_TAIL = ::T.let(nil, ::T.untyped)
  DEFAULT_MESSAGE_TAIL = ::T.let(nil, ::T.untyped)
  KEYWORD_ANCESTOR_TYPES = ::T.let(nil, ::T.untyped)
  KEYWORD_MESSAGE_TAIL = ::T.let(nil, ::T.untyped)
  UNALIGNED_RHS_TYPES = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Naming::AccessorMethodName
  MSG_READER = ::T.let(nil, ::T.untyped)
  MSG_WRITER = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Naming::AsciiIdentifiers
  CONSTANT_MSG = ::T.let(nil, ::T.untyped)
  IDENTIFIER_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Naming::BinaryOperatorParameterName
  EXCLUDED = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  OP_LIKE_METHODS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Naming::ClassAndModuleCamelCase
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Naming::ConstantName
  MSG = ::T.let(nil, ::T.untyped)
  SNAKE_CASE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Naming::FileName
  MSG_NO_DEFINITION = ::T.let(nil, ::T.untyped)
  MSG_REGEX = ::T.let(nil, ::T.untyped)
  MSG_SNAKE_CASE = ::T.let(nil, ::T.untyped)
  SNAKE_CASE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Naming::HeredocDelimiterCase
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Naming::HeredocDelimiterNaming
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Naming::MemoizedInstanceVariableName
  MSG = ::T.let(nil, ::T.untyped)
  UNDERSCORE_REQUIRED = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Naming::MethodName
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Naming::RescuedExceptionsVariableName
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Naming::VariableName
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Naming::VariableNumber
  MSG = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::NegativeConditional
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Offense
  COMPARISON_ATTRIBUTES = ::T.let(nil, ::T.untyped)
  NO_LOCATION = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::PreferredDelimiters
  PERCENT_LITERAL_TYPES = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::RangeHelp
  BYTE_ORDER_MARK = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Security::Eval
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Security::JSONLoad
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Security::MarshalLoad
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Security::Open
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Security::YAMLLoad
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Severity
  CODE_TABLE = ::T.let(nil, ::T.untyped)
  NAMES = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::SpaceAfterPunctuation
  MSG = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::SpaceBeforePunctuation
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::AccessModifierDeclarations
  GROUP_STYLE_MESSAGE = ::T.let(nil, ::T.untyped)
  INLINE_STYLE_MESSAGE = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::AccessorGrouping
  ACCESSOR_METHODS = ::T.let(nil, ::T.untyped)
  GROUPED_MSG = ::T.let(nil, ::T.untyped)
  SEPARATED_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::Alias
  MSG_ALIAS = ::T.let(nil, ::T.untyped)
  MSG_ALIAS_METHOD = ::T.let(nil, ::T.untyped)
  MSG_SYMBOL_ARGS = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::AndOr
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::ArgumentsForwarding
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::ArrayCoercion
  CHECK_MSG = ::T.let(nil, ::T.untyped)
  SPLAT_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::ArrayJoin
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::AsciiComments
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::Attr
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::AutoResourceCleanup
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
  TARGET_METHODS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::BarePercentLiterals
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::BeginBlock
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::BisectedAttrAccessor
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::BlockComments
  BEGIN_LENGTH = ::T.let(nil, ::T.untyped)
  END_LENGTH = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::BlockDelimiters
  ALWAYS_BRACES_MESSAGE = ::T.let(nil, ::T.untyped)
  BRACES_REQUIRED_MESSAGE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::CaseCorrector
  extend ::RuboCop::Cop::Style::ConditionalAssignmentHelper
  extend ::RuboCop::Cop::Style::ConditionalCorrectorHelper
end

class RuboCop::Cop::Style::CaseEquality
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::CaseLikeIf
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::CharacterLiteral
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::ClassAndModuleChildren
  COMPACT_MSG = ::T.let(nil, ::T.untyped)
  NESTED_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::ClassCheck
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::ClassEqualityComparison
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::ClassMethods
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::ClassMethodsDefinitions
  MSG = ::T.let(nil, ::T.untyped)
  MSG_SCLASS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::ClassVars
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::CollectionCompact
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::CollectionMethods
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::ColonMethodCall
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::ColonMethodDefinition
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::CombinableLoops
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::CommandLiteral
  MSG_USE_BACKTICKS = ::T.let(nil, ::T.untyped)
  MSG_USE_PERCENT_X = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::CommentAnnotation
  MISSING_NOTE = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::CommentedKeyword
  ALLOWED_COMMENTS = ::T.let(nil, ::T.untyped)
  ALLOWED_COMMENT_REGEXES = ::T.let(nil, ::T.untyped)
  KEYWORDS = ::T.let(nil, ::T.untyped)
  KEYWORD_REGEXES = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::ConditionalAssignment
  ASSIGNMENT_TYPES = ::T.let(nil, ::T.untyped)
  ASSIGN_TO_CONDITION_MSG = ::T.let(nil, ::T.untyped)
  ENABLED = ::T.let(nil, ::T.untyped)
  INDENTATION_WIDTH = ::T.let(nil, ::T.untyped)
  LINE_LENGTH = ::T.let(nil, ::T.untyped)
  MAX = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  SINGLE_LINE_CONDITIONS_ONLY = ::T.let(nil, ::T.untyped)
  VARIABLE_ASSIGNMENT_TYPES = ::T.let(nil, ::T.untyped)
  WIDTH = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::Style::ConditionalAssignmentHelper
  ALIGN_WITH = ::T.let(nil, ::T.untyped)
  END_ALIGNMENT = ::T.let(nil, ::T.untyped)
  EQUAL = ::T.let(nil, ::T.untyped)
  KEYWORD = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::ConstantVisibility
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::Copyright
  AUTOCORRECT_EMPTY_WARNING = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::DateTime
  CLASS_MSG = ::T.let(nil, ::T.untyped)
  COERCION_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::DefWithParentheses
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::Dir
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::DisableCopsWithinSourceCodeDirective
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::DocumentDynamicEvalDefinition
  BLOCK_COMMENT_REGEXP = ::T.let(nil, ::T.untyped)
  COMMENT_REGEXP = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::Documentation
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::DocumentationMethod
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::DoubleCopDisableDirective
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::DoubleNegation
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::EachForSimpleLoop
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::EachWithObject
  METHODS = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::EmptyBlockParameter
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::EmptyCaseCondition
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::EmptyElse
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::EmptyLambdaParameter
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::EmptyLiteral
  ARR_MSG = ::T.let(nil, ::T.untyped)
  HASH_MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
  STR_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::EmptyMethod
  MSG_COMPACT = ::T.let(nil, ::T.untyped)
  MSG_EXPANDED = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::Encoding
  ENCODING_PATTERN = ::T.let(nil, ::T.untyped)
  MSG_UNNECESSARY = ::T.let(nil, ::T.untyped)
  SHEBANG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::EndBlock
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::EvalWithLocation
  MSG = ::T.let(nil, ::T.untyped)
  MSG_INCORRECT_LINE = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::EvenOdd
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::ExpandPathArguments
  MSG = ::T.let(nil, ::T.untyped)
  PATHNAME_MSG = ::T.let(nil, ::T.untyped)
  PATHNAME_NEW_MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::ExplicitBlockArgument
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::ExponentialNotation
  MESSAGES = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::FloatDivision
  MESSAGES = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::For
  EACH_LENGTH = ::T.let(nil, ::T.untyped)
  PREFER_EACH = ::T.let(nil, ::T.untyped)
  PREFER_FOR = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::FormatString
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::FrozenStringLiteralComment
  MSG_DISABLED = ::T.let(nil, ::T.untyped)
  MSG_MISSING = ::T.let(nil, ::T.untyped)
  MSG_MISSING_TRUE = ::T.let(nil, ::T.untyped)
  MSG_UNNECESSARY = ::T.let(nil, ::T.untyped)
  SHEBANG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::GlobalStdStream
  MSG = ::T.let(nil, ::T.untyped)
  STD_STREAMS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::GlobalVars
  BUILT_IN_VARS = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::GuardClause
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::HashEachMethods
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::HashLikeCase
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::HashSyntax
  MSG_19 = ::T.let(nil, ::T.untyped)
  MSG_HASH_ROCKETS = ::T.let(nil, ::T.untyped)
  MSG_NO_MIXED_KEYS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::IdenticalConditionalBranches
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::IfCorrector
  extend ::RuboCop::Cop::Style::ConditionalAssignmentHelper
  extend ::RuboCop::Cop::Style::ConditionalCorrectorHelper
end

class RuboCop::Cop::Style::IfInsideElse
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::IfUnlessModifier
  MSG_USE_MODIFIER = ::T.let(nil, ::T.untyped)
  MSG_USE_NORMAL = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::IfUnlessModifierOfIfUnless
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::IfWithSemicolon
  MSG_IF_ELSE = ::T.let(nil, ::T.untyped)
  MSG_TERNARY = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::ImplicitRuntimeError
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::InfiniteLoop
  LEADING_SPACE = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::InlineComment
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::InverseMethods
  CAMEL_CASE = ::T.let(nil, ::T.untyped)
  CLASS_COMPARISON_METHODS = ::T.let(nil, ::T.untyped)
  EQUALITY_METHODS = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  NEGATED_EQUALITY_METHODS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::IpAddresses
  IPV6_MAX_SIZE = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::KeywordParametersOrder
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::Lambda
  LITERAL_MESSAGE = ::T.let(nil, ::T.untyped)
  METHOD_MESSAGE = ::T.let(nil, ::T.untyped)
  OFFENDING_SELECTORS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::LambdaCall
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::LineEndConcatenation
  COMPLEX_STRING_BEGIN_TOKEN = ::T.let(nil, ::T.untyped)
  COMPLEX_STRING_END_TOKEN = ::T.let(nil, ::T.untyped)
  CONCAT_TOKEN_TYPES = ::T.let(nil, ::T.untyped)
  HIGH_PRECEDENCE_OP_TOKEN_TYPES = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  QUOTE_DELIMITERS = ::T.let(nil, ::T.untyped)
  SIMPLE_STRING_TOKEN_TYPE = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::Style::MethodCallWithArgsParentheses::OmitParentheses
  TRAILING_WHITESPACE_REGEX = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::MethodCallWithoutArgsParentheses
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::MethodCalledOnDoEndBlock
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::MethodDefParentheses
  MSG_MISSING = ::T.let(nil, ::T.untyped)
  MSG_PRESENT = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::MinMax
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::MissingElse
  MSG = ::T.let(nil, ::T.untyped)
  MSG_EMPTY = ::T.let(nil, ::T.untyped)
  MSG_NIL = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::MissingRespondToMissing
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::MixinGrouping
  MIXIN_METHODS = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::MixinUsage
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::ModuleFunction
  EXTEND_SELF_MSG = ::T.let(nil, ::T.untyped)
  FORBIDDEN_MSG = ::T.let(nil, ::T.untyped)
  MODULE_FUNCTION_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::MultilineBlockChain
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::MultilineIfModifier
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::MultilineIfThen
  MSG = ::T.let(nil, ::T.untyped)
  NON_MODIFIER_THEN = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::MultilineMemoization
  BRACES_MSG = ::T.let(nil, ::T.untyped)
  KEYWORD_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::MultilineMethodSignature
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::MultilineTernaryOperator
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::MultilineWhenThen
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::MultipleComparison
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::MutableConstant
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::NegatedIfElseCondition
  MSG = ::T.let(nil, ::T.untyped)
  NEGATED_EQUALITY_METHODS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::NestedModifier
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::NestedParenthesizedCalls
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::NestedTernaryOperator
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::Next
  EXIT_TYPES = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::NilComparison
  EXPLICIT_MSG = ::T.let(nil, ::T.untyped)
  PREDICATE_MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::NilLambda
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::NonNilCheck
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::Not
  MSG = ::T.let(nil, ::T.untyped)
  OPPOSITE_METHODS = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::NumericLiteralPrefix
  BINARY_MSG = ::T.let(nil, ::T.untyped)
  BINARY_REGEX = ::T.let(nil, ::T.untyped)
  DECIMAL_MSG = ::T.let(nil, ::T.untyped)
  DECIMAL_REGEX = ::T.let(nil, ::T.untyped)
  HEX_MSG = ::T.let(nil, ::T.untyped)
  HEX_REGEX = ::T.let(nil, ::T.untyped)
  OCTAL_MSG = ::T.let(nil, ::T.untyped)
  OCTAL_REGEX = ::T.let(nil, ::T.untyped)
  OCTAL_ZERO_ONLY_MSG = ::T.let(nil, ::T.untyped)
  OCTAL_ZERO_ONLY_REGEX = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::NumericLiterals
  DELIMITER_REGEXP = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::NumericPredicate
  MSG = ::T.let(nil, ::T.untyped)
  REPLACEMENTS = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::OneLineConditional
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::OptionHash
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::OptionalArguments
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::OptionalBooleanParameter
  BOOLEAN_TYPES = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::OrAssignment
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::ParallelAssignment
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::PercentQLiterals
  LOWER_CASE_Q_MSG = ::T.let(nil, ::T.untyped)
  UPPER_CASE_Q_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::PerlBackrefs
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::PreferredHashMethods
  MSG = ::T.let(nil, ::T.untyped)
  OFFENDING_SELECTORS = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::Proc
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RaiseArgs
  COMPACT_MSG = ::T.let(nil, ::T.untyped)
  EXPLODED_MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RandomWithOffset
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RedundantArgument
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RedundantAssignment
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RedundantBegin
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RedundantCapitalW
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RedundantCondition
  MSG = ::T.let(nil, ::T.untyped)
  REDUNDANT_CONDITION = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RedundantConditional
  COMPARISON_OPERATOR_MATCHER = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RedundantException
  MSG_1 = ::T.let(nil, ::T.untyped)
  MSG_2 = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RedundantFetchBlock
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RedundantFileExtensionInRequire
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RedundantFreeze
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RedundantInterpolation
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RedundantPercentQ
  DYNAMIC_MSG = ::T.let(nil, ::T.untyped)
  EMPTY = ::T.let(nil, ::T.untyped)
  ESCAPED_NON_BACKSLASH = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  PERCENT_CAPITAL_Q = ::T.let(nil, ::T.untyped)
  PERCENT_Q = ::T.let(nil, ::T.untyped)
  QUOTE = ::T.let(nil, ::T.untyped)
  SINGLE_QUOTE = ::T.let(nil, ::T.untyped)
  STRING_INTERPOLATION_REGEXP = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RedundantRegexpCharacterClass
  MSG_REDUNDANT_CHARACTER_CLASS = ::T.let(nil, ::T.untyped)
  REQUIRES_ESCAPE_OUTSIDE_CHAR_CLASS_CHARS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RedundantRegexpEscape
  ALLOWED_ALWAYS_ESCAPES = ::T.let(nil, ::T.untyped)
  ALLOWED_OUTSIDE_CHAR_CLASS_METACHAR_ESCAPES = ::T.let(nil, ::T.untyped)
  ALLOWED_WITHIN_CHAR_CLASS_METACHAR_ESCAPES = ::T.let(nil, ::T.untyped)
  MSG_REDUNDANT_ESCAPE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RedundantReturn
  MSG = ::T.let(nil, ::T.untyped)
  MULTI_RETURN_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RedundantSelf
  KERNEL_METHODS = ::T.let(nil, ::T.untyped)
  KEYWORDS = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RedundantSelfAssignment
  ASSIGNMENT_TYPE_TO_RECEIVER_TYPE = ::T.let(nil, ::T.untyped)
  METHODS_RETURNING_SELF = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RedundantSort
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RedundantSortBy
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RegexpLiteral
  MSG_USE_PERCENT_R = ::T.let(nil, ::T.untyped)
  MSG_USE_SLASHES = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RescueModifier
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RescueStandardError
  MSG_EXPLICIT = ::T.let(nil, ::T.untyped)
  MSG_IMPLICIT = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::ReturnNil
  RETURN_MSG = ::T.let(nil, ::T.untyped)
  RETURN_NIL_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::SafeNavigation
  LOGIC_JUMP_KEYWORDS = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::Sample
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::SelfAssignment
  MSG = ::T.let(nil, ::T.untyped)
  OPS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::Semicolon
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::Send
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::SignalException
  FAIL_MSG = ::T.let(nil, ::T.untyped)
  RAISE_MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::SingleArgumentDig
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::SingleLineBlockParams
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::SingleLineMethods
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::SlicingWithRange
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::SoleNestedConditional
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::SpecialGlobalVars
  ENGLISH_VARS = ::T.let(nil, ::T.untyped)
  MSG_BOTH = ::T.let(nil, ::T.untyped)
  MSG_ENGLISH = ::T.let(nil, ::T.untyped)
  MSG_REGULAR = ::T.let(nil, ::T.untyped)
  NON_ENGLISH_VARS = ::T.let(nil, ::T.untyped)
  PERL_VARS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::StabbyLambdaParentheses
  MSG_NO_REQUIRE = ::T.let(nil, ::T.untyped)
  MSG_REQUIRE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::StaticClass
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::StderrPuts
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::StringConcatenation
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::StringHashKeys
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::StringLiterals
  MSG_INCONSISTENT = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::StringMethods
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::Strip
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::StructInheritance
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::SwapValues
  MSG = ::T.let(nil, ::T.untyped)
  SIMPLE_ASSIGNMENT_TYPES = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::SymbolArray
  ARRAY_MSG = ::T.let(nil, ::T.untyped)
  PERCENT_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::SymbolLiteral
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::SymbolProc
  MSG = ::T.let(nil, ::T.untyped)
  SUPER_TYPES = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::TernaryCorrector
  extend ::RuboCop::Cop::Style::ConditionalAssignmentHelper
  extend ::RuboCop::Cop::Style::ConditionalCorrectorHelper
end

class RuboCop::Cop::Style::TernaryParentheses
  MSG = ::T.let(nil, ::T.untyped)
  MSG_COMPLEX = ::T.let(nil, ::T.untyped)
  NON_COMPLEX_TYPES = ::T.let(nil, ::T.untyped)
  VARIABLE_TYPES = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::TrailingBodyOnClass
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::TrailingBodyOnMethodDefinition
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::TrailingBodyOnModule
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::TrailingCommaInBlockArgs
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::TrailingMethodEndStatement
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::TrailingUnderscoreVariable
  MSG = ::T.let(nil, ::T.untyped)
  UNDERSCORE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::TrivialAccessors
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::UnlessElse
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::UnpackFirst
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::VariableInterpolation
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::WhenThen
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::WhileUntilDo
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::WhileUntilModifier
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::WordArray
  ARRAY_MSG = ::T.let(nil, ::T.untyped)
  PERCENT_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::YodaCondition
  EQUALITY_OPERATORS = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  NONCOMMUTATIVE_OPERATORS = ::T.let(nil, ::T.untyped)
  PROGRAM_NAMES = ::T.let(nil, ::T.untyped)
  REVERSE_COMPARISON = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::ZeroLengthPredicate
  NONZERO_MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
  ZERO_MSG = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::SurroundingSpace
  NO_SPACE_COMMAND = ::T.let(nil, ::T.untyped)
  SINGLE_SPACE_REGEXP = ::T.let(nil, ::T.untyped)
  SPACE_COMMAND = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::TrailingComma
  MSG = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::UncommunicativeName
  CASE_MSG = ::T.let(nil, ::T.untyped)
  FORBIDDEN_MSG = ::T.let(nil, ::T.untyped)
  LENGTH_MSG = ::T.let(nil, ::T.untyped)
  NUM_MSG = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::Util
  LITERAL_REGEX = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Utils::FormatString
  DIGIT_DOLLAR = ::T.let(nil, ::T.untyped)
  FLAG = ::T.let(nil, ::T.untyped)
  NAME = ::T.let(nil, ::T.untyped)
  NUMBER = ::T.let(nil, ::T.untyped)
  NUMBER_ARG = ::T.let(nil, ::T.untyped)
  PRECISION = ::T.let(nil, ::T.untyped)
  SEQUENCE = ::T.let(nil, ::T.untyped)
  TEMPLATE_NAME = ::T.let(nil, ::T.untyped)
  TYPE = ::T.let(nil, ::T.untyped)
  WIDTH = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::VariableForce
  ARGUMENT_DECLARATION_TYPES = ::T.let(nil, ::T.untyped)
  LOGICAL_OPERATOR_ASSIGNMENT_TYPES = ::T.let(nil, ::T.untyped)
  LOOP_TYPES = ::T.let(nil, ::T.untyped)
  MULTIPLE_ASSIGNMENT_TYPE = ::T.let(nil, ::T.untyped)
  OPERATOR_ASSIGNMENT_TYPES = ::T.let(nil, ::T.untyped)
  POST_CONDITION_LOOP_TYPES = ::T.let(nil, ::T.untyped)
  REGEXP_NAMED_CAPTURE_TYPE = ::T.let(nil, ::T.untyped)
  RESCUE_TYPE = ::T.let(nil, ::T.untyped)
  SCOPE_TYPES = ::T.let(nil, ::T.untyped)
  SEND_TYPE = ::T.let(nil, ::T.untyped)
  TWISTED_SCOPE_TYPES = ::T.let(nil, ::T.untyped)
  VARIABLE_ASSIGNMENT_TYPE = ::T.let(nil, ::T.untyped)
  VARIABLE_ASSIGNMENT_TYPES = ::T.let(nil, ::T.untyped)
  VARIABLE_REFERENCE_TYPE = ::T.let(nil, ::T.untyped)
  ZERO_ARITY_SUPER_TYPE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::VariableForce::Assignment
  MULTIPLE_LEFT_HAND_SIDE_TYPE = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::VariableForce::Branch
  CLASSES_BY_TYPE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::VariableForce::Reference
  VARIABLE_REFERENCE_TYPES = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::VariableForce::Scope
  OUTER_SCOPE_CHILD_INDICES = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::VariableForce::Variable
  VARIABLE_DECLARATION_TYPES = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::VisibilityHelp
  VISIBILITY_SCOPES = ::T.let(nil, ::T.untyped)
end

class RuboCop::Formatter::ClangStyleFormatter
  ELLIPSES = ::T.let(nil, ::T.untyped)
end

class RuboCop::Formatter::DisabledConfigFormatter
  HEADING = ::T.let(nil, ::T.untyped)
end

class RuboCop::Formatter::FormatterSet
  BUILTIN_FORMATTERS_FOR_KEYS = ::T.let(nil, ::T.untyped)
  FORMATTER_APIS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Formatter::FuubarStyleFormatter
  RESET_SEQUENCE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Formatter::GitHubActionsFormatter
  ESCAPE_MAP = ::T.let(nil, ::T.untyped)
end

class RuboCop::Formatter::HTMLFormatter
  ELLIPSES = ::T.let(nil, ::T.untyped)
  TEMPLATE_PATH = ::T.let(nil, ::T.untyped)
end

class RuboCop::Formatter::HTMLFormatter::ERBContext
  LOGO_IMAGE_PATH = ::T.let(nil, ::T.untyped)
  SEVERITY_COLORS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Formatter::PacmanFormatter
  FALLBACK_TERMINAL_WIDTH = ::T.let(nil, ::T.untyped)
  GHOST = ::T.let(nil, ::T.untyped)
  PACDOT = ::T.let(nil, ::T.untyped)
  PACMAN = ::T.let(nil, ::T.untyped)
end

class RuboCop::Formatter::ProgressFormatter
  DOT = ::T.let(nil, ::T.untyped)
end

class RuboCop::Formatter::SimpleTextFormatter
  COLOR_FOR_SEVERITY = ::T.let(nil, ::T.untyped)
end

class RuboCop::MagicComment
  TOKEN = ::T.let(nil, ::T.untyped)
end

class RuboCop::MagicComment::EmacsComment
  FORMAT = ::T.let(nil, ::T.untyped)
  OPERATOR = ::T.let(nil, ::T.untyped)
  SEPARATOR = ::T.let(nil, ::T.untyped)
end

class RuboCop::MagicComment::VimComment
  FORMAT = ::T.let(nil, ::T.untyped)
  OPERATOR = ::T.let(nil, ::T.untyped)
  SEPARATOR = ::T.let(nil, ::T.untyped)
end

class RuboCop::AST::NodePattern
end

RuboCop::NodePattern::Builder = RuboCop::AST::NodePattern::Builder

class RuboCop::AST::NodePattern::Compiler
end

RuboCop::NodePattern::Compiler::Debug = RuboCop::AST::NodePattern::Compiler::Debug

class RuboCop::AST::NodePattern::Compiler
end

class RuboCop::AST::NodePattern::Lexer
end

RuboCop::NodePattern::Lexer::Error = RuboCop::AST::NodePattern::LexerRex::ScanError

class RuboCop::AST::NodePattern::Lexer
end

class RuboCop::AST::NodePattern
end

class RuboCop::Options
  DEFAULT_MAXIMUM_EXCLUSION_ITEMS = ::T.let(nil, ::T.untyped)
  EXITING_OPTIONS = ::T.let(nil, ::T.untyped)
  E_STDIN_NO_PATH = ::T.let(nil, ::T.untyped)
end

module RuboCop::OptionsHelp
  FORMATTER_OPTION_LIST = ::T.let(nil, ::T.untyped)
  MAX_EXCL = ::T.let(nil, ::T.untyped)
  TEXT = ::T.let(nil, ::T.untyped)
end

RuboCop::ProcessedSource = RuboCop::AST::ProcessedSource

class RuboCop::RemoteConfig
  CACHE_LIFETIME = ::T.let(nil, ::T.untyped)
end

class RuboCop::ResultCache
  NON_CHANGING = ::T.let(nil, ::T.untyped)
end

class RuboCop::Runner
  MAX_ITERATIONS = ::T.let(nil, ::T.untyped)
end

class RuboCop::TargetFinder
  HIDDEN_PATH_SUBSTRING = ::T.let(nil, ::T.untyped)
end

class RuboCop::TargetRuby
  DEFAULT_VERSION = ::T.let(nil, ::T.untyped)
end

class RuboCop::TargetRuby::GemspecFile
  GEMSPEC_EXTENSION = ::T.let(nil, ::T.untyped)
end

class RuboCop::TargetRuby::RubyVersionFile
  FILENAME = ::T.let(nil, ::T.untyped)
end

RuboCop::Token = RuboCop::AST::Token

module RuboCop::Version
  CANONICAL_FEATURE_NAMES = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  STRING = ::T.let(nil, ::T.untyped)
end

class RubyVM::AbstractSyntaxTree::Node
  def pretty_print_children(q, names=T.unsafe(nil)); end
end

module RubyVM::MJIT
end

module RubyVM::MJIT
  def self.enabled?(); end

  def self.pause(*_); end

  def self.resume(); end
end

ScanError = StringScanner::Error

class Set
  def ==(other); end

  def ===(o); end

  def compare_by_identity(); end

  def compare_by_identity?(); end

  def divide(&func); end

  def eql?(o); end

  def flatten_merge(set, seen=T.unsafe(nil)); end

  def pretty_print(pp); end

  def pretty_print_cycle(pp); end

  def reset(); end
  InspectKey = ::T.let(nil, ::T.untyped)
end

class SimpleDelegator
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

module Sinatra
  VERSION = ::T.let(nil, ::T.untyped)
end

class Sinatra::Base
  URI_INSTANCE = ::T.let(nil, ::T.untyped)
end

module Sinatra::Helpers
  ETAG_KINDS = ::T.let(nil, ::T.untyped)
end

class Sinatra::Request
  HEADER_PARAM = ::T.let(nil, ::T.untyped)
  HEADER_VALUE_WITH_PARAMS = ::T.let(nil, ::T.untyped)
end

class Sinatra::Response
  DROP_BODY_RESPONSES = ::T.let(nil, ::T.untyped)
end

class Sinatra::ShowExceptions
  TEMPLATE = ::T.let(nil, ::T.untyped)
end

class Socket
  IPV6_DONTFRAG = ::T.let(nil, ::T.untyped)
  IPV6_PATHMTU = ::T.let(nil, ::T.untyped)
  IPV6_RECVPATHMTU = ::T.let(nil, ::T.untyped)
  SO_BPF_EXTENSIONS = ::T.let(nil, ::T.untyped)
end

module Socket::Constants
  IPV6_DONTFRAG = ::T.let(nil, ::T.untyped)
  IPV6_PATHMTU = ::T.let(nil, ::T.untyped)
  IPV6_RECVPATHMTU = ::T.let(nil, ::T.untyped)
  SO_BPF_EXTENSIONS = ::T.let(nil, ::T.untyped)
end

module Solargraph
  VERSION = ::T.let(nil, ::T.untyped)
  YARDOC_PATH = ::T.let(nil, ::T.untyped)
  YARD_EXTENSION_FILE = ::T.let(nil, ::T.untyped)
end

class Solargraph::ApiMap
  include ::Solargraph::NodeMethods
  include ::Solargraph::YardMethods
  def append_source(code, filename); end

  def find_fully_qualified_namespace(name, root=T.unsafe(nil), skip=T.unsafe(nil)); end

  def get_class_variable_pins(namespace); end

  def get_class_variables(namespace); end

  def get_comment_for(node); end

  def get_constant_pins(namespace, root); end

  def get_constants(namespace, root); end

  def get_filename_for(node); end

  def get_global_variables(); end

  def get_include_strings_from(*nodes); end

  def get_instance_methods(namespace, root=T.unsafe(nil), visibility: T.unsafe(nil)); end

  def get_instance_variable_pins(namespace, scope=T.unsafe(nil)); end

  def get_instance_variables(namespace, scope=T.unsafe(nil)); end

  def get_methods(namespace, root=T.unsafe(nil), visibility: T.unsafe(nil)); end

  def get_namespace_nodes(fqns); end

  def get_namespace_type(namespace, root=T.unsafe(nil)); end

  def get_path_suggestions(path); end

  def get_symbols(); end

  def infer_assignment_node_type(node, namespace); end

  def infer_class_variable(var, namespace); end

  def infer_instance_variable(var, namespace, scope); end

  def infer_signature_type(signature, namespace, scope: T.unsafe(nil)); end

  def initialize(workspace=T.unsafe(nil)); end

  def namespace_exists?(name, root=T.unsafe(nil)); end

  def namespaces(); end

  def namespaces_in(name, root=T.unsafe(nil)); end

  def refresh(force=T.unsafe(nil)); end

  def required(); end

  def sources(); end

  def update(filename); end

  def virtualize(filename, code, cursor=T.unsafe(nil)); end

  def workspace(); end

  def yard_map(); end
  KEYWORDS = ::T.let(nil, ::T.untyped)
  METHODS_RETURNING_SELF = ::T.let(nil, ::T.untyped)
end

class Solargraph::ApiMap::Cache
  def clear(); end

  def get_assignment_node_type(node, namespace); end

  def get_signature_type(signature, namespace, scope); end

  def has_signature_type?(signature, namespace, scope); end

  def set_assignment_node_type(node, namespace, value); end

  def set_signature_type(signature, namespace, scope, value); end
end

class Solargraph::ApiMap::Cache
end

class Solargraph::ApiMap::Config
  def excluded(); end

  def included(); end

  def initialize(workspace=T.unsafe(nil)); end

  def workspace(); end
end

class Solargraph::ApiMap::Config
end

class Solargraph::ApiMap::Source
  include ::Solargraph::NodeMethods
  def attribute_pins(); end

  def class_variable_pins(); end

  def code(); end

  def code_for(node); end

  def comments(); end

  def constant_pins(); end

  def docstring_for(node); end

  def filename(); end

  def global_variable_pins(); end

  def include?(node); end

  def initialize(code, node, comments, filename); end

  def instance_variable_pins(); end

  def local_variable_pins(); end

  def method_pins(); end

  def namespace_includes(); end

  def namespace_nodes(); end

  def namespaces(); end

  def node(); end

  def required(); end

  def superclasses(); end

  def symbol_pins(); end

  def tree_for(node); end
end

class Solargraph::ApiMap::Source
  def self.beginning_of_line_from(str, i); end

  def self.fix(filename, code, cursor=T.unsafe(nil)); end

  def self.load(filename); end

  def self.virtual(filename, code); end
end

class Solargraph::ApiMap
  def self.get_keywords(); end
end

class Solargraph::CodeMap
  include ::Solargraph::NodeMethods
  def api_map(); end

  def code(); end

  def comment_at?(index); end

  def filename(); end

  def get_class_variables_at(index); end

  def get_instance_variables_at(index); end

  def get_local_variables_and_methods_at(index); end

  def get_offset(line, col); end

  def get_signature_at(index); end

  def get_signature_index_at(index); end

  def get_snippets_at(index); end

  def get_type_comment(node); end

  def infer_signature_at(index); end

  def infer_signature_from_node(signature, node); end

  def initialize(code: T.unsafe(nil), filename: T.unsafe(nil), workspace: T.unsafe(nil), api_map: T.unsafe(nil), cursor: T.unsafe(nil)); end

  def local_variable_in_node?(name, node); end

  def namespace_at(index); end

  def namespace_from(node); end

  def node(); end

  def node_at(index); end

  def parent_node_from(index, *types); end

  def resolve_object_at(index); end

  def signatures_at(index); end

  def string_at?(index); end

  def suggest_at(index, filtered: T.unsafe(nil), with_snippets: T.unsafe(nil)); end

  def tree_at(index); end

  def word_at(index); end

  def workspace(); end
end

class Solargraph::CodeMap
  def self.get_offset(text, line, col); end
end

module Solargraph::NodeMethods
  def const_from(node); end

  def infer_literal_node_type(node); end

  def pack_name(node); end

  def resolve_node_signature(node); end

  def unpack_name(node); end
end

module Solargraph::NodeMethods
end

module Solargraph::Pin
end

class Solargraph::Pin::Attribute
  def access(); end

  def initialize(source, node, namespace, access, docstring); end
end

class Solargraph::Pin::Attribute
end

class Solargraph::Pin::Base
  def docstring(); end

  def filename(); end

  def initialize(source, node, namespace); end

  def kind(); end

  def name(); end

  def namespace(); end

  def node(); end

  def parameters(); end

  def path(); end

  def return_type(); end

  def signature(); end

  def source(); end

  def value(); end
end

class Solargraph::Pin::Base
end

class Solargraph::Pin::BaseVariable
  include ::Solargraph::NodeMethods
end

class Solargraph::Pin::BaseVariable
end

class Solargraph::Pin::ClassVariable
end

class Solargraph::Pin::ClassVariable
end

class Solargraph::Pin::Constant
end

class Solargraph::Pin::Constant
end

class Solargraph::Pin::GlobalVariable
end

class Solargraph::Pin::GlobalVariable
end

class Solargraph::Pin::InstanceVariable
  def initialize(source, node, namespace, scope); end

  def scope(); end
end

class Solargraph::Pin::InstanceVariable
end

class Solargraph::Pin::LocalVariable
  def initialize(source, node, namespace, ancestors); end

  def visible_from?(node); end
end

class Solargraph::Pin::LocalVariable
end

class Solargraph::Pin::Method
  def initialize(source, node, namespace, scope, visibility); end

  def scope(); end

  def visibility(); end
end

class Solargraph::Pin::Method
end

class Solargraph::Pin::Symbol
end

class Solargraph::Pin::Symbol
end

module Solargraph::Pin
end

class Solargraph::Server
  def htmlify(text); end

  def rdoc_to_html(text); end

  def ruby_to_html(code); end
end

class Solargraph::Server::Helpers
  include ::YARD::Templates::Helpers::HtmlHelper
  include ::YARD::Templates::Helpers::MarkupHelper
  include ::YARD::Templates::Helpers::HtmlSyntaxHighlightHelper
  include ::YARD::Templates::Helpers::ModuleHelper
  def linkify(*args); end

  def object(); end

  def object=(object); end

  def options(); end

  def serializer(); end

  def serializer=(serializer); end

  def url_for(object); end
end

class Solargraph::Server::Helpers
end

class Solargraph::Server
  def self.prepare_workspace(directory); end

  def self.wait(); end
end

class Solargraph::Shell
  def config(directory=T.unsafe(nil)); end

  def prepare(); end

  def server(); end

  def suggest(*filenames); end

  def version(); end
end

class Solargraph::Shell
end

module Solargraph::Snippets
end

module Solargraph::Snippets
  def self.definitions(); end

  def self.keywords(); end
end

class Solargraph::Suggestion
  def arguments(); end

  def code_object(); end

  def detail(); end

  def docstring(); end

  def documentation(); end

  def initialize(label, kind: T.unsafe(nil), insert: T.unsafe(nil), detail: T.unsafe(nil), docstring: T.unsafe(nil), code_object: T.unsafe(nil), location: T.unsafe(nil), arguments: T.unsafe(nil), return_type: T.unsafe(nil), path: T.unsafe(nil)); end

  def insert(); end

  def kind(); end

  def label(); end

  def location(); end

  def params(); end

  def path(); end

  def return_type(); end

  def to_json(args=T.unsafe(nil)); end
  CLASS = ::T.let(nil, ::T.untyped)
  CONSTANT = ::T.let(nil, ::T.untyped)
  FIELD = ::T.let(nil, ::T.untyped)
  KEYWORD = ::T.let(nil, ::T.untyped)
  METHOD = ::T.let(nil, ::T.untyped)
  MODULE = ::T.let(nil, ::T.untyped)
  PROPERTY = ::T.let(nil, ::T.untyped)
  SNIPPET = ::T.let(nil, ::T.untyped)
  VARIABLE = ::T.let(nil, ::T.untyped)
end

class Solargraph::Suggestion
  def self.pull(pin, return_type=T.unsafe(nil)); end
end

class Solargraph::YardMap
  def bundled_gem_yardocs(); end

  def document(query); end

  def find_fully_qualified_namespace(namespace, scope); end

  def gem_names(); end

  def get_constants(namespace, scope=T.unsafe(nil)); end

  def get_instance_methods(namespace, scope=T.unsafe(nil), visibility: T.unsafe(nil)); end

  def get_methods(namespace, scope=T.unsafe(nil), visibility: T.unsafe(nil)); end

  def initialize(required: T.unsafe(nil), workspace: T.unsafe(nil)); end

  def load_yardoc(y); end

  def objects(path, space=T.unsafe(nil)); end

  def required(); end

  def search(query); end

  def workspace(); end

  def yardocs(); end
end

class Solargraph::YardMap::Cache
  def get_constants(namespace, scope); end

  def get_instance_methods(namespace, scope, visibility); end

  def get_methods(namespace, scope, visibility); end

  def set_constants(namespace, scope, suggestions); end

  def set_instance_methods(namespace, scope, visibility, suggestions); end

  def set_methods(namespace, scope, visibility, suggestions); end
end

class Solargraph::YardMap::Cache
end

class Solargraph::YardMap
end

module Solargraph::YardMethods
  def yard_files(); end

  def yard_options(); end
end

module Solargraph::YardMethods
end

class SortedSet
  def initialize(*args, &block); end
end

class SortedSet
  def self.setup(); end
end

class String
  include ::JSON::Ext::Generator::GeneratorMethods::String
  def parse_csv(**options); end

  def shellescape(); end

  def shellsplit(); end
end

class StringIO
  def set_encoding_by_bom(); end
  VERSION = ::T.let(nil, ::T.untyped)
end

class StringScanner
  def bol?(); end

  def fixed_anchor?(); end

  def initialize(*_); end
  Id = ::T.let(nil, ::T.untyped)
  Version = ::T.let(nil, ::T.untyped)
end

class Struct
  def deconstruct(); end

  def deconstruct_keys(_); end

  def filter(*_); end
end

Struct::Group = Etc::Group

Struct::Passwd = Etc::Passwd

Struct::Tms = Process::Tms

class Tempfile
  def _close(); end

  def inspect(); end
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

class Tempfile::Remover
  def call(*args); end

  def initialize(tmpfile); end
end

class Tempfile::Remover
end

class Thor
  def help(command=T.unsafe(nil), subcommand=T.unsafe(nil)); end
  HELP_MAPPINGS = ::T.let(nil, ::T.untyped)
  TEMPLATE_EXTNAME = ::T.let(nil, ::T.untyped)
  THOR_RESERVED_WORDS = ::T.let(nil, ::T.untyped)
end

Thor::AmbiguousTaskError = Thor::AmbiguousCommandError

class Thor::Argument
  VALID_TYPES = ::T.let(nil, ::T.untyped)
end

class Thor::Arguments
  NUMERIC = ::T.let(nil, ::T.untyped)
end

class Thor::Command
  FILE_REGEXP = ::T.let(nil, ::T.untyped)
end

Thor::Correctable = DidYouMean::Correctable

Thor::DynamicTask = Thor::DynamicCommand

class Thor::Group
  def _invoke_for_class_method(klass, command=T.unsafe(nil), *args, &block); end
end

Thor::HiddenTask = Thor::HiddenCommand

class Thor::Option
  VALID_TYPES = ::T.let(nil, ::T.untyped)
end

class Thor::Options
  EQ_RE = ::T.let(nil, ::T.untyped)
  LONG_RE = ::T.let(nil, ::T.untyped)
  OPTS_END = ::T.let(nil, ::T.untyped)
  SHORT_NUM = ::T.let(nil, ::T.untyped)
  SHORT_RE = ::T.let(nil, ::T.untyped)
  SHORT_SQ_RE = ::T.let(nil, ::T.untyped)
end

module Thor::Shell
  SHELL_DELEGATED_METHODS = ::T.let(nil, ::T.untyped)
end

Thor::Task = Thor::Command

class Thor::UndefinedCommandError
  include ::DidYouMean::Correctable
end

Thor::UndefinedTaskError = Thor::UndefinedCommandError

class Thor::UnknownArgumentError
  include ::DidYouMean::Correctable
end

module Tilt
  LOCK = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class Tilt::CSVTemplate
  def precompiled(locals); end

  def precompiled_template(locals); end
end

class Tilt::CSVTemplate
  def self.engine(); end
end

class Tilt::ERBTemplate
  def precompiled(locals); end

  def precompiled_postamble(locals); end

  def precompiled_preamble(locals); end

  def precompiled_template(locals); end
  SUPPORTS_KVARGS = ::T.let(nil, ::T.untyped)
end

class Tilt::ERBTemplate
  def self.default_output_variable(); end

  def self.default_output_variable=(name); end
end

class Tilt::EtanniTemplate
  def precompiled(locals); end

  def precompiled_template(locals); end
end

class Tilt::EtanniTemplate
end

class Tilt::Mapping
  AUTOLOAD_IS_BROKEN = ::T.let(nil, ::T.untyped)
  LOCK = ::T.let(nil, ::T.untyped)
end

class Tilt::PlainTemplate
end

class Tilt::PlainTemplate
end

class Tilt::RDocTemplate
  def allows_script?(); end

  def markup(); end
end

class Tilt::RDocTemplate
end

class Tilt::SigilTemplate
  def allows_script?(); end
end

class Tilt::SigilTemplate
end

class Tilt::StringTemplate
  def precompiled(locals); end

  def precompiled_template(locals); end
end

class Tilt::StringTemplate
end

Tilt::TOPOBJECT = Tilt::CompiledTemplates

class TracePoint
  def eval_script(); end

  def instruction_sequence(); end

  def parameters(); end
end

class TracePoint
  def self.new(*events); end
end

class TrueClass
  include ::JSON::Ext::Generator::GeneratorMethods::TrueClass
end

module URI
  include ::URI::RFC2396_REGEXP
end

class URI::FTP
  def buffer_open(buf, proxy, options); end
end

class URI::FTP
  def self.new2(user, password, host, port, path, typecode=T.unsafe(nil), arg_check=T.unsafe(nil)); end
end

class URI::File
  def check_password(user); end

  def check_user(user); end

  def check_userinfo(user); end

  def set_userinfo(v); end
  COMPONENT = ::T.let(nil, ::T.untyped)
  DEFAULT_PORT = ::T.let(nil, ::T.untyped)
end

class URI::File
end

class URI::HTTP
  def buffer_open(buf, proxy, options); end
end

class URI::LDAP
  def attributes(); end

  def attributes=(val); end

  def dn(); end

  def dn=(val); end

  def extensions(); end

  def extensions=(val); end

  def filter(); end

  def filter=(val); end

  def initialize(*arg); end

  def scope(); end

  def scope=(val); end

  def set_attributes(val); end

  def set_dn(val); end

  def set_extensions(val); end

  def set_filter(val); end

  def set_scope(val); end
end

class URI::MailTo
  def initialize(*arg); end
end

URI::Parser = URI::RFC2396_Parser

URI::REGEXP = URI::RFC2396_REGEXP

class URI::RFC2396_Parser
  def initialize(opts=T.unsafe(nil)); end
end

class URI::RFC3986_Parser
  def join(*uris); end

  def parse(uri); end

  def regexp(); end

  def split(uri); end
  RFC3986_relative_ref = ::T.let(nil, ::T.untyped)
end

module URI::Util
  def self.make_components_hash(klass, array_hash); end
end

module URI
  extend ::URI::Escape
  def self.get_encoding(label); end

  def self.open(name, *rest, &block); end
end

class UnboundMethod
  def bind_call(*_); end
end

module Unicode::DisplayWidth
  DATA_DIRECTORY = ::T.let(nil, ::T.untyped)
  DEPTHS = ::T.let(nil, ::T.untyped)
  INDEX = ::T.let(nil, ::T.untyped)
  INDEX_FILENAME = ::T.let(nil, ::T.untyped)
  NO_STRING_EXT = ::T.let(nil, ::T.untyped)
  UNICODE_VERSION = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

module UnicodeNormalize
end

module UnicodeNormalize
end

module Warning
  extend ::Warning
  def self.[](_); end

  def self.[]=(_, _1); end
end

module YARD
  CONFIG_DIR = ::T.let(nil, ::T.untyped)
  ROOT = ::T.let(nil, ::T.untyped)
  TEMPLATE_ROOT = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class YARD::CLI::CommandParser
  def run(*args); end
end

class YARD::CLI::CommandParser
  def self.commands(); end

  def self.commands=(commands); end

  def self.default_command(); end

  def self.default_command=(default_command); end

  def self.run(*args); end
end

class YARD::CLI::Config
  def append(); end

  def append=(append); end

  def as_list(); end

  def as_list=(as_list); end

  def gem_install_cmd(); end

  def gem_install_cmd=(gem_install_cmd); end

  def key(); end

  def key=(key); end

  def reset(); end

  def reset=(reset); end

  def run(*args); end

  def values(); end

  def values=(values); end
end

class YARD::CLI::Config
end

class YARD::CLI::Diff
  def run(*args); end
end

class YARD::CLI::Diff
end

class YARD::CLI::Display
  def format_objects(); end

  def initialize(*args); end

  def wrap_layout(contents); end
end

class YARD::CLI::Display
end

class YARD::CLI::Gems
  def run(*args); end
end

class YARD::CLI::Gems
end

class YARD::CLI::Graph
  def objects(); end

  def options(); end

  def run(*args); end
end

class YARD::CLI::Graph
end

class YARD::CLI::Help
  def run(*args); end
end

class YARD::CLI::Help
end

class YARD::CLI::I18n
end

class YARD::CLI::I18n
end

class YARD::CLI::List
  def run(*args); end
end

class YARD::CLI::List
end

class YARD::CLI::MarkupTypes
  def run(*args); end
end

class YARD::CLI::MarkupTypes
end

class YARD::CLI::Server
  def adapter(); end

  def adapter=(adapter); end

  def libraries(); end

  def libraries=(libraries); end

  def options(); end

  def options=(options); end

  def run(*args); end

  def scripts(); end

  def scripts=(scripts); end

  def server_options(); end

  def server_options=(server_options); end

  def template_paths(); end

  def template_paths=(template_paths); end
end

class YARD::CLI::Server
end

class YARD::CLI::Stats
  include ::YARD::Templates::Helpers::BaseHelper
  def initialize(parse=T.unsafe(nil)); end

  def output(name, data, undoc=T.unsafe(nil)); end

  def parse(); end

  def parse=(parse); end

  def print_statistics(); end

  def print_undocumented_objects(); end

  def stats_for_attributes(); end

  def stats_for_classes(); end

  def stats_for_constants(); end

  def stats_for_files(); end

  def stats_for_methods(); end

  def stats_for_modules(); end
  STATS_ORDER = ::T.let(nil, ::T.untyped)
end

class YARD::CLI::Stats
end

class YARD::CLI::YRI
  def cache_object(name, path); end

  def find_object(name); end

  def print_object(object); end

  def print_usage(); end

  def run(*args); end
  CACHE_FILE = ::T.let(nil, ::T.untyped)
  DEFAULT_SEARCH_PATHS = ::T.let(nil, ::T.untyped)
  SEARCH_PATHS_FILE = ::T.let(nil, ::T.untyped)
end

class YARD::CLI::YRI
end

class YARD::CLI::YardoptsCommand
  DEFAULT_YARDOPTS_FILE = ::T.let(nil, ::T.untyped)
end

module YARD::CodeObjects
  BUILTIN_ALL = ::T.let(nil, ::T.untyped)
  BUILTIN_CLASSES = ::T.let(nil, ::T.untyped)
  BUILTIN_EXCEPTIONS = ::T.let(nil, ::T.untyped)
  BUILTIN_EXCEPTIONS_HASH = ::T.let(nil, ::T.untyped)
  BUILTIN_MODULES = ::T.let(nil, ::T.untyped)
  CONSTANTMATCH = ::T.let(nil, ::T.untyped)
  CONSTANTSTART = ::T.let(nil, ::T.untyped)
  CSEP = ::T.let(nil, ::T.untyped)
  CSEPQ = ::T.let(nil, ::T.untyped)
  ISEP = ::T.let(nil, ::T.untyped)
  ISEPQ = ::T.let(nil, ::T.untyped)
  METHODMATCH = ::T.let(nil, ::T.untyped)
  METHODNAMEMATCH = ::T.let(nil, ::T.untyped)
  NAMESPACEMATCH = ::T.let(nil, ::T.untyped)
  NSEP = ::T.let(nil, ::T.untyped)
  NSEPQ = ::T.let(nil, ::T.untyped)
  PROXY_MATCH = ::T.let(nil, ::T.untyped)
end

class YARD::CodeObjects::ClassVariableObject
  def value(); end

  def value=(value); end
end

class YARD::CodeObjects::ClassVariableObject
end

class YARD::CodeObjects::ExtendedMethodObject
  def initialize(obj); end

  def method_missing(sym, *args, &block); end

  def scope(); end
end

class YARD::CodeObjects::ExtendedMethodObject
end

class YARD::CodeObjects::ExtraFileObject
  def ==(other); end

  def attributes(); end

  def attributes=(attributes); end

  def contents(); end

  def contents=(contents); end

  def eql?(other); end

  def equal?(other); end

  def filename(); end

  def filename=(filename); end

  def initialize(filename, contents=T.unsafe(nil)); end

  def locale(); end

  def locale=(locale); end

  def name(); end

  def name=(name); end

  def path(); end

  def title(); end

  def type(); end
end

class YARD::CodeObjects::ExtraFileObject
end

class YARD::CodeObjects::MacroObject
  def attached?(); end

  def expand(call_params=T.unsafe(nil), full_source=T.unsafe(nil), block_source=T.unsafe(nil)); end

  def macro_data(); end

  def macro_data=(macro_data); end

  def method_object(); end

  def method_object=(method_object); end
  MACRO_MATCH = ::T.let(nil, ::T.untyped)
end

class YARD::CodeObjects::MacroObject
  def self.apply(docstring, call_params=T.unsafe(nil), full_source=T.unsafe(nil), block_source=T.unsafe(nil), _method_object=T.unsafe(nil)); end

  def self.apply_macro(macro, docstring, call_params=T.unsafe(nil), full_source=T.unsafe(nil), block_source=T.unsafe(nil)); end

  def self.create(macro_name, data, method_object=T.unsafe(nil)); end

  def self.create_docstring(macro_name, data, method_object=T.unsafe(nil)); end

  def self.expand(macro_data, call_params=T.unsafe(nil), full_source=T.unsafe(nil), block_source=T.unsafe(nil)); end

  def self.find(macro_name); end

  def self.find_or_create(macro_name, data, method_object=T.unsafe(nil)); end
end

class YARD::Config
  CONFIG_DIR = ::T.let(nil, ::T.untyped)
  CONFIG_FILE = ::T.let(nil, ::T.untyped)
  DEFAULT_CONFIG_OPTIONS = ::T.let(nil, ::T.untyped)
  IGNORED_PLUGINS = ::T.let(nil, ::T.untyped)
  YARD_PLUGIN_PREFIX = ::T.let(nil, ::T.untyped)
end

class YARD::Docstring
  META_MATCH = ::T.let(nil, ::T.untyped)
end

class YARD::DocstringParser
  META_MATCH = ::T.let(nil, ::T.untyped)
end

module YARD::GemIndex
end

module YARD::GemIndex
  def self.all(); end

  def self.each(&block); end

  def self.find_all_by_name(*args); end
end

class YARD::Handlers::C::AliasHandler
  MATCH = ::T.let(nil, ::T.untyped)
end

class YARD::Handlers::C::AliasHandler
end

class YARD::Handlers::C::AttributeHandler
  MATCH = ::T.let(nil, ::T.untyped)
end

class YARD::Handlers::C::AttributeHandler
end

class YARD::Handlers::C::Base
  include ::YARD::Handlers::C::HandlerMethods
  include ::YARD::Parser::C
  include ::YARD::Handlers::Common::MethodHandler
  def ensure_variable_defined!(var, max_retries=T.unsafe(nil)); end

  def namespace_for_variable(var); end

  def namespaces(); end

  def override_comments(); end

  def parse_block(opts=T.unsafe(nil)); end

  def process_file(file, object); end

  def processed_files(); end

  def symbols(); end
  ERROR_CLASS_NAMES = ::T.let(nil, ::T.untyped)
end

class YARD::Handlers::C::Base
  def self.handles?(statement, processor); end

  def self.statement_class(type=T.unsafe(nil)); end
end

class YARD::Handlers::C::ClassHandler
  MATCH1 = ::T.let(nil, ::T.untyped)
  MATCH2 = ::T.let(nil, ::T.untyped)
end

class YARD::Handlers::C::ClassHandler
end

class YARD::Handlers::C::ConstantHandler
  MATCH = ::T.let(nil, ::T.untyped)
end

class YARD::Handlers::C::ConstantHandler
end

module YARD::Handlers::C::HandlerMethods
  include ::YARD::Parser::C
  include ::YARD::CodeObjects
  include ::YARD::Handlers::Common::MethodHandler
  def handle_alias(var_name, new_name, old_name); end

  def handle_attribute(var_name, name, read, write); end

  def handle_class(var_name, class_name, parent, in_module=T.unsafe(nil)); end

  def handle_constants(type, var_name, const_name, value); end

  def handle_method(scope, var_name, name, func_name, _source_file=T.unsafe(nil)); end

  def handle_module(var_name, module_name, in_module=T.unsafe(nil)); end
end

module YARD::Handlers::C::HandlerMethods
end

class YARD::Handlers::C::InitHandler
  MATCH = ::T.let(nil, ::T.untyped)
end

class YARD::Handlers::C::InitHandler
end

class YARD::Handlers::C::MethodHandler
  MATCH1 = ::T.let(nil, ::T.untyped)
  MATCH2 = ::T.let(nil, ::T.untyped)
  MATCH3 = ::T.let(nil, ::T.untyped)
end

class YARD::Handlers::C::MethodHandler
end

class YARD::Handlers::C::MixinHandler
  MATCH = ::T.let(nil, ::T.untyped)
end

class YARD::Handlers::C::MixinHandler
end

class YARD::Handlers::C::ModuleHandler
  MATCH1 = ::T.let(nil, ::T.untyped)
  MATCH2 = ::T.let(nil, ::T.untyped)
end

class YARD::Handlers::C::ModuleHandler
end

class YARD::Handlers::C::OverrideCommentHandler
end

class YARD::Handlers::C::OverrideCommentHandler
end

class YARD::Handlers::C::PathHandler
  MATCH = ::T.let(nil, ::T.untyped)
end

class YARD::Handlers::C::PathHandler
end

class YARD::Handlers::C::StructHandler
  MATCH = ::T.let(nil, ::T.untyped)
end

class YARD::Handlers::C::StructHandler
end

class YARD::Handlers::C::SymbolHandler
  MATCH = ::T.let(nil, ::T.untyped)
end

class YARD::Handlers::C::SymbolHandler
end

module YARD::Handlers::Common::MethodHandler
  def add_predicate_return_tag(obj); end
end

module YARD::Handlers::Common::MethodHandler
end

class YARD::Handlers::Processor
  def extra_state(); end

  def extra_state=(extra_state); end

  def file(); end

  def file=(file); end

  def find_handlers(statement); end

  def globals(); end

  def globals=(globals); end

  def initialize(parser); end

  def namespace(); end

  def namespace=(namespace); end

  def owner(); end

  def owner=(owner); end

  def parse_remaining_files(); end

  def parser_type(); end

  def parser_type=(parser_type); end

  def process(statements); end

  def scope(); end

  def scope=(scope); end

  def visibility(); end

  def visibility=(visibility); end
end

class YARD::Handlers::Processor
  def self.namespace_for_handler(); end

  def self.register_handler_namespace(type, ns); end
end

class YARD::Handlers::Ruby::AliasHandler
end

class YARD::Handlers::Ruby::AliasHandler
end

class YARD::Handlers::Ruby::AttributeHandler
  def validated_attribute_names(params); end
end

class YARD::Handlers::Ruby::AttributeHandler
end

class YARD::Handlers::Ruby::Base
  extend ::YARD::Parser::Ruby
end

class YARD::Handlers::Ruby::ClassConditionHandler
  def parse_condition(); end

  def parse_else_block(); end

  def parse_then_block(); end
end

class YARD::Handlers::Ruby::ClassConditionHandler
end

class YARD::Handlers::Ruby::ClassHandler
  include ::YARD::Handlers::Ruby::StructHandlerMethods
end

class YARD::Handlers::Ruby::ClassHandler
end

class YARD::Handlers::Ruby::ClassVariableHandler
end

class YARD::Handlers::Ruby::ClassVariableHandler
end

class YARD::Handlers::Ruby::CommentHandler
end

class YARD::Handlers::Ruby::CommentHandler
end

class YARD::Handlers::Ruby::ConstantHandler
  include ::YARD::Handlers::Ruby::StructHandlerMethods
end

class YARD::Handlers::Ruby::ConstantHandler
end

class YARD::Handlers::Ruby::DSLHandler
  include ::YARD::Handlers::Ruby::DSLHandlerMethods
end

class YARD::Handlers::Ruby::DSLHandler
end

module YARD::Handlers::Ruby::DSLHandlerMethods
  include ::YARD::CodeObjects
  include ::YARD::Parser
  def handle_comments(); end

  def register_docstring(object, docstring=T.unsafe(nil), stmt=T.unsafe(nil)); end
  IGNORE_METHODS = ::T.let(nil, ::T.untyped)
end

module YARD::Handlers::Ruby::DSLHandlerMethods
end

module YARD::Handlers::Ruby::DecoratorHandlerMethods
  def process_decorator(*nodes, &block); end
end

module YARD::Handlers::Ruby::DecoratorHandlerMethods
end

class YARD::Handlers::Ruby::ExceptionHandler
end

class YARD::Handlers::Ruby::ExceptionHandler
end

class YARD::Handlers::Ruby::ExtendHandler
end

class YARD::Handlers::Ruby::ExtendHandler
end

class YARD::Handlers::Ruby::Legacy::AliasHandler
end

class YARD::Handlers::Ruby::Legacy::AliasHandler
end

class YARD::Handlers::Ruby::Legacy::AttributeHandler
end

class YARD::Handlers::Ruby::Legacy::AttributeHandler
end

class YARD::Handlers::Ruby::Legacy::Base
  include ::YARD::Parser::Ruby::Legacy::RubyToken
  def parse_block(opts=T.unsafe(nil)); end
end

class YARD::Handlers::Ruby::Legacy::Base
  def self.handles?(stmt); end
end

class YARD::Handlers::Ruby::Legacy::ClassConditionHandler
  def parse_condition(); end

  def parse_else_block(); end

  def parse_then_block(); end
end

class YARD::Handlers::Ruby::Legacy::ClassConditionHandler
end

class YARD::Handlers::Ruby::Legacy::ClassHandler
  include ::YARD::Handlers::Ruby::StructHandlerMethods
end

class YARD::Handlers::Ruby::Legacy::ClassHandler
end

class YARD::Handlers::Ruby::Legacy::ClassVariableHandler
  HANDLER_MATCH = ::T.let(nil, ::T.untyped)
end

class YARD::Handlers::Ruby::Legacy::ClassVariableHandler
end

class YARD::Handlers::Ruby::Legacy::CommentHandler
end

class YARD::Handlers::Ruby::Legacy::CommentHandler
end

class YARD::Handlers::Ruby::Legacy::ConstantHandler
  include ::YARD::Handlers::Ruby::StructHandlerMethods
  HANDLER_MATCH = ::T.let(nil, ::T.untyped)
end

class YARD::Handlers::Ruby::Legacy::ConstantHandler
end

class YARD::Handlers::Ruby::Legacy::DSLHandler
  include ::YARD::Handlers::Ruby::DSLHandlerMethods
end

class YARD::Handlers::Ruby::Legacy::DSLHandler
end

class YARD::Handlers::Ruby::Legacy::ExceptionHandler
end

class YARD::Handlers::Ruby::Legacy::ExceptionHandler
end

class YARD::Handlers::Ruby::Legacy::ExtendHandler
end

class YARD::Handlers::Ruby::Legacy::ExtendHandler
end

class YARD::Handlers::Ruby::Legacy::MethodHandler
end

class YARD::Handlers::Ruby::Legacy::MethodHandler
end

class YARD::Handlers::Ruby::Legacy::MixinHandler
end

class YARD::Handlers::Ruby::Legacy::MixinHandler
end

class YARD::Handlers::Ruby::Legacy::ModuleFunctionHandler
end

class YARD::Handlers::Ruby::Legacy::ModuleFunctionHandler
end

class YARD::Handlers::Ruby::Legacy::ModuleHandler
end

class YARD::Handlers::Ruby::Legacy::ModuleHandler
end

class YARD::Handlers::Ruby::Legacy::PrivateClassMethodHandler
end

class YARD::Handlers::Ruby::Legacy::PrivateClassMethodHandler
end

class YARD::Handlers::Ruby::Legacy::PrivateConstantHandler
end

class YARD::Handlers::Ruby::Legacy::PrivateConstantHandler
end

class YARD::Handlers::Ruby::Legacy::VisibilityHandler
end

class YARD::Handlers::Ruby::Legacy::VisibilityHandler
end

class YARD::Handlers::Ruby::Legacy::YieldHandler
end

class YARD::Handlers::Ruby::Legacy::YieldHandler
end

class YARD::Handlers::Ruby::MethodConditionHandler
end

class YARD::Handlers::Ruby::MethodConditionHandler
end

class YARD::Handlers::Ruby::MethodHandler
  include ::YARD::Handlers::Common::MethodHandler
  def format_args(); end
end

class YARD::Handlers::Ruby::MethodHandler
end

class YARD::Handlers::Ruby::MixinHandler
  def process_mixin(mixin); end

  def recipient(mixin); end
end

class YARD::Handlers::Ruby::MixinHandler
end

class YARD::Handlers::Ruby::ModuleFunctionHandler
end

class YARD::Handlers::Ruby::ModuleFunctionHandler
end

class YARD::Handlers::Ruby::ModuleHandler
end

class YARD::Handlers::Ruby::ModuleHandler
end

class YARD::Handlers::Ruby::PrivateClassMethodHandler
  include ::YARD::Handlers::Ruby::DecoratorHandlerMethods
end

class YARD::Handlers::Ruby::PrivateClassMethodHandler
end

class YARD::Handlers::Ruby::PrivateConstantHandler
end

class YARD::Handlers::Ruby::PrivateConstantHandler
end

class YARD::Handlers::Ruby::PublicClassMethodHandler
  include ::YARD::Handlers::Ruby::DecoratorHandlerMethods
end

class YARD::Handlers::Ruby::PublicClassMethodHandler
end

module YARD::Handlers::Ruby::StructHandlerMethods
  include ::YARD::CodeObjects
  def add_reader_tags(klass, new_method, member); end

  def add_writer_tags(klass, new_method, member); end

  def create_attributes(klass, members); end

  def create_class(classname, superclass); end

  def create_member_method?(klass, member, type=T.unsafe(nil)); end

  def create_reader(klass, member); end

  def create_writer(klass, member); end

  def member_tag_for_member(klass, member, type=T.unsafe(nil)); end

  def members_from_tags(klass); end

  def return_type_from_tag(member_tag); end
end

module YARD::Handlers::Ruby::StructHandlerMethods
end

class YARD::Handlers::Ruby::VisibilityHandler
  include ::YARD::Handlers::Ruby::DecoratorHandlerMethods
end

class YARD::Handlers::Ruby::VisibilityHandler
end

class YARD::Handlers::Ruby::YieldHandler
end

class YARD::Handlers::Ruby::YieldHandler
end

class YARD::I18n::Locale
  def initialize(name); end

  def load(locale_directory); end

  def name(); end

  def translate(message); end
end

class YARD::I18n::Locale
  def self.default(); end

  def self.default=(locale); end
end

class YARD::I18n::Message
  def ==(other); end

  def add_comment(comment); end

  def add_location(path, line); end

  def comments(); end

  def id(); end

  def initialize(id); end

  def locations(); end
end

class YARD::I18n::Message
end

class YARD::I18n::Messages
  include ::Enumerable
  def ==(other); end

  def [](id); end

  def each(&block); end

  def messages(); end

  def register(id); end
end

class YARD::I18n::Messages
end

class YARD::I18n::PotGenerator
  def generate(); end

  def initialize(relative_base_path); end

  def messages(); end

  def parse_files(files); end

  def parse_objects(objects); end
end

class YARD::I18n::PotGenerator
end

class YARD::I18n::Text
  def extract_messages(); end

  def initialize(input, options=T.unsafe(nil)); end

  def translate(locale); end
end

class YARD::I18n::Text
end

class YARD::Logger
  PROGRESS_INDICATORS = ::T.let(nil, ::T.untyped)
end

module YARD::Parser::Ruby::Legacy::RubyToken
  def Token(token, value=T.unsafe(nil)); end

  def set_token_position(line, char); end
  EXPR_ARG = ::T.let(nil, ::T.untyped)
  EXPR_BEG = ::T.let(nil, ::T.untyped)
  EXPR_CLASS = ::T.let(nil, ::T.untyped)
  EXPR_DOT = ::T.let(nil, ::T.untyped)
  EXPR_END = ::T.let(nil, ::T.untyped)
  EXPR_FNAME = ::T.let(nil, ::T.untyped)
  EXPR_MID = ::T.let(nil, ::T.untyped)
  NEWLINE_TOKEN = ::T.let(nil, ::T.untyped)
  TkReading2Token = ::T.let(nil, ::T.untyped)
  TkSymbol2Token = ::T.let(nil, ::T.untyped)
  TokenDefinitions = ::T.let(nil, ::T.untyped)
end

module YARD::Parser::Ruby::Legacy::RubyToken
  def self.def_token(token_n, super_token=T.unsafe(nil), reading=T.unsafe(nil), *opts); end
end

class YARD::Parser::SourceParser
  DEFAULT_PATH_GLOB = ::T.let(nil, ::T.untyped)
  ENCODING_BYTE_ORDER_MARKS = ::T.let(nil, ::T.untyped)
  ENCODING_LINE = ::T.let(nil, ::T.untyped)
  FROZEN_STRING_LINE = ::T.let(nil, ::T.untyped)
  SHEBANG_LINE = ::T.let(nil, ::T.untyped)
end

module YARD::Registry
  DEFAULT_PO_DIR = ::T.let(nil, ::T.untyped)
  DEFAULT_YARDOC_FILE = ::T.let(nil, ::T.untyped)
  LOCAL_YARDOC_INDEX = ::T.let(nil, ::T.untyped)
end

class YARD::RegistryResolver
  include ::YARD::CodeObjects::NamespaceMapper
  def initialize(registry=T.unsafe(nil)); end

  def lookup_by_path(path, opts=T.unsafe(nil)); end
end

class YARD::RegistryResolver
end

class YARD::Serializers::ProcessSerializer
  def initialize(cmd); end

  def serialize(_object, data); end
end

class YARD::Serializers::ProcessSerializer
end

class YARD::Serializers::StdoutSerializer
  def initialize(wrap=T.unsafe(nil)); end

  def serialize(_object, data); end
end

class YARD::Serializers::StdoutSerializer
end

class YARD::Server::Adapter
  def add_library(library); end

  def document_root(); end

  def document_root=(document_root); end

  def initialize(libs, opts=T.unsafe(nil), server_opts=T.unsafe(nil)); end

  def libraries(); end

  def libraries=(libraries); end

  def options(); end

  def options=(options); end

  def router(); end

  def router=(router); end

  def server_options(); end

  def server_options=(server_options); end

  def start(); end
end

class YARD::Server::Adapter
  def self.setup(); end

  def self.shutdown(); end
end

class YARD::Server::Commands::Base
  def adapter(); end

  def adapter=(adapter); end

  def body(); end

  def body=(body); end

  def cache(data); end

  def caching(); end

  def caching=(caching); end

  def call(request); end

  def command_options(); end

  def command_options=(command_options); end

  def headers(); end

  def headers=(headers); end

  def initialize(opts=T.unsafe(nil)); end

  def not_found(); end

  def path(); end

  def path=(path); end

  def redirect(url); end

  def render(object=T.unsafe(nil)); end

  def request(); end

  def request=(request); end

  def run(); end

  def status(); end

  def status=(status); end
end

class YARD::Server::Commands::Base
end

class YARD::Server::Commands::DisplayFileCommand
  def index(); end

  def index=(index); end
end

class YARD::Server::Commands::DisplayFileCommand
end

class YARD::Server::Commands::DisplayObjectCommand
  include ::YARD::Server::DocServerHelper
  def index(); end
end

class YARD::Server::Commands::DisplayObjectCommand
end

class YARD::Server::Commands::FramesCommand
end

class YARD::Server::Commands::FramesCommand
end

class YARD::Server::Commands::LibraryCommand
  def incremental(); end

  def incremental=(incremental); end

  def library(); end

  def library=(library); end

  def options(); end

  def options=(options); end

  def serializer(); end

  def serializer=(serializer); end

  def single_library(); end

  def single_library=(single_library); end

  def use_fork(); end

  def use_fork=(use_fork); end
  CAN_FORK = ::T.let(nil, ::T.untyped)
end

class YARD::Server::Commands::LibraryCommand
end

class YARD::Server::Commands::LibraryIndexCommand
  def options(); end

  def options=(options); end
end

class YARD::Server::Commands::LibraryIndexCommand
end

class YARD::Server::Commands::ListCommand
  include ::YARD::Templates::Helpers::BaseHelper
end

class YARD::Server::Commands::ListCommand
end

class YARD::Server::Commands::RootRequestCommand
  include ::YARD::Server::Commands::StaticFileHelpers
  include ::WEBrick::HTTPUtils
end

class YARD::Server::Commands::RootRequestCommand
end

class YARD::Server::Commands::SearchCommand
  include ::YARD::Templates::Helpers::BaseHelper
  include ::YARD::Templates::Helpers::ModuleHelper
  include ::YARD::Server::DocServerHelper
  def query(); end

  def query=(query); end

  def results(); end

  def results=(results); end

  def visible_results(); end
end

class YARD::Server::Commands::SearchCommand
end

class YARD::Server::Commands::StaticFileCommand
  include ::YARD::Server::Commands::StaticFileHelpers
  include ::WEBrick::HTTPUtils
  STATIC_PATHS = ::T.let(nil, ::T.untyped)
end

class YARD::Server::Commands::StaticFileCommand
end

module YARD::Server::Commands::StaticFileHelpers
  include ::WEBrick::HTTPUtils
  def favicon?(); end

  def static_template_file?(); end
end

module YARD::Server::Commands::StaticFileHelpers
  def self.find_file(adapter, url); end
end

module YARD::Server::DocServerHelper
  def abs_url(*path_components); end

  def base_path(path); end

  def mtime(file); end

  def mtime_url(file); end

  def router(); end

  def url_for(obj, anchor=T.unsafe(nil), relative=T.unsafe(nil)); end

  def url_for_file(filename, anchor=T.unsafe(nil)); end

  def url_for_frameset(); end

  def url_for_index(); end

  def url_for_list(type); end

  def url_for_main(); end
end

module YARD::Server::DocServerHelper
end

class YARD::Server::DocServerSerializer
  def initialize(_command=T.unsafe(nil)); end
end

class YARD::Server::DocServerSerializer
end

class YARD::Server::FinishRequest
end

class YARD::Server::FinishRequest
end

class YARD::Server::LibraryVersion
  def ==(other); end

  def eql?(other); end

  def equal?(other); end

  def gemspec(); end

  def initialize(name, version=T.unsafe(nil), yardoc=T.unsafe(nil), source=T.unsafe(nil)); end

  def load_yardoc_from_disk(); end

  def load_yardoc_from_gem(); end

  def name(); end

  def name=(name); end

  def prepare!(); end

  def ready?(); end

  def source(); end

  def source=(source); end

  def source_path(); end

  def source_path=(source_path); end

  def source_path_for_disk(); end

  def source_path_for_gem(); end

  def to_s(url_format=T.unsafe(nil)); end

  def version(); end

  def version=(version); end

  def yardoc_file(); end

  def yardoc_file=(yardoc_file); end

  def yardoc_file_for_gem(); end
end

class YARD::Server::LibraryVersion
end

class YARD::Server::NotFoundError
end

class YARD::Server::NotFoundError
end

class YARD::Server::RackAdapter
  include ::WEBrick::HTTPUtils
  def call(env); end
end

class YARD::Server::RackAdapter
end

class YARD::Server::RackMiddleware
  def call(env); end

  def initialize(app, opts=T.unsafe(nil)); end
end

class YARD::Server::RackMiddleware
end

class YARD::Server::Router
  include ::YARD::Server::StaticCaching
  include ::YARD::Server::Commands
  def adapter(); end

  def adapter=(adapter); end

  def call(request); end

  def docs_prefix(); end

  def final_options(library, paths); end

  def initialize(adapter); end

  def list_prefix(); end

  def parse_library_from_path(paths); end

  def request(); end

  def request=(request); end

  def route(path=T.unsafe(nil)); end

  def route_docs(library, paths); end

  def route_index(); end

  def route_list(library, paths); end

  def route_search(library, paths); end

  def route_static(library, paths); end

  def search_prefix(); end

  def static_prefix(); end
end

class YARD::Server::Router
end

module YARD::Server::StaticCaching
  def check_static_cache(); end
end

module YARD::Server::StaticCaching
end

class YARD::Server::WebrickAdapter
end

class YARD::Server::WebrickAdapter
end

class YARD::Server::WebrickServlet
  def adapter(); end

  def adapter=(adapter); end

  def do_GET(request, response); end

  def initialize(server, adapter); end
end

class YARD::Server::WebrickServlet
end

class YARD::StubProxy
  FILELEN = ::T.let(nil, ::T.untyped)
end

class YARD::Tags::DefaultFactory
  def parse_tag(tag_name, text); end

  def parse_tag_with_name(tag_name, text); end

  def parse_tag_with_options(tag_name, text); end

  def parse_tag_with_title_and_text(tag_name, text); end

  def parse_tag_with_types(tag_name, text); end

  def parse_tag_with_types_and_name(tag_name, text); end

  def parse_tag_with_types_and_title(tag_name, text); end

  def parse_tag_with_types_name_and_default(tag_name, text); end
  TYPELIST_CLOSING_CHARS = ::T.let(nil, ::T.untyped)
  TYPELIST_OPENING_CHARS = ::T.let(nil, ::T.untyped)
end

class YARD::Tags::DefaultFactory
end

class YARD::Tags::DefaultTag
  def defaults(); end

  def initialize(tag_name, text, types=T.unsafe(nil), name=T.unsafe(nil), defaults=T.unsafe(nil)); end
end

class YARD::Tags::DefaultTag
end

class YARD::Tags::MethodDirective
  SCOPE_MATCH = ::T.let(nil, ::T.untyped)
end

class YARD::Tags::OptionTag
  def initialize(tag_name, name, pair); end

  def pair(); end

  def pair=(pair); end
end

class YARD::Tags::OptionTag
end

module YARD::Tags::RefTag
  def owner(); end

  def owner=(owner); end
end

module YARD::Tags::RefTag
end

class YARD::Tags::RefTagList
  def initialize(tag_name, owner, name=T.unsafe(nil)); end

  def name(); end

  def name=(name); end

  def owner(); end

  def owner=(owner); end

  def tag_name(); end

  def tag_name=(tag_name); end

  def tags(); end
end

class YARD::Tags::RefTagList
end

class YARD::Tags::TagFormatError
end

class YARD::Tags::TagFormatError
end

class YARD::Tags::TypesExplainer
end

class YARD::Tags::TypesExplainer::CollectionType
  def initialize(name, types); end

  def to_s(_singular=T.unsafe(nil)); end

  def types(); end

  def types=(types); end
end

class YARD::Tags::TypesExplainer::CollectionType
end

class YARD::Tags::TypesExplainer::FixedCollectionType
end

class YARD::Tags::TypesExplainer::FixedCollectionType
end

class YARD::Tags::TypesExplainer::HashCollectionType
  def initialize(name, key_types, value_types); end

  def key_types(); end

  def key_types=(key_types); end

  def to_s(_singular=T.unsafe(nil)); end

  def value_types(); end

  def value_types=(value_types); end
end

class YARD::Tags::TypesExplainer::HashCollectionType
end

class YARD::Tags::TypesExplainer::Parser
  include ::YARD::CodeObjects
  def initialize(string); end

  def parse(); end
  TOKENS = ::T.let(nil, ::T.untyped)
end

class YARD::Tags::TypesExplainer::Parser
  def self.parse(string); end
end

class YARD::Tags::TypesExplainer::Type
  def initialize(name); end

  def name(); end

  def name=(name); end

  def to_s(singular=T.unsafe(nil)); end
end

class YARD::Tags::TypesExplainer::Type
end

class YARD::Tags::TypesExplainer
  def self.explain(*types); end

  def self.explain!(*types); end
end

module YARD::Templates::Engine
end

module YARD::Templates::Engine
  def self.generate(objects, options=T.unsafe(nil)); end

  def self.register_template_path(path); end

  def self.render(options=T.unsafe(nil)); end

  def self.template(*path); end

  def self.template!(path, full_paths=T.unsafe(nil)); end

  def self.template_paths(); end

  def self.template_paths=(template_paths); end

  def self.with_serializer(object, serializer); end
end

module YARD::Templates::ErbCache
end

module YARD::Templates::ErbCache
  def self.clear!(); end

  def self.method_for(filename); end
end

module YARD::Templates::Helpers::BaseHelper
  def format_object_title(object); end

  def format_object_type(object); end

  def format_source(value); end

  def format_types(list, brackets=T.unsafe(nil)); end

  def globals(); end

  def h(text); end

  def link_file(filename, title=T.unsafe(nil), anchor=T.unsafe(nil)); end

  def link_include_file(file); end

  def link_include_object(obj); end

  def link_object(obj, title=T.unsafe(nil)); end

  def link_url(url, title=T.unsafe(nil), params=T.unsafe(nil)); end

  def linkify(*args); end

  def object(); end

  def object=(object); end

  def owner(); end

  def run_verifier(list); end

  def serializer(); end

  def serializer=(serializer); end
end

module YARD::Templates::Helpers::BaseHelper
end

module YARD::Templates::Helpers::FilterHelper
  def is_class?(object); end

  def is_method?(object); end

  def is_module?(object); end

  def is_namespace?(object); end
end

module YARD::Templates::Helpers::FilterHelper
end

module YARD::Templates::Helpers::HtmlHelper
  include ::YARD::Templates::Helpers::MarkupHelper
  include ::YARD::Templates::Helpers::HtmlSyntaxHighlightHelper
  include ::YARD::Templates::Helpers::ModuleHelper
  def anchor_for(object); end

  def charset(); end

  def format_object_name_list(objects); end

  def format_types(typelist, brackets=T.unsafe(nil)); end

  def h(text); end

  def html_markup_asciidoc(text); end

  def html_markup_html(text); end

  def html_markup_markdown(text); end

  def html_markup_none(text); end

  def html_markup_org(text); end

  def html_markup_pre(text); end

  def html_markup_rdoc(text); end

  def html_markup_ruby(source); end

  def html_markup_text(text); end

  def html_markup_textile(text); end

  def html_markup_textile_strict(text); end

  def html_syntax_highlight(source, type=T.unsafe(nil)); end

  def html_syntax_highlight_plain(source); end

  def htmlify(text, markup=T.unsafe(nil)); end

  def htmlify_line(*args); end

  def insert_include(text, markup=T.unsafe(nil)); end

  def link_file(filename, title=T.unsafe(nil), anchor=T.unsafe(nil)); end

  def link_include_file(file); end

  def link_include_object(obj); end

  def link_object(obj, title=T.unsafe(nil), anchor=T.unsafe(nil), relative=T.unsafe(nil)); end

  def link_url(url, title=T.unsafe(nil), params=T.unsafe(nil)); end

  def mtime(_file); end

  def mtime_url(obj, anchor=T.unsafe(nil), relative=T.unsafe(nil)); end

  def resolve_links(text); end

  def signature(meth, link=T.unsafe(nil), show_extras=T.unsafe(nil), full_attr_name=T.unsafe(nil)); end

  def signature_types(meth, link=T.unsafe(nil)); end

  def url_for(obj, anchor=T.unsafe(nil), relative=T.unsafe(nil)); end

  def url_for_file(filename, anchor=T.unsafe(nil)); end

  def url_for_frameset(); end

  def url_for_index(); end

  def url_for_list(type); end

  def url_for_main(); end
  ASCIIDOC_ATTRIBUTES = ::T.let(nil, ::T.untyped)
  URLMATCH = ::T.let(nil, ::T.untyped)
end

module YARD::Templates::Helpers::HtmlHelper
  def self.urlencode(text); end
end

module YARD::Templates::Helpers::HtmlSyntaxHighlightHelper
  include ::YARD::Templates::Helpers::ModuleHelper
  def html_syntax_highlight_ruby(source); end
end

module YARD::Templates::Helpers::HtmlSyntaxHighlightHelper
end

class YARD::Templates::Helpers::Markup::RDocMarkdown
  def fix_typewriter(html); end
end

class YARD::Templates::Helpers::Markup::RDocMarkdown
end

class YARD::Templates::Helpers::Markup::RDocMarkup
  def from_path(); end

  def from_path=(from_path); end

  def initialize(text); end

  def to_html(); end
end

class YARD::Templates::Helpers::Markup::RDocMarkup::MARKUP
  def add_html(tag, name); end

  def add_regexp_handling(pattern, name); end

  def add_word_pair(start, stop, name); end

  def attribute_manager(); end

  def convert(input, formatter); end

  def initialize(attribute_manager=T.unsafe(nil)); end
end

class YARD::Templates::Helpers::Markup::RDocMarkup::MARKUP::AttrChanger
  def turn_off(); end

  def turn_off=(_); end

  def turn_on(); end

  def turn_on=(_); end
end

class YARD::Templates::Helpers::Markup::RDocMarkup::MARKUP::AttrChanger
  def self.[](*_); end

  def self.members(); end
end

class YARD::Templates::Helpers::Markup::RDocMarkup::MARKUP::AttrSpan
  def [](n); end

  def initialize(length); end

  def set_attrs(start, length, bits); end
end

class YARD::Templates::Helpers::Markup::RDocMarkup::MARKUP::AttrSpan
end

class YARD::Templates::Helpers::Markup::RDocMarkup::MARKUP::AttributeManager
  def add_html(tag, name); end

  def add_regexp_handling(pattern, name); end

  def add_word_pair(start, stop, name); end

  def attribute(turn_on, turn_off); end

  def attributes(); end

  def change_attribute(current, new); end

  def changed_attribute_by_name(current_set, new_set); end

  def convert_attrs(str, attrs); end

  def convert_html(str, attrs); end

  def convert_regexp_handlings(str, attrs); end

  def copy_string(start_pos, end_pos); end

  def display_attributes(); end

  def flow(str); end

  def html_tags(); end

  def mask_protected_sequences(); end

  def matching_word_pairs(); end

  def protectable(); end

  def regexp_handlings(); end

  def split_into_flow(); end

  def unmask_protected_sequences(); end

  def word_pair_map(); end
  A_PROTECT = ::T.let(nil, ::T.untyped)
  NULL = ::T.let(nil, ::T.untyped)
  PROTECT_ATTR = ::T.let(nil, ::T.untyped)
end

class YARD::Templates::Helpers::Markup::RDocMarkup::MARKUP::AttributeManager
end

class YARD::Templates::Helpers::Markup::RDocMarkup::MARKUP::Attributes
  def as_string(bitmap); end

  def bitmap_for(name); end

  def each_name_of(bitmap); end

  def regexp_handling(); end
end

class YARD::Templates::Helpers::Markup::RDocMarkup::MARKUP::Attributes
end

class YARD::Templates::Helpers::Markup::RDocMarkup::MARKUP::BlankLine
  def accept(visitor); end
end

class YARD::Templates::Helpers::Markup::RDocMarkup::MARKUP::BlankLine
  def self.new(); end
end

class YARD::Templates::Helpers::Markup::RDocMarkup::MARKUP::BlockQuote
end

class YARD::Templates::Helpers::Markup::RDocMarkup::MARKUP::BlockQuote
end

class YARD::Templates::Helpers::Markup::RDocMarkup::MARKUP::Document
  include ::Enumerable
  def <<(part); end

  def ==(other); end

  def accept(visitor); end

  def concat(parts); end

  def each(&block); end

  def empty?(); end

  def file(); end

  def file=(location); end

  def initialize(*parts); end

  def merge(other); end

  def merged?(); end

  def omit_headings_below(); end

  def omit_headings_below=(omit_headings_below); end

  def parts(); end

  def push(*parts); end

  def table_of_contents(); end
end

class YARD::Templates::Helpers::Markup::RDocMarkup::MARKUP::Document
end

class YARD::Templates::Helpers::Markup::RDocMarkup::MARKUP::Formatter
  def accept_document(document); end

  def add_regexp_handling_RDOCLINK(); end

  def add_regexp_handling_TIDYLINK(); end

  def add_tag(name, start, stop); end

  def annotate(tag); end

  def convert(content); end

  def convert_flow(flow); end

  def convert_regexp_handling(target); end

  def convert_string(string); end

  def ignore(*node); end

  def in_tt?(); end

  def initialize(options, markup=T.unsafe(nil)); end

  def off_tags(res, item); end

  def on_tags(res, item); end

  def parse_url(url); end

  def tt?(tag); end
end

class YARD::Templates::Helpers::Markup::RDocMarkup::MARKUP::Formatter::InlineTag
  def bit(); end

  def bit=(_); end

  def off(); end

  def off=(_); end

  def on(); end

  def on=(_); end
end

class YARD::Templates::Helpers::Markup::RDocMarkup::MARKUP::Formatter::InlineTag
  def self.[](*_); end

  def self.members(); end
end

class YARD::Templates::Helpers::Markup::RDocMarkup::MARKUP::Formatter
  def self.gen_relative_url(path, target); end
end

class YARD::Templates::Helpers::Markup::RDocMarkup::MARKUP::HardBreak
  def ==(other); end

  def accept(visitor); end
end

class YARD::Templates::Helpers::Markup::RDocMarkup::MARKUP::HardBreak
  def self.new(); end
end

class YARD::Templates::Helpers::Markup::RDocMarkup::MARKUP::Heading
  def accept(visitor); end

  def aref(); end

  def label(context=T.unsafe(nil)); end

  def level(); end

  def level=(_); end

  def plain_html(); end

  def text(); end

  def text=(_); end
end

class YARD::Templates::Helpers::Markup::RDocMarkup::MARKUP::Heading
  def self.[](*_); end

  def self.members(); end

  def self.to_html(); end

  def self.to_label(); end
end

class YARD::Templates::Helpers::Markup::RDocMarkup::MARKUP::Include
  def ==(other); end

  def file(); end

  def include_path(); end

  def initialize(file, include_path); end
end

class YARD::Templates::Helpers::Markup::RDocMarkup::MARKUP::Include
end

class YARD::Templates::Helpers::Markup::RDocMarkup::MARKUP::IndentedParagraph
  def indent(); end

  def initialize(indent, *parts); end

  def text(hard_break=T.unsafe(nil)); end
end

class YARD::Templates::Helpers::Markup::RDocMarkup::MARKUP::IndentedParagraph
end

class YARD::Templates::Helpers::Markup::RDocMarkup::MARKUP::List
  def <<(item); end

  def ==(other); end

  def accept(visitor); end

  def empty?(); end

  def initialize(type=T.unsafe(nil), *items); end

  def items(); end

  def last(); end

  def push(*items); end

  def type(); end

  def type=(type); end
end

class YARD::Templates::Helpers::Markup::RDocMarkup::MARKUP::List
end

class YARD::Templates::Helpers::Markup::RDocMarkup::MARKUP::ListItem
  def <<(part); end

  def ==(other); end

  def accept(visitor); end

  def empty?(); end

  def initialize(label=T.unsafe(nil), *parts); end

  def label(); end

  def label=(label); end

  def length(); end

  def parts(); end

  def push(*parts); end
end

class YARD::Templates::Helpers::Markup::RDocMarkup::MARKUP::ListItem
end

class YARD::Templates::Helpers::Markup::RDocMarkup::MARKUP::Paragraph
  def text(hard_break=T.unsafe(nil)); end
end

class YARD::Templates::Helpers::Markup::RDocMarkup::MARKUP::Paragraph
end

class YARD::Templates::Helpers::Markup::RDocMarkup::MARKUP::Parser
  include ::RDoc::Text
  def build_heading(level); end

  def build_list(margin); end

  def build_paragraph(margin); end

  def build_verbatim(margin); end

  def debug(); end

  def debug=(debug); end

  def get(); end

  def parse(parent, indent=T.unsafe(nil)); end

  def parse_text(parent, indent); end

  def peek_token(); end

  def setup_scanner(input); end

  def skip(token_type, error=T.unsafe(nil)); end

  def tokenize(input); end

  def tokens(); end

  def unget(); end
  LIST_TOKENS = ::T.let(nil, ::T.untyped)
end

class YARD::Templates::Helpers::Markup::RDocMarkup::MARKUP::Parser::Error
end

class YARD::Templates::Helpers::Markup::RDocMarkup::MARKUP::Parser::Error
end

class YARD::Templates::Helpers::Markup::RDocMarkup::MARKUP::Parser::MyStringScanner
  def [](i); end

  def eos?(); end

  def initialize(input); end

  def matched(); end

  def newline!(); end

  def pos(); end

  def scan(re); end

  def unscan(s); end
end

class YARD::Templates::Helpers::Markup::RDocMarkup::MARKUP::Parser::MyStringScanner
end

class YARD::Templates::Helpers::Markup::RDocMarkup::MARKUP::Parser::ParseError
end

class YARD::Templates::Helpers::Markup::RDocMarkup::MARKUP::Parser::ParseError
end

class YARD::Templates::Helpers::Markup::RDocMarkup::MARKUP::Parser
  def self.parse(str); end

  def self.tokenize(str); end
end

class YARD::Templates::Helpers::Markup::RDocMarkup::MARKUP::PreProcess
  def find_include_file(name); end

  def handle(text, code_object=T.unsafe(nil), &block); end

  def handle_directive(prefix, directive, param, code_object=T.unsafe(nil), encoding=T.unsafe(nil)); end

  def include_file(name, indent, encoding); end

  def initialize(input_file_name, include_path); end

  def options(); end

  def options=(options); end
end

class YARD::Templates::Helpers::Markup::RDocMarkup::MARKUP::PreProcess
  def self.post_process(&block); end

  def self.post_processors(); end

  def self.register(directive, &block); end

  def self.registered(); end

  def self.reset(); end
end

class YARD::Templates::Helpers::Markup::RDocMarkup::MARKUP::Raw
  def <<(text); end

  def ==(other); end

  def accept(visitor); end

  def initialize(*parts); end

  def merge(other); end

  def parts(); end

  def push(*texts); end

  def text(); end
end

class YARD::Templates::Helpers::Markup::RDocMarkup::MARKUP::Raw
end

class YARD::Templates::Helpers::Markup::RDocMarkup::MARKUP::RegexpHandling
  def ==(o); end

  def initialize(type, text); end

  def text(); end

  def text=(text); end

  def type(); end
end

class YARD::Templates::Helpers::Markup::RDocMarkup::MARKUP::RegexpHandling
end

class YARD::Templates::Helpers::Markup::RDocMarkup::MARKUP::Rule
  def accept(visitor); end
end

class YARD::Templates::Helpers::Markup::RDocMarkup::MARKUP::Rule
end

class YARD::Templates::Helpers::Markup::RDocMarkup::MARKUP::ToAnsi
end

class YARD::Templates::Helpers::Markup::RDocMarkup::MARKUP::ToAnsi
end

class YARD::Templates::Helpers::Markup::RDocMarkup::MARKUP::ToBs
end

class YARD::Templates::Helpers::Markup::RDocMarkup::MARKUP::ToBs
end

class YARD::Templates::Helpers::Markup::RDocMarkup::MARKUP::ToHtml
  include ::RDoc::Text
  def accept_blank_line(blank_line); end

  def accept_block_quote(block_quote); end

  def accept_heading(heading); end

  def accept_list_end(list); end

  def accept_list_item_end(list_item); end

  def accept_list_item_start(list_item); end

  def accept_list_start(list); end

  def accept_paragraph(paragraph); end

  def accept_raw(raw); end

  def accept_rule(rule); end

  def accept_verbatim(verbatim); end

  def code_object(); end

  def code_object=(code_object); end

  def convert_string(text); end

  def end_accepting(); end

  def from_path(); end

  def from_path=(from_path); end

  def gen_url(url, text); end

  def handle_RDOCLINK(url); end

  def handle_regexp_HARD_BREAK(target); end

  def handle_regexp_HYPERLINK(target); end

  def handle_regexp_RDOCLINK(target); end

  def handle_regexp_TIDYLINK(target); end

  def html_list_name(list_type, open_tag); end

  def in_list_entry(); end

  def init_tags(); end

  def list(); end

  def list_end_for(list_type); end

  def list_item_start(list_item, list_type); end

  def parseable?(text); end

  def res(); end

  def start_accepting(); end

  def to_html(item); end
  LIST_TYPE_TO_HTML = ::T.let(nil, ::T.untyped)
end

class YARD::Templates::Helpers::Markup::RDocMarkup::MARKUP::ToHtml
end

class YARD::Templates::Helpers::Markup::RDocMarkup::MARKUP::ToHtmlCrossref
  def context(); end

  def context=(context); end

  def cross_reference(name, text=T.unsafe(nil), code=T.unsafe(nil)); end

  def handle_regexp_CROSSREF(target); end

  def initialize(options, from_path, context, markup=T.unsafe(nil)); end

  def link(name, text, code=T.unsafe(nil)); end

  def show_hash(); end

  def show_hash=(show_hash); end
  ALL_CROSSREF_REGEXP = ::T.let(nil, ::T.untyped)
  CLASS_REGEXP_STR = ::T.let(nil, ::T.untyped)
  CROSSREF_REGEXP = ::T.let(nil, ::T.untyped)
  METHOD_REGEXP_STR = ::T.let(nil, ::T.untyped)
end

class YARD::Templates::Helpers::Markup::RDocMarkup::MARKUP::ToHtmlCrossref
end

class YARD::Templates::Helpers::Markup::RDocMarkup::MARKUP::ToHtmlSnippet
  def accept_raw(*node); end

  def accept_rule(*node); end

  def add_paragraph(); end

  def character_limit(); end

  def characters(); end

  def handle_regexp_CROSSREF(target); end

  def initialize(options, characters=T.unsafe(nil), paragraphs=T.unsafe(nil), markup=T.unsafe(nil)); end

  def mask(); end

  def paragraph_limit(); end

  def paragraphs(); end

  def truncate(text); end
end

class YARD::Templates::Helpers::Markup::RDocMarkup::MARKUP::ToHtmlSnippet
end

class YARD::Templates::Helpers::Markup::RDocMarkup::MARKUP::ToJoinedParagraph
  def accept_block_quote(*node); end

  def accept_heading(*node); end

  def accept_list_end(*node); end

  def accept_list_item_end(*node); end

  def accept_list_item_start(*node); end

  def accept_list_start(*node); end

  def accept_paragraph(paragraph); end

  def accept_raw(*node); end

  def accept_rule(*node); end

  def accept_verbatim(*node); end

  def end_accepting(); end

  def initialize(); end

  def start_accepting(); end
end

class YARD::Templates::Helpers::Markup::RDocMarkup::MARKUP::ToJoinedParagraph
end

class YARD::Templates::Helpers::Markup::RDocMarkup::MARKUP::ToLabel
  def accept_blank_line(*node); end

  def accept_block_quote(*node); end

  def accept_heading(*node); end

  def accept_list_end(*node); end

  def accept_list_item_end(*node); end

  def accept_list_item_start(*node); end

  def accept_list_start(*node); end

  def accept_paragraph(*node); end

  def accept_raw(*node); end

  def accept_rule(*node); end

  def accept_verbatim(*node); end

  def convert(text); end

  def end_accepting(*node); end

  def handle_regexp_CROSSREF(target); end

  def handle_regexp_HARD_BREAK(*node); end

  def handle_regexp_TIDYLINK(target); end

  def initialize(markup=T.unsafe(nil)); end

  def res(); end

  def start_accepting(*node); end
end

class YARD::Templates::Helpers::Markup::RDocMarkup::MARKUP::ToLabel
end

class YARD::Templates::Helpers::Markup::RDocMarkup::MARKUP::ToMarkdown
  def gen_url(url, text); end

  def handle_rdoc_link(url); end

  def handle_regexp_RDOCLINK(target); end

  def handle_regexp_TIDYLINK(target); end
end

class YARD::Templates::Helpers::Markup::RDocMarkup::MARKUP::ToMarkdown
end

class YARD::Templates::Helpers::Markup::RDocMarkup::MARKUP::ToRdoc
  def accept_blank_line(blank_line); end

  def accept_block_quote(block_quote); end

  def accept_heading(heading); end

  def accept_indented_paragraph(paragraph); end

  def accept_list_end(list); end

  def accept_list_item_end(list_item); end

  def accept_list_item_start(list_item); end

  def accept_list_start(list); end

  def accept_paragraph(paragraph); end

  def accept_raw(raw); end

  def accept_rule(rule); end

  def accept_verbatim(verbatim); end

  def attributes(text); end

  def end_accepting(); end

  def handle_regexp_HARD_BREAK(target); end

  def handle_regexp_SUPPRESSED_CROSSREF(target); end

  def indent(); end

  def indent=(indent); end

  def init_tags(); end

  def initialize(markup=T.unsafe(nil)); end

  def list_index(); end

  def list_type(); end

  def list_width(); end

  def prefix(); end

  def res(); end

  def start_accepting(); end

  def use_prefix(); end

  def width(); end

  def width=(width); end

  def wrap(text); end
end

class YARD::Templates::Helpers::Markup::RDocMarkup::MARKUP::ToRdoc
end

class YARD::Templates::Helpers::Markup::RDocMarkup::MARKUP::ToTableOfContents
  def accept_blank_line(*node); end

  def accept_block_quote(*node); end

  def accept_heading(heading); end

  def accept_list_end(*node); end

  def accept_list_end_bullet(*node); end

  def accept_list_item_end(*node); end

  def accept_list_item_start(*node); end

  def accept_list_start(*node); end

  def accept_paragraph(*node); end

  def accept_raw(*node); end

  def accept_rule(*node); end

  def accept_verbatim(*node); end

  def end_accepting(); end

  def initialize(); end

  def omit_headings_below(); end

  def omit_headings_below=(omit_headings_below); end

  def res(); end

  def start_accepting(); end

  def suppressed?(heading); end
end

class YARD::Templates::Helpers::Markup::RDocMarkup::MARKUP::ToTableOfContents
  def self.to_toc(); end
end

class YARD::Templates::Helpers::Markup::RDocMarkup::MARKUP::ToTest
  def accept_blank_line(blank_line); end

  def accept_heading(heading); end

  def accept_list_end(list); end

  def accept_list_item_end(list_item); end

  def accept_list_item_start(list_item); end

  def accept_list_start(list); end

  def accept_paragraph(paragraph); end

  def accept_raw(raw); end

  def accept_rule(rule); end

  def accept_verbatim(verbatim); end

  def end_accepting(); end

  def start_accepting(); end
end

class YARD::Templates::Helpers::Markup::RDocMarkup::MARKUP::ToTest
end

class YARD::Templates::Helpers::Markup::RDocMarkup::MARKUP::ToTtOnly
  def accept_blank_line(markup_item); end

  def accept_block_quote(block_quote); end

  def accept_heading(markup_item); end

  def accept_list_end(list); end

  def accept_list_item_end(markup_item); end

  def accept_list_item_start(list_item); end

  def accept_list_start(list); end

  def accept_paragraph(paragraph); end

  def accept_raw(markup_item); end

  def accept_rule(markup_item); end

  def accept_verbatim(markup_item); end

  def do_nothing(markup_item); end

  def end_accepting(); end

  def initialize(markup=T.unsafe(nil)); end

  def list_type(); end

  def res(); end

  def start_accepting(); end

  def tt_sections(text); end
end

class YARD::Templates::Helpers::Markup::RDocMarkup::MARKUP::ToTtOnly
end

class YARD::Templates::Helpers::Markup::RDocMarkup::MARKUP::Verbatim
  def format(); end

  def format=(format); end

  def normalize(); end

  def ruby?(); end
end

class YARD::Templates::Helpers::Markup::RDocMarkup::MARKUP::Verbatim
end

class YARD::Templates::Helpers::Markup::RDocMarkup::MARKUP
  def self.parse(str); end
end

class YARD::Templates::Helpers::Markup::RDocMarkup
end

module YARD::Templates::Helpers::MarkupHelper
  def load_markup_provider(type=T.unsafe(nil)); end

  def markup_class(type=T.unsafe(nil)); end

  def markup_file_contents(contents); end

  def markup_for_file(contents, filename); end

  def markup_provider(type=T.unsafe(nil)); end
  MARKUP_EXTENSIONS = ::T.let(nil, ::T.untyped)
  MARKUP_FILE_SHEBANG = ::T.let(nil, ::T.untyped)
  MARKUP_PROVIDERS = ::T.let(nil, ::T.untyped)
end

module YARD::Templates::Helpers::MarkupHelper
  def self.clear_markup_cache(); end

  def self.markup_cache(); end

  def self.markup_cache=(markup_cache); end
end

module YARD::Templates::Helpers::MethodHelper
  def format_args(object); end

  def format_block(object); end

  def format_code(object, _show_lines=T.unsafe(nil)); end

  def format_constant(value); end

  def format_lines(object); end

  def format_return_types(object); end
end

module YARD::Templates::Helpers::MethodHelper
end

module YARD::Templates::Helpers::ModuleHelper
  def prune_method_listing(list, hide_attributes=T.unsafe(nil)); end
end

module YARD::Templates::Helpers::ModuleHelper
end

module YARD::Templates::Helpers::TextHelper
  def align_right(text, spacer=T.unsafe(nil), col=T.unsafe(nil)); end

  def h(text); end

  def hr(col=T.unsafe(nil), sep=T.unsafe(nil)); end

  def indent(text, len=T.unsafe(nil)); end

  def signature(meth); end

  def title_align_right(text, col=T.unsafe(nil)); end

  def wrap(text, col=T.unsafe(nil)); end
end

module YARD::Templates::Helpers::TextHelper
end

module YARD::Templates::Helpers::UMLHelper
  def format_path(object); end

  def h(text); end

  def tidy(data); end

  def uml_visibility(object); end
end

module YARD::Templates::Helpers::UMLHelper
end

class YARD::Templates::Section
  def <<(*args); end

  def ==(other); end

  def [](*args); end

  def any(item); end

  def eql?(other); end

  def initialize(name, *args); end

  def name(); end

  def name=(name); end

  def place(*args); end

  def push(*args); end

  def unshift(*args); end
end

class YARD::Templates::Section
end

module YARD::Templates::Template
  include ::YARD::Templates::ErbCache
  include ::YARD::Templates::Helpers::BaseHelper
  include ::YARD::Templates::Helpers::MethodHelper
  def T(*path); end

  def class(); end

  def class=(_); end

  def erb(section, &block); end

  def erb_file_for(section); end

  def erb_with(content, filename=T.unsafe(nil)); end

  def file(basename, allow_inherited=T.unsafe(nil)); end

  def init(); end

  def initialize(opts=T.unsafe(nil)); end

  def inspect(); end

  def options(); end

  def options=(value); end

  def run(opts=T.unsafe(nil), sects=T.unsafe(nil), start_at=T.unsafe(nil), break_first=T.unsafe(nil), &block); end

  def section(); end

  def section=(section); end

  def sections(*args); end

  def superb(sect=T.unsafe(nil), &block); end

  def yieldall(opts=T.unsafe(nil), &block); end
end

module YARD::Templates::Template::ClassMethods
  def S(*args); end

  def T(*path); end

  def find_file(basename); end

  def find_nth_file(basename, index=T.unsafe(nil)); end

  def full_path(); end

  def full_path=(full_path); end

  def full_paths(); end

  def initialize(path, full_paths); end

  def is_a?(klass); end

  def new(*args); end

  def path(); end

  def path=(path); end

  def reset_full_paths(); end

  def run(*args); end
end

module YARD::Templates::Template::ClassMethods
end

module YARD::Templates::Template
  def self.extra_includes(); end

  def self.extra_includes=(extra_includes); end

  def self.include_extra(template, options); end

  def self.included(klass); end
end

class YARD::Verifier
  def add_expressions(*expressions); end

  def call(object); end

  def expressions(); end

  def expressions=(value); end

  def initialize(*expressions); end

  def method_missing(sym, *args, &block); end

  def o(); end

  def object(); end

  def run(list); end
  NILCLASS_METHODS = ::T.let(nil, ::T.untyped)
end

class YARD::Verifier
end

class Zlib::Deflate
  def initialize(*_); end
end

class Zlib::GzipReader
  def initialize(*_); end
end

class Zlib::GzipWriter
  def initialize(*_); end
end

class Zlib::Inflate
  def initialize(*_); end
end
